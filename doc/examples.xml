<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  examples.xml         RCWA documentation          Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$     ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:Examples"><Heading>Examples</Heading>

This chapter lists some <Q>nice</Q> examples of rcwa mappings and -groups.
The rcwa mappings mentioned in this chapter can be found in the file
<F>pkg/rcwa/examples/examples.g</F>, so there is no need to extract them
from the manual files. This file can be read into the current &GAP; session
by issueing <C>RCWAReadExamples( );</C>.

<!-- #################################################################### -->

<Section Label="sec:SlowlyContractingMapping">
<Heading>
  An rcwa mapping which seems to be contracting, but very slow
</Heading>

The iterates of an integer under the Collatz mapping <M>T</M> seem to
approach its contraction centre -- this is the finite set where all
trajectories end up after a finite number of steps -- rather quickly and
do not get very large before doing so (of course this is a purely heuristic
statement as the Collatz conjecture has not been proved so far!):

<Example>
<![CDATA[
gap> T := RcwaMapping([[1,0,2],[3,1,2]]);;
gap> S0 := ContractionCentre(T,100,1000);
[ -136, -91, -82, -68, -61, -55, -41, -37, -34, -25, -17, -10, -7, -5, -1, 0, 
  1, 2 ]
gap> S0^T = S0; # This holds by definition of the contraction centre.
true
gap> Trajectory(T,15,S0,"stop");
[ 15, 23, 35, 53, 80, 40, 20, 10, 5, 8, 4, 2 ]
gap> Trajectory(T,27,S0,"stop");
[ 27, 41, 62, 31, 47, 71, 107, 161, 242, 121, 182, 91, 137, 206, 103, 155, 
  233, 350, 175, 263, 395, 593, 890, 445, 668, 334, 167, 251, 377, 566, 283, 
  425, 638, 319, 479, 719, 1079, 1619, 2429, 3644, 1822, 911, 1367, 2051, 
  3077, 4616, 2308, 1154, 577, 866, 433, 650, 325, 488, 244, 122, 61, 92, 46, 
  23, 35, 53, 80, 40, 20, 10, 5, 8, 4, 2 ]
gap> List([1..100],n->Length(Trajectory(T,n,S0,"stop")));
[ 1, 1, 5, 2, 4, 6, 11, 3, 13, 5, 10, 7, 7, 12, 12, 4, 9, 14, 14, 6, 6, 11, 
  11, 8, 16, 8, 70, 13, 13, 13, 67, 5, 18, 10, 10, 15, 15, 15, 23, 7, 69, 7, 
  20, 12, 12, 12, 66, 9, 17, 17, 17, 9, 9, 71, 71, 14, 22, 14, 22, 14, 14, 
  68, 68, 6, 19, 19, 19, 11, 11, 11, 65, 16, 73, 16, 11, 16, 16, 24, 24, 8, 
  16, 70, 70, 8, 8, 21, 21, 13, 21, 13, 59, 13, 13, 67, 67, 10, 75, 18, 18, 
  18 ]
gap> Maximum(List([1..1000],n->Length(Trajectory(T,n,S0,"stop"))));
113
gap> Maximum(List([1..1000],n->Maximum(Trajectory(T,n,S0,"stop"))));
125252
]]>
</Example>

In the sequel, an example of another mapping is given, which is probably
also contracting, but yields much longer trajectories:

<Log>
<![CDATA[
gap> f6 := RcwaMapping([[ 1,0,6],[ 5, 1,6],[ 7,-2,6],
>                       [11,3,6],[11,-2,6],[11,-1,6]]);;
gap> SetName(f6,"f6");
gap> Display(f6);

Integral rcwa mapping with modulus 6

                n mod 6                |                 n^f6
---------------------------------------+--------------------------------------
  0                                    | n/6
  1                                    | (5n + 1)/6
  2                                    | (7n - 2)/6
  3                                    | (11n + 3)/6
  4                                    | (11n - 2)/6
  5                                    | (11n - 1)/6

gap> S0 := ContractionCentre(f6,1000,100000);;
gap> Trajectory(f6,25,S0,"stop");
[ 25, 21, 39, 72, 12, 2 ]
gap> List([1..100],n->Length(Trajectory(f6,n,S0,"stop")));
[ 2, 2, 3, 4, 2, 2, 3, 2, 2, 5, 7, 2, 8, 17, 3, 16, 2, 4, 17, 6, 5, 2, 5, 5, 
  6, 2, 4, 2, 15, 2, 2, 3, 2, 5, 13, 3, 2, 3, 4, 2, 8, 4, 4, 2, 7, 19, 23517, 
  3, 9, 3, 2, 18, 14, 2, 20, 23512, 14, 2, 6, 6, 2, 4, 19, 12, 23511, 8, 
  23513, 10, 2, 13, 13, 3, 2, 23517, 7, 20, 7, 9, 9, 6, 12, 8, 6, 18, 14, 
  23516, 31, 12, 23545, 4, 21, 19, 5, 2, 17, 17, 13, 19, 6, 23515 ]
gap> Maximum(Trajectory(f6,47,S0,"stop"));;
736339177776247330443187705477107581873369010805146980871580925673774229545698\
886054
]]>
</Log>

Computing the trajectory of 3224 takes quite a while -- it ascends to
about <M>3 \cdot 10^{2197}</M>, before it approaches the fixed point&nbsp;2
after 19949562 steps. <P/>

When constructing the mapping <C>f6</C>, the denominators of the
partial mappings have been chosen to be equal and the numerators have
been chosen to be numbers coprime to the common denominator, whose product
is just a little bit smaller than the <C>Modulus(f6)</C>th power of the
denominator. In the example we have <M>5 \cdot 7 \cdot 11^3 = 46585</M>
and <M>6^6 = 46656</M>. <P/>

Although the trajectories of <C>T</C> are much shorter than those of
<C>f6</C>, it seems likely that this does not make the problem of deciding
whether the mapping&nbsp;<C>T</C> is contracting essentially easier --
even for mappings with much shorter trajectories than&nbsp;<C>T</C>
the problem seems to be equally hard -- provided that it is not trivial,
i.e. that there is no <M>k</M> such that applying the <M>k</M>th power of
the respective mapping to any integer decreases its absolute value.

</Section>

<!-- #################################################################### -->

<Section Label="sec:AndaloroResult">
<Heading>Checking a result by P. Andaloro</Heading>

In <Cite Key="Andaloro00"/>, P.&nbsp;Andaloro has shown that proving that
trajectories of integers <M>n \in 1(16)</M> under the Collatz mapping always
end up with&nbsp;1 would be sufficient for proving the Collatz conjecture.
In the sequel, this result should be verified with &RCWA;. Checking that the
union of the images of the residue class 1(16) under powers of the Collatz
mapping&nbsp;<M>T</M> contains <M>\mathbb{Z} \setminus 0(3)</M> is obviously
sufficient. Thus we proceed by setting <M>S := 1(16)</M> and successively
uniting the set <M>S</M> with its image under&nbsp;<M>T</M>:

<Example>
<![CDATA[
gap> S := ResidueClass(Integers,16,1);
1(16)
gap> S := Union(S,S^T);
1(16) U 2(24)
gap> S := Union(S,S^T);
1(12) U 2(24) U 17(48) U 33(48)
gap> S := Union(S,S^T);
<union of 30 residue classes (mod 144)>
gap> S := Union(S,S^T);
<union of 42 residue classes (mod 144)>
gap> S := Union(S,S^T);
<union of 172 residue classes (mod 432)>
gap> S := Union(S,S^T);
<union of 676 residue classes (mod 1296)>
gap> S := Union(S,S^T);
<union of 810 residue classes (mod 1296)>
gap> S := Union(S,S^T);
<union of 2638 residue classes (mod 3888)>
gap> S := Union(S,S^T);
<union of 33 residue classes (mod 48)>
gap> S := Union(S,S^T);
<union of 33 residue classes (mod 48)>
gap> Union(S,ResidueClass(Integers,3,0)); # Et voila ...
Integers
]]>
</Example>

Further similar computations are shown in
Section&nbsp;<Ref Label="sec:CollatzImagesAndPreImages"/>.

</Section>

<!-- #################################################################### -->

<Section Label="sec:MatthewsLeighExamples">
<Heading>Two examples by Matthews and Leigh</Heading>

In <Cite Key="MatthewsLeigh87"/>, K.&nbsp;R.&nbsp;Matthews and
G.&nbsp;M.&nbsp;Leigh have shown that two trajectories of the following
(surjective, but not injective) mappings are acyclic (mod&nbsp;<M>x</M>)
and divergent:

<Example>
<![CDATA[
gap> x := Indeterminate(GF(4),1);; SetName(x,"x");
gap> R := PolynomialRing(GF(2),1);
GF(2)[x]
gap> ML1 := RcwaMapping(R,x,[[1,0,x],[(x+1)^3,1,x]]*One(R));;
gap> ML2 := RcwaMapping(R,x,[[1,0,x],[(x+1)^2,1,x]]*One(R));;
gap> SetName(ML1,"ML1"); SetName(ML2,"ML2");
gap> Display(ML1);

Rcwa mapping of GF(2)[x] with modulus x

         P mod x          |                       P^ML1
--------------------------+---------------------------------------------------
 0*Z(2)                   | P/x
 Z(2)^0                   | ((x^3+x^2+x+Z(2)^0)*P + Z(2)^0)/x

gap> Display(ML2);

Rcwa mapping of GF(2)[x] with modulus x

         P mod x          |                       P^ML2
--------------------------+---------------------------------------------------
 0*Z(2)                   | P/x
 Z(2)^0                   | ((x^2+Z(2)^0)*P + Z(2)^0)/x

gap> List([ML1,ML2],IsSurjective);
[ true, true ]
gap> List([ML1,ML2],IsInjective);
[ false, false ]
gap> traj1 := Trajectory(ML1,One(R),20,"length");
[ Z(2)^0, x^2+x+Z(2)^0, x^4+x^2+x, x^3+x+Z(2)^0, x^5+x^4+x^2, x^4+x^3+x, 
  x^3+x^2+Z(2)^0, x^5+x^2+Z(2)^0, x^7+x^6+x^5+x^3+Z(2)^0, 
  x^9+x^7+x^6+x^5+x^3+x+Z(2)^0, x^11+x^10+x^8+x^7+x^6+x^5+x^2, 
  x^10+x^9+x^7+x^6+x^5+x^4+x, x^9+x^8+x^6+x^5+x^4+x^3+Z(2)^0, 
  x^11+x^8+x^7+x^6+x^4+x+Z(2)^0, x^13+x^12+x^11+x^8+x^7+x^6+x^4, 
  x^12+x^11+x^10+x^7+x^6+x^5+x^3, x^11+x^10+x^9+x^6+x^5+x^4+x^2, 
  x^10+x^9+x^8+x^5+x^4+x^3+x, x^9+x^8+x^7+x^4+x^3+x^2+Z(2)^0, 
  x^11+x^9+x^8+x^4+x^3+x^2+Z(2)^0 ]
gap> traj2 := Trajectory(ML2,(x^3+x+1)*One(R),20,"length");
[ x^3+x+Z(2)^0, x^4+x+Z(2)^0, x^5+x^3+x^2+x+Z(2)^0, x^6+x^3+Z(2)^0, 
  x^7+x^5+x^4+x^2+x, x^6+x^4+x^3+x+Z(2)^0, x^7+x^4+x^3+x+Z(2)^0, 
  x^8+x^6+x^5+x^4+x^3+x+Z(2)^0, x^9+x^6+x^3+x+Z(2)^0, 
  x^10+x^8+x^7+x^5+x^4+x+Z(2)^0, x^11+x^8+x^7+x^5+x^4+x^3+x^2+x+Z(2)^0, 
  x^12+x^10+x^9+x^8+x^7+x^5+Z(2)^0, x^13+x^10+x^7+x^4+x, 
  x^12+x^9+x^6+x^3+Z(2)^0, x^13+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x, 
  x^12+x^10+x^9+x^7+x^6+x^4+x^3+x+Z(2)^0, 
  x^13+x^10+x^9+x^7+x^6+x^4+x^3+x+Z(2)^0, 
  x^14+x^12+x^11+x^10+x^9+x^7+x^6+x^4+x^3+x+Z(2)^0, 
  x^15+x^12+x^9+x^7+x^6+x^4+x^3+x+Z(2)^0, 
  x^16+x^14+x^13+x^11+x^10+x^7+x^6+x^4+x^3+x+Z(2)^0 ]
]]>
</Example>

The pattern which Matthews and Leigh used to show the divergence of the
above trajectories can be recognized easily by looking at the corresponding
Markov chains with the two states 0&nbsp;mod&nbsp;<M>x</M> and
1&nbsp;mod&nbsp;<M>x</M>:

<Example>
<![CDATA[
gap> traj1modx := Trajectory(ML1,One(R),400,"length") mod x;;
gap> traj2modx := Trajectory(ML2,(x^3+x+1)*One(R),600,"length") mod x;;
gap> List(traj1modx{[1..200]},val->Position([Zero(R),One(R)],val)-1);
[ 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 
  1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
gap> List(traj2modx{[1..200]},val->Position([Zero(R),One(R)],val)-1);
[ 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 
  0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
]]>
</Example>

What is important here are the lengths of the intervals between two changes
from one state to the other:

<Example>
<![CDATA[
gap> ChangePoints := l -> Filtered([1..Length(l)-1],pos->l[pos]<>l[pos+1]);;
gap> Diffs := l -> List([1..Length(l)-1],pos->l[pos+1]-l[pos]);;
gap> Diffs(ChangePoints(traj1modx)); # The pattern in the first ...
[ 1, 1, 2, 4, 2, 2, 4, 8, 4, 4, 8, 16, 8, 8, 16, 32, 16, 16, 32, 64, 32, 32, 
  64 ]
gap> Diffs(ChangePoints(traj2modx)); # ... and in the second example.
[ 1, 7, 1, 1, 1, 13, 1, 1, 1, 1, 1, 1, 1, 25, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 49, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 97, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
gap> Diffs(ChangePoints(last)); # Make this a bit more obvious.
[ 1, 3, 1, 7, 1, 15, 1, 31, 1, 63, 1 ]
]]>
</Example>

This looks clearly acyclic, thus the trajectories diverge.
Needless to say however that this computational evidence does not replace
the proof along these lines given in the article cited above, but just
sheds a light on the idea behind it.

</Section>

<!-- #################################################################### -->

<Section Label="sec:WildProductOfInvolutions">
<Heading>
  Three involutions whose product has coprime multiplier and divisor
</Heading>

It is not very easy to find tame mappings whose product is not balanced, i.e.
there are primes dividing only the multiplier and not the divisor or vice
versa. But there are even such mappings of finite order whose product has
coprime multiplier and divisor. This is interesting in the context of the
question how a non-trivial normal subgroup of RCWA(<M>\Z</M>) can look like.
From the existence of mappings having the mentioned properties it follows
that the mappings having non-coprime multiplier and divisor do not even form
a subgroup. <P/>

We investigate an example of 3 conjugate involutions whose product is not
only wild, but even has coprime multiplier and divisor.

<Example>
<![CDATA[
gap> rc := function(r,m) return ResidueClass(DefaultRing(m),m,r); end;;
gap> f1 := RcwaMapping([[rc(1,6),rc(0, 8)],[rc(5,6),rc(4, 8)]]);;
gap> f2 := RcwaMapping([[rc(1,6),rc(0, 4)],[rc(5,6),rc(2, 4)]]);;
gap> f3 := RcwaMapping([[rc(2,6),rc(1,12)],[rc(4,6),rc(7,12)]]);;
gap> SetName(f1,"f1"); SetName(f2,"f2"); SetName(f3,"f3");
gap> List([f1,f2,f3],Order);
[ 2, 2, 2 ]
gap> Display(f1);

Bijective rcwa mapping of Z with modulus 24, of order 2

               n mod 24                |                 n^f1
---------------------------------------+--------------------------------------
   0  8 16                             | (3n + 4)/4
   1  7 13 19                          | (4n - 4)/3
   2  3  6  9 10 14 15 18 21 22        | n
   4 12 20                             | (3n + 8)/4
   5 11 17 23                          | (4n - 8)/3

gap> Display(f2);

Bijective rcwa mapping of Z with modulus 12, of order 2

               n mod 12                |                 n^f2
---------------------------------------+--------------------------------------
   0  4  8                             | (3n + 2)/2
   1  7                                | (2n - 2)/3
   2  6 10                             | (3n + 4)/2
   3  9                                | n
   5 11                                | (2n - 4)/3

gap> Display(f3);

Bijective rcwa mapping of Z with modulus 12, of order 2

               n mod 12                |                 n^f3
---------------------------------------+--------------------------------------
   0  3  5  6  9 11                    | n
   1                                   | (n + 3)/2
   2  8                                | 2n - 3
   4 10                                | 2n - 1
   7                                   | (n + 1)/2

gap> f := f1*f2*f3;
<bijective rcwa mapping of Z with modulus 12>
gap> IsTame(f);
false
gap> Display(f);

Wild bijective rcwa mapping of Z with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0                                   | n/2
   1  7                                | n + 1
   2  6 10                             | (3n + 4)/2
   3  9                                | n
   4                                   | n - 3
   5  8 11                             | n - 1

gap> List([1..8],k->Modulus(f^k));
[ 12, 24, 48, 96, 192, 384, 768, 1536 ]
gap> List([1..8],k->[Multiplier(f^k),Divisor(f^k)]);
[ [ 3, 2 ], [ 3, 4 ], [ 9, 8 ], [ 9, 16 ], [ 27, 32 ], [ 27, 64 ], 
  [ 81, 128 ], [ 81, 256 ] ]
gap> List([1..8],k->Length(Set(Coefficients(f^k))));
[ 6, 8, 12, 14, 20, 24, 32, 40 ]
gap> support := List([1..8],k->MovedPoints(f^k));;
gap> for k in [1..8] do View(support[k]); Print("\n"); od;
0(2) U 1(6) U 5(6) \ [ 0 ]
2(4) U 5(6) U 0(12) U 1(12) U 4(12) \ [ -2, -1, 0 ]
0(2) U 1(6) U 5(6) \ [ 0 ]
2(4) U 5(6) U 0(12) U 1(12) U 4(12) \ [ -2, -1, 0, 1, 2, 4, 5 ]
0(2) U 1(6) U 5(6) \ [ 0 ]
2(4) U 5(6) U 0(12) U 1(12) U 4(12) \ [ -2, -1, 0 ]
0(2) U 1(6) U 5(6) \ [ 0 ]
2(4) U 5(6) U 0(12) U 1(12) U 4(12) \ [ -2, -1, 0, 1, 2, 4, 5 ]
gap> List(support,Density);
[ 5/6, 2/3, 5/6, 2/3, 5/6, 2/3, 5/6, 2/3 ]
gap> for S in Set(support) do View(S); Print("\n"); od;
0(2) U 1(6) U 5(6) \ [ 0 ]
2(4) U 5(6) U 0(12) U 1(12) U 4(12) \ [ -2, -1, 0 ]
2(4) U 5(6) U 0(12) U 1(12) U 4(12) \ [ -2, -1, 0, 1, 2, 4, 5 ]
gap> G := Group(f1,f2,f3);
<rcwa group over Z with 3 generators>
gap> MovedPoints(G);
0(2) U 1(6) U 5(6)
]]>
</Example>

The involutions <C>f1</C>, <C>f2</C> and <C>f3</C> are conjugate
in RCWA(<M>\mathbb{Z}</M>):

<Example>
<![CDATA[
gap> IsConjugate(RCWA(Integers),f1,f2);
true
gap> IsConjugate(RCWA(Integers),f2,f3);
true
gap> g12 := RepresentativeAction(RCWA(Integers),f1,f2);
<bijective rcwa mapping of Z with modulus 1440>
gap> g23 := RepresentativeAction(RCWA(Integers),f2,f3);
<bijective rcwa mapping of Z with modulus 216>
gap> g13 := RepresentativeAction(RCWA(Integers),f1,f3);
<bijective rcwa mapping of Z with modulus 288>
gap> SetName(g12,"g12"); SetName(g23,"g23"); SetName(g13,"g13");
gap> List([g12,g23,g13],g->[Multiplier(g),Divisor(g)]);
[ [ 540, 80 ], [ 40, 18 ], [ 60, 12 ] ]
gap> List([g12,g23,g13],IsTame);
[ false, false, false ]
gap> f1^g13=f3;    # A verification of one of the conjugators.
true
gap> List([g12,g23,g13],g->Length(Set(Coefficients(g))));
[ 95, 57, 27 ]
gap> Display(g13); # Display the `shortest' one of the mappings g12, g23, g13.

Wild bijective rcwa mapping of Z with modulus 288

               n mod 288               |                n^g13
---------------------------------------+--------------------------------------
    0  24  48  72  96 120 144 168 192  | 
  216 240 264                          | 3n + 1
    1  19  37  55  73  91 109 127 145  | 
  163 181 199 217 235 253 271          | 2n
    2  38  74 110 146 182 218 254      | (5n - 10)/6
    3  27  39  63  75  99 111 135 147  | 
  171 183 207 219 243 255 279          | (5n + 3)/6
    4  28  52  76 100 124 148 172 196  | 
  220 244 268                          | 6n - 17
    5  23  41  59  77  95 113 131 149  | 
  167 185 203 221 239 257 275          | 4n - 16
    6  18  42  54  78  90 114 126 150  | 
  162 186 198 222 234 258 270          | 5n/6
    7  13  31  79  85 103 151 157 175  | 
  223 229 247                          | n + 3
    8  16  40 104 112 136 200 208 232  | (3n + 14)/2
    9  45  81 117 153 189 225 261      | (5n - 9)/6
   10  34  46  70  82 106 118 142 154  | 
  178 190 214 226 250 262 286          | (5n + 4)/6
   11  35  83 107 155 179 227 251      | (n + 5)/2
   12  44 108 140 204 236              | (3n + 16)/4
   14  26  50  62  86  98 122 134 158  | 
  170 194 206 230 242 266 278          | (5n - 4)/6
   15  21  33  51  57  69  87  93 105  | 
  123 129 141 159 165 177 195 201 213  | 
  231 237 249 267 273 285              | (5n - 3)/6
   17  89 161 233                      | n + 5
   20 116 212                          | (3n + 26)/2
   22  58  94 130 166 202 238 274      | (5n - 2)/6
   25  49  97 121 169 193 241 265      | (n + 3)/2
   29  47  53  71 101 119 125 143 173  | 
  191 197 215 245 263 269 287          | n - 1
   30  66 102 138 174 210 246 282      | (5n - 6)/6
   32  64 128 160 224 256              | (3n + 4)/4
   36  60  68  92 132 156 164 188 228  | 
  252 260 284                          | (3n + 2)/2
   43  61  67 115 133 139 187 205 211  | 
  259 277 283                          | n - 3
   56  80  88 152 176 184 248 272 280  | (3n - 10)/2
   65 137 209 281                      | (n - 1)/2
   84 180 276                          | (3n - 8)/4

gap> List([g12,g23,g13],MovedPoints);
[ Integers, Z \ [ -23, -2, 1, 25 ], Z \ [ -6, -3, 3 ] ]
]]>
</Example>

The products <C>f1*f3</C> and <C>f2*f3</C> seem to have only finite cycles,
but <C>f1*f2</C> has also infinite ones:

<Example>
<![CDATA[
gap> f12 := f1*f2;
<bijective rcwa mapping of Z with modulus 12>
gap> f23 := f2*f3;
<bijective rcwa mapping of Z with modulus 72>
gap> f13 := f1*f3;
<bijective rcwa mapping of Z with modulus 144>
gap> List([1..4],k->Maximum(List([-10^k..10^k],n->Length(Cycle(f13,n)))));
[ 14, 20, 42, 46 ]
gap> List([1..4],k->Maximum(List([-10^k..10^k],n->Length(Cycle(f23,n)))));
[ 8, 20, 32, 38 ]
gap> Set(List([-1000..1000],n->Length(Cycle(f13,n))));
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 
  22, 23, 24, 25, 26, 27, 30, 42 ]
gap> Set(List([-1000..1000],n->Length(Cycle(f23,n))));
[ 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 28, 32 ]
gap> Trajectory(f12,2,30,"length");
[ 2, 5, 7, 13, 25, 49, 97, 193, 385, 769, 1537, 3073, 6145, 12289, 24577, 
  49153, 98305, 196609, 393217, 786433, 1572865, 3145729, 6291457, 12582913, 
  25165825, 50331649, 100663297, 201326593, 402653185, 805306369 ]
gap> LogInt(Trajectory(f12,2,1000,"length")[1000],10);
300
gap> Trajectory(f12,2,20,"length") mod 12;
[ 2, 5, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
gap> Display(f12); # Once a trajectory enters 1(12), it gets stuck there:

Bijective rcwa mapping of Z with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0  4  8                             | n/2
   1  7                                | 2n - 1
   2  6 10                             | (3n + 4)/2
   3  9                                | n
   5 11                                | 2n - 3

gap> S := [ResidueClass(Integers,12,1)];; # Compute preimages of 1(12):
gap> for i in [1..10] do Add(S,PreImage(f12,S[i])); od;
gap> for i in [1..11] do View(S[i]); Print("\n"); od;
1(12)
1(6)
1(6) U 5(6)
2(4) U 1(6) U 5(6)
2(4) U 1(6) U 5(6) U 4(8)
<union of 37 residue classes (mod 48)>
<union of 77 residue classes (mod 96)>
<union of 157 residue classes (mod 192)>
<union of 317 residue classes (mod 384)>
<union of 637 residue classes (mod 768)>
<union of 1277 residue classes (mod 1536)>
gap> List(S,Si->Float(Density(Si)));
[ 0.0833333, 0.166667, 0.333333, 0.583333, 0.708333, 0.770833, 0.802083, 
  0.817708, 0.825521, 0.829427, 0.83138 ]
gap> Clmod12 := List([0..11],r->ResidueClass(Integers,12,r));
[ 0(12), 1(12), 2(12), 3(12), 4(12), 5(12), 6(12), 7(12), 8(12), 9(12), 
  10(12), 11(12) ]
gap> List(Clmod12,cl->Intersection(cl,S[2]));
[ [  ], 1(12), [  ], [  ], [  ], [  ], [  ], 7(12), [  ], [  ], [  ], [  ] ]
gap> List(Clmod12,cl->Intersection(cl,S[5]));
[ 12(24), 1(12), 2(12), [  ], 4(24), 5(12), 6(12), 7(12), 20(24), [  ], 
  10(12), 11(12) ]
gap> List(Clmod12,cl->Intersection(cl,S[6]));
[ 12(24) U 24(48), 1(12), 2(12), [  ], 4(24) U 40(48), 5(12), 6(12), 7(12), 
  20(24) U 8(48), [  ], 10(12), 11(12) ]
gap> List(Clmod12,cl->Intersection(cl,S[8]));
[ 12(24) U 24(48) U 48(96) U 96(192), 1(12), 2(12), [  ], 
  4(24) U 40(48) U 16(96) U 160(192), 5(12), 6(12), 7(12), 
  20(24) U 8(48) U 80(96) U 32(192), [  ], 10(12), 11(12) ]
]]>
</Example>

We see that except of the fixed points <M>n \equiv 3</M>&nbsp;mod&nbsp;6 and
<M>n = 0</M>, <Q>everything is eventually mapped to 1(12)</Q> --
thus that any non-constant trajectory is divergent.

As already observed, the situation concerning <C>f13</C> and <C>f23</C>
looks quite a bit different. We take a closer look at the <Q>smaller</Q> one
of these two examples:

<Example>
<![CDATA[
gap> components := FactorizationOnConnectedComponents(f23,Modulus(f23));
[ <rcwa mapping of Z with modulus 72>, <rcwa mapping of Z with modulus 72>, 
  <rcwa mapping of Z with modulus 72> ]
gap> List(components,MovedPoints);
[ 18(24) U 29(36), 6(24) U 11(36), <union of 25 residue classes (mod 36)> \ 
    [ 4, 7, 8, 13 ] ]
gap> List(components{[1,2]},Order); # We can split off two involutions.
[ 2, 2 ]
gap> f23c := components[3];; SetName(f23c,"f23c"); # The complicate part.
gap> f23c^-1;
<bijective rcwa mapping of Z with modulus 72>
gap> Display(f23c);

Bijective rcwa mapping of Z with modulus 72

               n mod 72                |                n^f23c
---------------------------------------+--------------------------------------
   0  8 16 24 32 40 48 56 64           | (3n + 8)/4
   1 19 37 55                          | (2n - 2)/3
   2 10 14 22 26 34 38 46 50 58 62 70  | (3n + 4)/2
   3  6  9 11 15 18 21 27 29 30 33 39  | 
  42 45 47 51 54 57 63 65 66 69        | n
   4 12 20 28 36 44 52 60 68           | (3n + 4)/4
   5 23 41 59                          | (4n - 17)/3
   7 25 43 61                          | (4n - 7)/3
  13 31 49 67                          | (4n - 13)/3
  17 35 53 71                          | (4n - 11)/3

gap> Difference(Integers,MovedPoints(f23c));
3(6) U 6(12) U 11(18) U [ 4, 7, 8, 13 ]
gap> powers := List([1..4],k->f23c^k);
[ f23c, <bijective rcwa mapping of Z with modulus 864>, 
  <bijective rcwa mapping of Z with modulus 10368>, 
  <bijective rcwa mapping of Z with modulus 124416> ]
gap> moved := List(powers,MovedPoints);
[ <union of 25 residue classes (mod 36)> \ [ 4, 7, 8, 13 ], 
  <union of 25 residue classes (mod 36)> \ [ 4, 7, 8, 13 ], 
  <union of 25 residue classes (mod 36)> \ [ 4, 7, 8, 13 ], 
  <union of 230 residue classes (mod 432)> \ [ 4, 7, 8, 13 ] ]
gap> diff := Difference(moved[3],moved[4]);
<union of 70 residue classes (mod 432)>
gap> AsUnionOfFewClasses(diff);
[ 2(36), 10(36), 0(48), 12(48), 5(54), 17(54), 1(72), 19(72) ]
gap> cyc1 := Cycle(f23c,ResidueClass(Integers,72,1));
[ 1(72), 0(48), 2(36), 5(54) ]
gap> cyc2 := Cycle(f23c,ResidueClass(Integers,72,19));
[ 19(72), 12(48), 10(36), 17(54) ]
gap> ord4 := List([cyc1,cyc2],cyc->RestrictedPerm(f23,Union(cyc)));
[ <rcwa mapping of Z with modulus 432>, <rcwa mapping of Z with modulus 432> ]
gap> List(ord4,Order); # We can split off two mappings of order 4.
[ 4, 4 ]
]]>
</Example>

It seems quite likely that this way one can continue successively splitting
off mappings of larger and larger finite order, and that this yields a
decomposition of <C>f23</C> into an infinite number of disjoint <Q>residue
class cycles</Q> like <C>cyc1</C> and <C>cyc2</C> above. The investigations
of the <Q>phenomenon</Q> of wild mappings having only finite cycles will be
continued in Section&nbsp;<Ref Label="sec:WildButFiniteCycles"/>.

</Section>

<!-- #################################################################### -->

<Section Label="sec:StructureOfWildGroup">
<Heading>Exploring the structure of a wild rcwa group</Heading>

In this example, a simple attempt to should be made to investigate the
structure of a given wild group by finding orders of torsion elements.
In general, determining the structure of a given wild group computationally
seems to be a very hard task -- i.e. so far I have not been successful in
trying to determine a finite presentation for a finitely generated wild
rcwa group in any non-trivial case. First of all, the group in question
has to be defineed:

<Example>
<![CDATA[
gap> u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;
gap> SetName(u,"u");
gap> Display(u);

Rcwa mapping of Z with modulus 5

                n mod 5                |                 n^u
---------------------------------------+--------------------------------------
  0                                    | 3n/5
  1                                    | (9n + 1)/5
  2                                    | (3n - 1)/5
  3                                    | (9n - 2)/5
  4                                    | (9n + 4)/5

gap> nu := RcwaMapping([[1,1,1]]);
Rcwa mapping of Z: n -> n + 1
gap> SetName(nu,"nu");
gap> G := Group(u,nu);
<rcwa group over Z with 2 generators>
gap> IsTame(G);
false
]]>
</Example>

Now we would like to know which orders torsion elements of&nbsp;<C>G</C>
can have -- taking a look at the above generators it seems to make sense
to try commutators:

<Example>
<![CDATA[
gap> l := Filtered([0..100],k->IsTame(Comm(u,nu^k)));
[ 0, 2, 3, 5, 6, 9, 10, 12, 13, 15, 17, 18, 20, 21, 24, 25, 27, 28, 30, 32, 
  33, 35, 36, 39, 40, 42, 43, 45, 47, 48, 50, 51, 54, 55, 57, 58, 60, 62, 63, 
  65, 66, 69, 70, 72, 73, 75, 77, 78, 80, 81, 84, 85, 87, 88, 90, 92, 93, 95, 
  96, 99, 100 ]
gap> List(l,k->Order(Comm(u,nu^k)));
[ 1, 6, 5, 3, 5, 5, 3, infinity, 7, infinity, 7, 5, 3, infinity, infinity, 3, 
  5, 7, infinity, 7, infinity, 3, 5, 5, 3, 5, infinity, infinity, infinity, 
  5, 3, 5, 5, 3, infinity, 7, infinity, 7, 5, 3, infinity, infinity, 3, 5, 7, 
  infinity, 7, infinity, 3, 5, 5, 3, 5, infinity, infinity, infinity, 5, 3, 
  5, 5, 3 ]
gap> Display(Comm(u,nu^13));

Bijective rcwa mapping of Z with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0 3 6                                | n + 5
  1 4 7                                | 3n - 9
  2 8                                  | n - 11
  5                                    | (n + 16)/3

gap> Order(Comm(u,nu^13));
7
gap> u2 := u^2;
<wild bijective rcwa mapping of Z with modulus 25>
gap> Filtered([1..16],k->IsTame(Comm(u2,nu^k))); # k < 15 -> commutator wild!
[ 15 ]
gap> Order(Comm(u2,nu^15));
infinity
gap> u2nu17 := Comm(u2,nu^17);
<bijective rcwa mapping of Z with modulus 81>
gap> orbs := ShortOrbits(Group(u2nu17),[-100..100],100);;
gap> List(orbs,Length);
[ 72, 72, 73, 72, 73, 72, 72, 73, 72, 72, 72, 73, 72, 72, 73, 72, 72, 73, 72, 
  72, 73, 72, 72 ]
gap> Lcm(last);
5256
gap> u2nu17^5256; # This element has indeed order 2^3*3^2*73 = 5256.
IdentityMapping( Integers )
gap> u2nu18 := Comm(u2,nu^18);
<bijective rcwa mapping of Z with modulus 81>
gap> orbs := ShortOrbits(Group(u2nu18),[-100..100],100);;
gap> List(orbs,Length);
[ 22, 22, 22, 21, 22, 22, 22, 21, 21, 22, 22, 21, 22, 21, 22, 22, 21, 22, 22, 
  21, 22, 22, 21 ]
gap> Lcm(last);
462
gap> u2nu18^462; # This is an element of order 2*3*7*11 = 462.
IdentityMapping( Integers )
gap> Order(Comm(u2,nu^20));
29
gap> Order(Comm(u2,nu^25));
9
gap> Order(Comm(u2,nu^30));
15
]]>
</Example>

Thus even this rather simple-minded approach reveals various different
orders of torsion elements, and the involved primes are also not all
quite <Q>small</Q>.

</Section>

<!-- #################################################################### -->

<Section Label="sec:WildButFiniteCycles">
<Heading>A wild rcwa mapping which has only finite cycles</Heading>

In Section <Ref Label="sec:WildProductOfInvolutions"/> we have seen
examples of wild rcwa mappings of <M>\mathbb{Z}</M> which seem to have
only finite cycles. In this section we give and examine a mapping which
can be shown to have these properties and is likely to be something like
a <Q>minimal</Q> example.
In the Introduction (<Ref Label="ch:Introduction"/>) we have seen an
example of such an element of RCWA(GF(2)[<M>x</M>]).
It was easy to explain this <Q>phenomenon</Q> by pointing out that
the degree function gives rise to a partition of GF(2)[<M>x</M>] into
finite sets which is left invariant by the given permutation.
Regarding <M>\mathbb{Z}</M> however the situation looks completely
different -- we do not have a <Q>natural</Q> partition into finite sets
which might be fixed by a wild rcwa mapping.

<Example>
<![CDATA[
gap> kappa := RcwaMapping([[1,0,1],[1,0,1],[3,2,2],[1,-1,1],
>                          [2,0,1],[1,0,1],[3,2,2],[1,-1,1],
>                          [1,1,3],[1,0,1],[3,2,2],[2,-2,1]]);;
gap> SetName(kappa,"kappa");
gap> List([-5..5],k->Modulus(kappa^k));
[ 7776, 1296, 432, 72, 24, 1, 12, 72, 144, 864, 1728 ]
gap> Display(kappa);

Bijective rcwa mapping of Z with modulus 12

               n mod 12                |               n^kappa
---------------------------------------+--------------------------------------
   0  1  5  9                          | n
   2  6 10                             | (3n + 2)/2
   3  7                                | n - 1
   4                                   | 2n
   8                                   | (n + 1)/3
  11                                   | 2n - 2

gap> List([-50..50],n->Length(Cycle(kappa,n)));
[ 13, 13, 1, 1, 4, 4, 4, 1, 7, 7, 7, 1, 10, 10, 1, 1, 13, 13, 4, 1, 4, 4, 7, 
  1, 10, 10, 1, 1, 4, 4, 7, 1, 10, 10, 4, 1, 7, 7, 1, 1, 7, 7, 4, 1, 4, 4, 2, 
  1, 1, 2, 1, 1, 4, 4, 4, 1, 7, 7, 4, 1, 7, 7, 1, 1, 10, 10, 7, 1, 4, 4, 7, 
  1, 10, 10, 1, 1, 4, 4, 4, 1, 13, 13, 7, 1, 10, 10, 1, 1, 7, 7, 4, 1, 4, 4, 
  10, 1, 13, 13, 1, 1, 4 ]
gap> List([2..14],k->Maximum(List([1..2^k],n->Length(Cycle(kappa,n)))));
[ 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40 ]
gap> List([2..14],k->Length(Cycle(kappa,2^k-2)));
[ 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40 ]
gap> Cycle(kappa,2^16-2);
[ 65534, 98302, 147454, 221182, 331774, 497662, 746494, 1119742, 1679614, 
  2519422, 3779134, 5668702, 8503054, 12754582, 19131874, 28697812, 57395624, 
  19131875, 38263748, 12754583, 25509164, 8503055, 17006108, 5668703, 
  11337404, 3779135, 7558268, 2519423, 5038844, 1679615, 3359228, 1119743, 
  2239484, 746495, 1492988, 497663, 995324, 331775, 663548, 221183, 442364, 
  147455, 294908, 98303, 196604, 65535 ]
gap> last mod 12;
[ 2, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 4, 8, 11, 8, 11, 
  8, 11, 8, 11, 8, 11, 8, 11, 8, 11, 8, 11, 8, 11, 8, 11, 8, 11, 8, 11, 8, 
  11, 8, 11, 8, 3 ]
gap> lengthstatistics := Collected(List(ShortOrbits(Group(kappa),
>                                                   [1..12^4],100),Length));
[ [ 1, 6912 ], [ 4, 1728 ], [ 7, 864 ], [ 10, 432 ], [ 13, 216 ], 
  [ 16, 108 ], [ 19, 54 ], [ 22, 27 ], [ 25, 13 ], [ 28, 7 ], [ 31, 3 ], 
  [ 34, 2 ], [ 37, 1 ], [ 40, 1 ] ]
]]>
</Example>

We would like to determine a partition of&nbsp;<M>\Z</M> into unions of
cycles of equal length:

<Example>
<![CDATA[
gap> C := [Difference(Integers,MovedPoints(kappa))];; pow := [kappa^0];;
gap> for i in [1..3] do
>      Add(pow,kappa^i);
>      C[i+1] := Difference(rc(2,4),
>                           Union(Union(C{[1..i]}),
>                                 Union(List([0..i],
>                                       j->Intersection(rc(2,4)^pow[j+1],
>                                                       rc(2,4)^(pow[i-j+1]^-1))))));
>    od;
gap> C;
[ 1(4) U 0(12) U [ -2 ], 2(24) U 18(24), 6(48) U 38(48) U 10(72) U 58(72), 
  <union of 38 residue classes (mod 864)> ]
gap> List(C,S->Length(Cycle(kappa,S)));
[ 1, 4, 7, 10 ]
gap> Cycle(kappa,C[1]);
[ 1(4) U 0(12) U [ -2 ] ]
gap> Cycle(kappa,C[2]);
[ 2(24) U 18(24), 4(36) U 28(36), 8(72) U 56(72), 3(24) U 19(24) ]
gap> cycle7 := Cycle(kappa,C[3]);;
gap> for S in cycle7 do View(S); Print("\n"); od;
6(48) U 38(48) U 10(72) U 58(72)
10(72) U 58(72) U 16(108) U 88(108)
16(108) U 88(108) U 32(216) U 176(216)
11(72) U 59(72) U 32(216) U 176(216)
11(72) U 59(72) U 20(144) U 116(144)
7(48) U 39(48) U 20(144) U 116(144)
6(48) U 7(48) U 38(48) U 39(48)
gap> cycle10 := Cycle(kappa,C[4]);;
gap> for S in cycle10 do View(S); Print("\n"); od;
<union of 38 residue classes (mod 864)>
<union of 38 residue classes (mod 1296)>
<union of 12 residue classes (mod 648)>
<union of 12 residue classes (mod 648)>
<union of 22 residue classes (mod 1296)>
<union of 12 residue classes (mod 432)>
<union of 22 residue classes (mod 864)>
<union of 12 residue classes (mod 288)>
<union of 14 residue classes (mod 288)>
<union of 16 residue classes (mod 288)>
gap> List(cycle10,Density);
[ 19/432, 19/648, 1/54, 1/54, 11/648, 1/36, 11/432, 1/24, 7/144, 1/18 ]
gap> List(last,Float);
[ 0.0439815, 0.029321, 0.0185185, 0.0185185, 0.0169753, 0.0277778, 0.025463, 
  0.0416667, 0.0486111, 0.0555556 ]
gap> Sum(last2);
47/144
gap> Density(Union(cycle10));
47/432
gap> P := List(C,S->Union(Cycle(kappa,S)));;
gap> for S in P do View(S); Print("\n"); od;
1(4) U 0(12) U [ -2 ]
<union of 18 residue classes (mod 72)>
<union of 78 residue classes (mod 432)>
<union of 282 residue classes (mod 2592)>
gap> P2 := AsUnionOfFewClasses(P[2]);
[ 2(24), 3(24), 18(24), 19(24), 4(36), 28(36), 8(72), 56(72) ]
gap> Permutation(kappa,P2);
(1,5,7,2)(3,6,8,4)
gap> P3 := AsUnionOfFewClasses(P[3]);
[ 6(48), 7(48), 38(48), 39(48), 10(72), 11(72), 58(72), 59(72), 16(108), 
  88(108), 20(144), 116(144), 32(216), 176(216) ]
gap> Permutation(kappa,P3);
(1,5,9,13,6,11,2)(3,7,10,14,8,12,4)
gap> P4 := AsUnionOfFewClasses(P[4]);
[ 14(96), 15(96), 78(96), 79(96), 22(144), 23(144), 118(144), 119(144), 
  34(216), 35(216), 178(216), 179(216), 44(288), 236(288), 52(324), 268(324), 
  68(432), 356(432), 104(648), 536(648) ]
gap> Permutation(kappa,P4);
(1,5,9,15,19,10,17,6,13,2)(3,7,11,16,20,12,18,8,14,4)
gap> List(P,S->Set(List(Intersection([1..12^4],S),n->Length(Cycle(kappa,n)))));
[ [ 1 ], [ 4 ], [ 7 ], [ 10 ] ]
gap> Set(List(Intersection([1..12^4],Difference(Integers,Union(P))),
>             n->Length(Cycle(kappa,n))));
[ 13, 16, 19, 22, 25, 28, 31, 34, 37, 40 ]
]]>
</Example>

Finally we would like to factor our mapping into involutions:

<Example>
<![CDATA[
gap> elm1 := kappa;
kappa
gap> Multpk(elm1,2,1)^elm1;
8(12)
gap> Multpk(elm1,2,-1)^elm1;
4(6)
gap> Multpk(elm1,3,1)^elm1;
4(6)
gap> Multpk(elm1,3,-1)^elm1;
3(4)
gap> fact1 := RcwaMapping([[rc(4,6),rc(8,12)]]);
<rcwa mapping of Z with modulus 12>
gap> elm2 := elm1/fact1;
<rcwa mapping of Z with modulus 12>
gap> Display(elm2);

Rcwa mapping of Z with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0  1  4  5  9                       | n
   2  6 10                             | 3n + 2
   3  7 11                             | n - 1
   8                                   | (n + 1)/3

gap> Multpk(elm2,3,1)^elm2;
8(12)
gap> Multpk(elm2,3,-1)^elm2;
3(4)
gap> fact2 := RcwaMapping([[rc(3,4),rc(8,12)]]);
<rcwa mapping of Z with modulus 12>
gap> elm3 := elm2/fact2;
<rcwa mapping of Z with modulus 4>
gap> Display(elm3);

Rcwa mapping of Z with modulus 4

                n mod 4                |                 n^f
---------------------------------------+--------------------------------------
  0 1                                  | n
  2                                    | n + 1
  3                                    | n - 1

gap> fact3 := RcwaMapping([[rc(2,4),rc(3,4)]]);
<rcwa mapping of Z with modulus 4>
gap> elm4 := elm3/fact3;
IdentityMapping( Integers )
gap> kappafacts := [ RcwaMapping([[rc(2,4),rc(3,4)]]),
>                    RcwaMapping([[rc(3,4),rc(8,12)]]),
>                    RcwaMapping([[rc(4,6),rc(8,12)]]) ];
[ <rcwa mapping of Z with modulus 4>, <rcwa mapping of Z with modulus 12>,
  <rcwa mapping of Z with modulus 12> ]
gap> List(kappafacts,Order);
[ 2, 2, 2 ]
gap> kappa = Product(kappafacts);
true
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:AbelianModularGroup">
<Heading>An abelian rcwa group over a polynomial ring</Heading>

We want to have a look at a wild rcwa group over GF(4)[<M>x</M>] which
happens to be abelian (of course in general, rcwa groups also over this ring
are usually far from being abelian -- see below).
We start by defining this group:

<Example>
<![CDATA[
gap> x := Indeterminate(GF(4),1);; SetName(x,"x");
gap> R := PolynomialRing(GF(4),1);
GF(4)[x]
gap> e := One(GF(4));;
gap> p := x^2 + x + e;;    q := x^2 + e;;
gap> r := x^2 + x + Z(4);; s := x^2 + x + Z(4)^2;;
gap> cg := List( AllResidues(R,x^2), pol -> [ p, p * pol mod q, q ] );;
gap> ch := List( AllResidues(R,x^2), pol -> [ r, r * pol mod s, s ] );;
gap> g := RcwaMapping( R, q, cg );
<rcwa mapping of GF(4)[x] with modulus x^2+Z(2)^0>
gap> h := RcwaMapping( R, s, ch );
<rcwa mapping of GF(4)[x] with modulus x^2+x+Z(2^2)^2>
gap> List([g,h],Order);
[ infinity, infinity ]
gap> List([g,h],IsTame);
[ false, false ]
gap> G := Group(g,h);
<rcwa group over GF(4)[x] with 2 generators>
gap> IsAbelian(G);
true
]]>
</Example>

Now we compute the action of the group <C>G</C> on one of its orbits, and
make some statistics of the orbits of <C>G</C> containing polynomials of
degree less than&nbsp;4:

<Example>
<![CDATA[
gap> orb := Orbit(G,x^5);
[ x^5, x^5+x^4+x^2+Z(2)^0, x^5+x^3+x^2+Z(2^2)*x+Z(2)^0, x^5+x^3, 
  x^5+x^4+x^3+x^2+Z(2^2)^2*x+Z(2^2)^2, x^5+x, x^5+x^4+x^3, x^5+x^2+Z(2^2)^2*x,
  x^5+x^4+x^2+x, x^5+x^3+x^2+Z(2^2)^2*x+Z(2)^0, x^5+x^4+Z(2^2)*x+Z(2^2), 
  x^5+x^3+x, x^5+x^4+x^3+x^2+Z(2^2)*x+Z(2^2), x^5+x^4+x^3+x+Z(2)^0, 
  x^5+x^2+Z(2^2)*x, x^5+x^4+Z(2^2)^2*x+Z(2^2)^2 ]
gap> H := Action(G,orb);
Group([ (1,2,4,7,6,9,12,14)(3,5,8,11,10,13,15,16), 
  (1,3,6,10)(2,5,9,13)(4,8,12,15)(7,11,14,16) ])
gap> IsAbelian(H); # check ...
true
gap> Exponent(H);
8
gap> Collected(List(ShortOrbits(G,AllResidues(R,x^4),100),Length));
[ [ 1, 4 ], [ 2, 6 ], [ 4, 12 ], [ 8, 24 ] ]
]]>
</Example>

Changing the generators a little causes the group structure to change a lot:

<Example>
<![CDATA[
gap> cg[1][2] := cg[1][2] + (x^2 + e) * p * q;;
gap> ch[7][2] := ch[7][2] + x * r * s;;
gap> g := RcwaMapping( R, q, cg );;
gap> h := RcwaMapping( R, s, ch );;
gap> G := Group(g,h);
<rcwa group over GF(4)[x] with 2 generators>
gap> orb := Orbit(G,Zero(R));;
gap> Length(orb);
87
gap> Collected(List(orb,DegreeOfLaurentPolynomial));
[ [ 1, 2 ], [ 2, 4 ], [ 3, 16 ], [ 4, 64 ], [ infinity, 1 ] ]
gap> H := Action(G,orb);
<permutation group with 2 generators>
gap> IsNaturalAlternatingGroup(H);
true
gap> orb := Orbit(G,x^6);;
gap> Length(orb);
512
gap> H := Action(G,orb);
<permutation group with 2 generators>
gap> IsNaturalSymmetricGroup(H);
false
gap> IsNaturalAlternatingGroup(H);
false
gap> blk := Blocks(H,[1..512]);;
gap> List(blk,Length);
[ 128, 128, 128, 128 ]
gap> Action(H,blk,OnSets);
Group([ (1,2)(3,4), (1,3)(2,4) ])
]]>
</Example>

Thus the modified group has a quotient isomorphic to the alternating group
of degree&nbsp;87, and a quotient isomorphic to some wreath product or a
subgroup thereof acting transitively, but not primitively on 512 points.

</Section>

<!-- #################################################################### -->

<Section Label="sec:SubgroupOfS9">
<Heading>An rcwa representation of a small group</Heading>

We give an rcwa representation of the 3-Sylow-subgroup of the symmetric
group on 9 points. Of course this group has a very nice permutation
representation, hence for computational purposes we do not gain anything
here.

<Example>
<![CDATA[
gap> r := RcwaMapping([[1,0,1],[1,1,1],[3,-3,1],
>                      [1,0,3],[1,1,1],[3,-3,1],
>                      [1,0,1],[1,1,1],[3,-3,1]]);;
gap> s := RcwaMapping([[1,0,1],[1,1,1],[3,6,1],
>                      [1,0,3],[1,1,1],[3,6,1],
>                      [1,0,1],[1,1,1],[3,-21,1]]);;
gap> SetName(r,"r"); SetName(s,"s");
gap> Display(r);

Rcwa mapping of Z with modulus 9

                n mod 9                |                 n^r
---------------------------------------+--------------------------------------
  0 6                                  | n
  1 4 7                                | n + 1
  2 5 8                                | 3n - 3
  3                                    | n/3

gap> Display(s);

Rcwa mapping of Z with modulus 9

                n mod 9                |                 n^s
---------------------------------------+--------------------------------------
  0 6                                  | n
  1 4 7                                | n + 1
  2 5                                  | 3n + 6
  3                                    | n/3
  8                                    | 3n - 21

gap> G := Group(r,s);
<rcwa group over Z with 2 generators>
gap> H := SylowSubgroup(SymmetricGroup(9),3);
Group([ (1,2,3), (4,5,6), (7,8,9), (1,4,7)(2,5,8)(3,6,9) ])
gap> phi := InverseGeneralMapping(IsomorphismGroups(G,H));;
gap> (1,2,3)^phi;
<bijective rcwa mapping of Z with modulus 9>
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:RcwaRepresentationOfS10">
<Heading>
  An rcwa representation of the symmetric group on 10 points
</Heading>

We start by defining some bijections of infinite order and computing
commutators (the mapping&nbsp;<M>a</M> has already been discussed briefly
in the Introduction&nbsp;(<Ref Label="ch:Introduction"/>)):

<Example>
<![CDATA[
gap> a := RcwaMapping([[3,0,2],[3, 1,4],[3,0,2],[3,-1,4]]);;
gap> b := RcwaMapping([[3,0,2],[3,13,4],[3,0,2],[3,-1,4]]);;
gap> c := RcwaMapping([[3,0,2],[3, 1,4],[3,0,2],[3,11,4]]);;
gap> SetName(a,"a"); SetName(b,"b"); SetName(c,"c");
gap> List([a,b,c],Order);
[ infinity, infinity, infinity ]
gap> ab := Comm(a,b);; ac := Comm(a,c);; bc := Comm(b,c);;
gap> SetName(ab,"[a,b]"); SetName(ac,"[a,c]"); SetName(bc,"[b,c]");
gap> List([ab,ac,bc],Order);
[ 6, 6, 12 ]
]]>
</Example>

Now we would like to have a look at [<A>a</A>,<A>b</A>] ...

<Example>
<![CDATA[
gap> Display(ab);

Bijective rcwa mapping of Z with modulus 18, of order 6

               n mod 18                |               n^[a,b]
---------------------------------------+--------------------------------------
   0  2  3  8  9 11 12 17              | n
   1 10                                | 2n - 5
   4  7 13 16                          | n + 3
   5 14                                | 2n - 4
   6                                   | (n + 2)/2
  15                                   | (n - 5)/2

]]>
</Example>

... form the group generated by [<A>a</A>,<A>b</A>]
and [<A>a</A>,<A>c</A>] and compute its action on one of its orbits:

<Example>
<![CDATA[
gap> G := Group(ab,ac);
<rcwa group over Z with 2 generators>
gap> orb := Orbit(G,1);
[ -15, -12, -7, -6, -5, -4, -3, -2, -1, 1 ]
gap> H := Action(G,orb);
Group([ (2,5,8,10,7,6), (1,3,6,9,4,5) ])
gap> Size(H);
3628800
gap> Size(G); # G acts faithful on orb.
3628800
]]>
</Example>

Hence the group <A>G</A> is isomorphic to the symmetric group on 10 points
and acts faithfully on the orbit containing&nbsp;1.

We also would like to know which groups arise if we take as generators
either <A>ab</A>, <A>ac</A> or <A>bc</A> and the mapping&nbsp;<A>t</A>,
which maps each integer to its additive inverse:

<Example>
<![CDATA[
gap> t := RcwaMapping([[-1,0,1]]);
Rcwa mapping of Z: n -> -n
gap> Order(t);
2
gap> G := Group(ab,t);
<rcwa group over Z with 2 generators>
gap> Size(G);
7257600
gap> H := Image(IsomorphismPermGroup(G));;
gap> H2 := Group((1,2),(1,2,3,4,5,6,7,8,9,10),(11,12));;
gap> IsomorphismGroups(H,H2) <> fail; # H = C2 x S10
true
]]>
</Example>

Thus the group generated by <A>ab</A> and <A>t</A> is isomorphic to 
<Alt Only="LaTeX"><M>{\rm C}_2 \times {\rm S}_{10}</M></Alt>
<Alt Not="LaTeX"><M>C_2 x S_{10}</M></Alt>.
The next group is an extension of a perfect group of order&nbsp;960:

<Example>
<![CDATA[
gap> G := Group(ac,t);;
gap> Size(G);
3840
gap> H := Image(IsomorphismPermGroup(G));;
gap> P := DerivedSubgroup(H);
Group([ (2,15,3,5,16)(4,6,18,7,17)(9,19,10,12,20)(11,13,22,14,21), 
  (2,3,5,7,16)(4,15,6,18,17)(9,10,12,14,20)(11,19,13,22,21) ])
gap> Size(P);
960
gap> IsPerfect(P);
true
gap> PerfectGroup(PerfectIdentification(P));
A5 2^4'
]]>
</Example>

The last group is infinite:

<Example>
<![CDATA[
gap> G := Group(bc,t);;
gap> Size(G);
infinity
gap> Order(bc*t);
infinity
gap> Modulus(G);
18
gap> ResidueClassUnionViewingFormat("short");
gap> RespectedClassPartition(G);
[ 0(18), 1(18), 2(18), 4(18), 5(18), 7(18), 8(18), 9(18), 10(18), 11(18), 
  13(18), 14(18), 16(18), 17(18), 3(36), 6(36), 12(36), 15(36), 21(36), 
  24(36), 30(36), 33(36) ]
gap> D := DerivedSubgroup(ActionOnClassPartition(G));;
gap> DegreeAction(D);
20
gap> IsPerfect(D);
true
gap> Size(D);
928972800
gap> RankOfKernelOfActionOnClassPartition(G);
9
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:LocalExample">
<Heading>Some examples over (semi)localizations of the integers</Heading>

We start with something one can observe when trying to <Q>transfer</Q> an
rcwa mapping from the ring of integers to one of its localizations (we take
the mapping <C>a</C> from the last example):

<Example>
<![CDATA[
gap> a2 := RcwaMapping(Z_pi(2),ShallowCopy(Coefficients(a)));
<rcwa mapping of Z_( 2 ) with modulus 4>
gap> IsSurjective(a2); # As expected
true
gap> IsInjective(a2); # Why not??
false
gap> 0^a2;
0
gap> (1/3)^a2; # That's the reason!
0
]]>
</Example>

The above can also be explained easily by pointing out that the modulus
of the inverse of <C>a</C> is 3, and that 3 is a unit of
<M>\mathbb{Z}_{(2)}</M>.
Moving to <M>\mathbb{Z}_{(2,3)}</M> solves this problem:

<Example>
<![CDATA[
gap> a23 := RcwaMapping(Z_pi([2,3]),ShallowCopy(Coefficients(a)));
<rcwa mapping of Z_( 2, 3 ) with modulus 4>
gap> IsBijective(a23);
true
]]>
</Example>

We get additional finite cycles, e.g.:

<Example>
<![CDATA[
gap> List(ShortOrbits(Group(a23),[0..50]/5,50),orb->Cycle(a23,orb[1]));
[ [ 0 ], [ 1/5, 2/5, 3/5 ], 
  [ 4/5, 6/5, 9/5, 8/5, 12/5, 18/5, 27/5, 19/5, 13/5, 11/5, 7/5 ], [ 1 ], 
  [ 2, 3 ], [ 14/5, 21/5, 17/5 ], 
  [ 16/5, 24/5, 36/5, 54/5, 81/5, 62/5, 93/5, 71/5, 52/5, 78/5, 117/5, 89/5, 
      68/5, 102/5, 153/5, 116/5, 174/5, 261/5, 197/5, 149/5, 113/5, 86/5, 
      129/5, 98/5, 147/5, 109/5, 83/5, 61/5, 47/5, 34/5, 51/5, 37/5, 29/5, 
      23/5 ], [ 4, 6, 9, 7, 5 ] ]
gap> List(last,Length);
[ 1, 3, 11, 1, 2, 3, 34, 5 ]
gap> List(ShortOrbits(Group(a23),[0..50]/7,50),orb->Cycle(a23,orb[1]));
[ [ 0 ], [ -1/7, 1/7 ], [ 2/7, 3/7, 4/7, 6/7, 9/7, 5/7 ], [ 1 ], [ 2, 3 ], 
  [ 4, 6, 9, 7, 5 ] ]
gap> List(last,Length);
[ 1, 2, 6, 1, 2, 5 ]
gap> List(ShortOrbits(Group(a23),[0..50]/11,50),orb->Cycle(a23,orb[1]));
[ [ 0 ], [ -5/11, -1/11, 2/11, 3/11, 5/11, 1/11, -2/11, -3/11 ], 
  [ 4/11, 6/11, 9/11 ], [ 1 ], 
  [ 16/11, 24/11, 36/11, 54/11, 81/11, 58/11, 87/11, 68/11, 102/11, 153/11, 
      112/11, 168/11, 252/11, 378/11, 567/11, 428/11, 642/11, 963/11, 725/11, 
      541/11, 403/11, 305/11, 226/11, 339/11, 257/11, 190/11, 285/11, 211/11, 
      161/11, 118/11, 177/11, 130/11, 195/11, 149/11, 109/11, 79/11, 62/11, 
      93/11, 67/11, 53/11, 37/11, 25/11 ], [ 2, 3 ], [ 4, 6, 9, 7, 5 ] ]
gap> List(last,Length);
[ 1, 8, 3, 1, 42, 2, 5 ]
]]>
</Example>

But the group structure remains invariant under the <Q>transfer</Q> of
a group with prime set <M>\{2,3\}</M> from <M>\Z</M> to <M>\Z_{(2,3)}</M>:

<Example>
<![CDATA[
gap> b23 := RcwaMapping(Z_pi([2,3]),ShallowCopy(Coefficients(b)));;
gap> c23 := RcwaMapping(Z_pi([2,3]),ShallowCopy(Coefficients(c)));;
gap> ab23 := Comm(a23,b23);
<rcwa mapping of Z_( 2, 3 ) with modulus 18>
gap> ac23 := Comm(a23,c23);
<rcwa mapping of Z_( 2, 3 ) with modulus 18>
gap> G := Group(ab23,ac23);
<rcwa group over Z_( 2, 3 ) with 2 generators>
gap> S := Intersection(Enumerator(Rationals){[1..200]},Z_pi([2,3]));
[ -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -12/5, -11/5, -2, -9/5, -12/7, 
  -8/5, -11/7, -10/7, -7/5, -9/7, -6/5, -8/7, -12/11, -1, -10/11, -6/7, 
  -9/11, -4/5, -8/11, -5/7, -7/11, -3/5, -4/7, -6/11, -5/11, -3/7, -2/5, 
  -4/11, -2/7, -3/11, -1/5, -2/11, -1/7, -1/11, 0, 1/13, 1/11, 1/7, 2/13, 
  2/11, 1/5, 3/13, 3/11, 2/7, 4/13, 4/11, 5/13, 2/5, 3/7, 5/11, 6/13, 7/13, 
  6/11, 4/7, 3/5, 8/13, 7/11, 9/13, 5/7, 8/11, 10/13, 4/5, 9/11, 11/13, 6/7, 
  10/11, 12/13, 1, 12/11, 8/7, 13/11, 6/5, 9/7, 7/5, 10/7, 11/7, 8/5, 12/7, 
  9/5, 2, 11/5, 12/5, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ]
gap> orbs := ShortOrbits(G,S,50);;
gap> List(orbs,Length);
[ 10, 10, 1, 10, 1, 10, 10, 10, 10, 10, 1, 10, 10, 10, 1, 10, 10, 10, 10, 10, 
  10, 10, 10, 10, 10, 10, 10, 10, 1, 10, 10, 10, 10, 10, 10, 10, 10, 10, 1, 
  10, 1, 10, 10, 10, 1, 1, 10, 1, 10 ]
gap> ForAll(orbs,orb->IsNaturalSymmetricGroup(Action(G,orb)));
true
]]>
</Example>

<Q>Transferring</Q> a non-invertible rcwa mapping from the ring of integers
to some of its (semi)localizations can also turn it into an invertible one:

<Example>
<![CDATA[
gap> v := RcwaMapping([[6,0,1],[1,-7,2],[6,0,1],[1,-1,1],
>                      [6,0,1],[1, 1,2],[6,0,1],[1,-1,1]]);;
gap> SetName(v,"v");
gap> Display(v);

Rcwa mapping of Z with modulus 8

                n mod 8                |                 n^v
---------------------------------------+--------------------------------------
  0 2 4 6                              | 6n
  1                                    | (n - 7)/2
  3 7                                  | n - 1
  5                                    | (n + 1)/2

gap> IsInjective(v);
true
gap> IsSurjective(v);
false
gap> Image(v);
1(2) U 2(4) U 0(12)
gap> Difference(Integers,last);
4(12) U 8(12)
gap> v2 := RcwaMapping(Z_pi(2),ShallowCopy(Coefficients(v)));
<rcwa mapping of Z_( 2 ) with modulus 8>
gap> IsBijective(v2);
true
gap> Display(v2^-1);

Bijective rcwa mapping of Z_( 2 ) with modulus 4

                n mod 4                |                 n^f
---------------------------------------+--------------------------------------
  0                                    | 1/3 n / 2
  1                                    | 2 n + 7
  2                                    | n + 1
  3                                    | 2 n - 1

gap> S := ResidueClass(Z_pi(2),2,0);; l := [S];;
gap> for i in [1..10] do Add(l,l[Length(l)]^v2); od;
gap> l; # Visibly v2 is wild ...
[ 0(2), 0(4), 0(8), 0(16), 0(32), 0(64), 0(128), 0(256), 0(512), 0(1024), 
  0(2048) ]
gap> w2 := RcwaMapping(Z_pi(2),[[1,0,2],[2,-1,1],[1,1,1],[2,-1,1]]);;
gap> v2w2 := Comm(v2,w2);; SetName(v2w2,"[v2,w2]"); v2w2^-1;;
gap> Display(v2w2);

Bijective rcwa mapping of Z_( 2 ) with modulus 8

                n mod 8                |              n^[v2,w2]
---------------------------------------+--------------------------------------
  0 3 4 7                              | n
  1                                    | n + 4
  2 6                                  | 3 n
  5                                    | n - 4

]]>
</Example>

  Again, viewed as an rcwa mapping of the integers the commutator given at
  the end of our example would not be surjective.

</Section>

<!-- #################################################################### -->

<Section Label="sec:Twisting257CyclesToModulus32">
<Heading>
  Twisting 257-cycles into an rcwa mapping with modulus 32
</Heading>

We define an rcwa mapping <A>x</A> of order&nbsp;257 with modulus&nbsp;32
(the easiest way to construct such a mapping is to prescribe the
graph and then to assign suitable affine mappings to its vertices).

<Example>
<![CDATA[
gap> x := RcwaMapping([[ 16,  2,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1,  0, 16], [ 16, 18,  1],
>                      [  1,-14,  1], [ 16, 18,  1],
>                      [  1,-14,  1], [ 16, 18,  1],
>                      [  1,-14,  1], [ 16, 18,  1],
>                      [  1,-14,  1], [ 16, 18,  1],
>                      [  1,-14,  1], [ 16, 18,  1],
>                      [  1,-14,  1], [ 16, 18,  1],
>                      [  1,-14,  1], [  1,-31,  1]]);;
gap> SetName(x,"x");
gap> Display(x);

Rcwa mapping of Z with modulus 32

               n mod 32                |                 n^x
---------------------------------------+--------------------------------------
   0                                   | 16n + 2
   1  3  5  7  9 11 13 15 17 19 21 23  | 
  25 27 29                             | 16n + 18
   2  4  6  8 10 12 14                 | n + 16
  16                                   | n/16
  18 20 22 24 26 28 30                 | n - 14
  31                                   | n - 31

gap> Order(x);
257
gap> List([-20..20],n->n^x);
[ -4, -286, -2, -254, -1, -222, -28, -190, -26, -158, -24, -126, -22, -94, 
  -20, -62, -18, -30, -16, -32, 2, 34, 18, 66, 20, 98, 22, 130, 24, 162, 26, 
  194, 28, 226, 30, 258, 1, 290, 4, 322, 6 ]
]]>
</Example>

Of course we would like to know how a cycle of this permutation looks
like:

<Example>
<![CDATA[
gap> Cycle(x,[1],0);
[ 0, 2, 18, 4, 20, 6, 22, 8, 24, 10, 26, 12, 28, 14, 30, 16, 1, 34, 50, 36, 
  52, 38, 54, 40, 56, 42, 58, 44, 60, 46, 62, 48, 3, 66, 82, 68, 84, 70, 86, 
  72, 88, 74, 90, 76, 92, 78, 94, 80, 5, 98, 114, 100, 116, 102, 118, 104, 
  120, 106, 122, 108, 124, 110, 126, 112, 7, 130, 146, 132, 148, 134, 150, 
  136, 152, 138, 154, 140, 156, 142, 158, 144, 9, 162, 178, 164, 180, 166, 
  182, 168, 184, 170, 186, 172, 188, 174, 190, 176, 11, 194, 210, 196, 212, 
  198, 214, 200, 216, 202, 218, 204, 220, 206, 222, 208, 13, 226, 242, 228, 
  244, 230, 246, 232, 248, 234, 250, 236, 252, 238, 254, 240, 15, 258, 274, 
  260, 276, 262, 278, 264, 280, 266, 282, 268, 284, 270, 286, 272, 17, 290, 
  306, 292, 308, 294, 310, 296, 312, 298, 314, 300, 316, 302, 318, 304, 19, 
  322, 338, 324, 340, 326, 342, 328, 344, 330, 346, 332, 348, 334, 350, 336, 
  21, 354, 370, 356, 372, 358, 374, 360, 376, 362, 378, 364, 380, 366, 382, 
  368, 23, 386, 402, 388, 404, 390, 406, 392, 408, 394, 410, 396, 412, 398, 
  414, 400, 25, 418, 434, 420, 436, 422, 438, 424, 440, 426, 442, 428, 444, 
  430, 446, 432, 27, 450, 466, 452, 468, 454, 470, 456, 472, 458, 474, 460, 
  476, 462, 478, 464, 29, 482, 498, 484, 500, 486, 502, 488, 504, 490, 506, 
  492, 508, 494, 510, 496, 31 ]
gap> Length(last);
257
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ModuliOfPowers">
<Heading> The behaviour of the moduli of powers </Heading>

In this section we give some examples illustrating how different the
series of the moduli of powers of a given rcwa mapping of the integers
can look like.

<Example>
<![CDATA[
gap> List([0..4],i->Modulus(a^i));
[ 1, 4, 16, 64, 256 ]
gap> List([0..6],i->Modulus(ab^i));
[ 1, 18, 18, 18, 18, 18, 1 ]
gap> List([0..3],i->Modulus(r^i));
[ 1, 9, 9, 1 ]
gap> List([0..9],i->Modulus(s^i));
[ 1, 9, 9, 27, 27, 27, 27, 27, 27, 1 ]
gap> g := RcwaMapping([[2,2,1],[1,4,1],[1,0,2],[2,2,1],[1,-4,1],[1,-2,1]]);;
gap> List([0..7],i->Modulus(g^i));
[ 1, 6, 12, 12, 12, 12, 6, 1 ]
gap> u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;
gap> List([0..3],i->Modulus(u^i));
[ 1, 5, 25, 125 ]
gap> v6 := RcwaMapping([[-1,2,1],[1,-1,1],[1,-1,1]]);;
gap> List([0..6],i->Modulus(v6^i));
[ 1, 3, 3, 3, 3, 3, 1 ]
gap> w8 := RcwaMapping([[-1,3,1],[1,-1,1],[1,-1,1],[1,-1,1]]);;
gap> List([0..8],i->Modulus(w8^i));
[ 1, 4, 4, 4, 4, 4, 4, 4, 1 ]
gap> z := RcwaMapping([[2,  1, 1],[1,  1,1],[2, -1,1],[2, -2,1],
>                      [1,  6, 2],[1,  1,1],[1, -6,2],[2,  5,1],
>                      [1,  6, 2],[1,  1,1],[1,  1,1],[2, -5,1],
>                      [1,  0, 1],[1, -4,1],[1,  0,1],[2,-10,1]]);;
gap> SetName(z,"z");
gap> Order(z);
infinity
gap> Display(z);

Bijective rcwa mapping of Z with modulus 16, of order infinity

               n mod 16                |                 n^z
---------------------------------------+--------------------------------------
   0                                   | 2n + 1
   1  5  9 10                          | n + 1
   2                                   | 2n - 1
   3                                   | 2n - 2
   4  8                                | (n + 6)/2
   6                                   | (n - 6)/2
   7                                   | 2n + 5
  11                                   | 2n - 5
  12 14                                | n
  13                                   | n - 4
  15                                   | 2n - 10

gap> List([0..25],i->Modulus(z^i));
[ 1, 16, 32, 64, 64, 128, 128, 128, 128, 128, 128, 256, 256, 256, 256, 256, 
  256, 512, 512, 512, 512, 512, 512, 1024, 1024, 1024 ]
gap> e1 := RcwaMapping([[1,4,1],[2,0,1],[1,0,2],[2,0,1]]);;
gap> e2 := RcwaMapping([[1,4,1],[2,0,1],[1,0,2],[1,0,1],
>                       [1,4,1],[2,0,1],[1,0,1],[1,0,1]]);;
gap> List([e1,e2],Order);
[ infinity, infinity ]
gap> List([1..20],i->Modulus(e1^i));
[ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 ]
gap> List([1..20],i->Modulus(e2^i));
[ 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4 ]
gap> SetName(e1,"e1"); SetName(e2,"e2");
gap> Display(e2);

Bijective rcwa mapping of Z with modulus 8, of order infinity

                n mod 8                |                 n^e2
---------------------------------------+--------------------------------------
  0 4                                  | n + 4
  1 5                                  | 2n
  2                                    | n/2
  3 6 7                                | n

gap> e2^2 = Restriction(RcwaMapping([[1,2,1]]),RcwaMapping([[4,0,1]]));
true
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:CollatzImagesAndPreImages">
<Heading> Images and preimages under the Collatz mapping </Heading>

We would like to have a look at the images of the residue class 1(2)
under powers of the Collatz mapping.

<Example>
<![CDATA[
gap> T := RcwaMapping([[1,0,2],[3,1,2]]);;
gap> S0 := ResidueClass(Integers,2,1);
1(2)
gap> S1 := S0^T;
2(3)
gap> S2 := S1^T;
1(3) U 8(9)
gap> S3 := S2^T;
2(3) U 4(9)
gap> S4 := S3^T;
1(3) U 2(9) U 8(9)
gap> S5 := S4^T;
2(3) U 1(9) U 4(9)
gap> S6 := S5^T;
1(3) U 2(3)
gap> S7 := S6^T;
1(3) U 2(3)
]]>
</Example>

We see that the image gets stable after applying the mapping <M>T</M> for
the 6th time, hence that <M>T^6</M> maps the residue class 1(2)
surjectively onto the union of the residue classes 1(3) and 2(3), which is
setwisely stabilized by <M>T</M>.
Now we would like to determine the preimages of 1(3) resp. 2(3) in 1(2)
under <M>T^6</M>. The residue class 1(2) has to be the disjoint union of
these sets.

<Example>
<![CDATA[
gap> U := ResidueClass(Integers,3,1);;
gap> for i in [1..6] do U := PreImage(T,U); od;
gap> U := Intersection(U,S0);
<union of 11 residue classes (mod 64)>
gap> V := ResidueClass(Integers,3,2);;
gap> for i in [1..6] do V := PreImage(T,V); od;
gap> V := Intersection(V,S0);
<union of 21 residue classes (mod 64)>
gap> Display(U);

The union of the residue classes r ( mod 64 ) of Z for r =

  1  5  7  9 21 23 29 31 49 51 59

gap> Display(V);

The union of the residue classes r ( mod 64 ) of Z for r =

  3 11 13 15 17 19 25 27 33 35 37 39 41 43 45 47 53 55 57 61 63

gap> Union(U,V) = S0 and Intersection(U,V) = [];  # consistency check
true
]]>
</Example>

Now we want to determine the images of the residue class 0(3) under
powers of&nbsp;<M>T</M>:

<Example>
<![CDATA[
gap> S0 := ResidueClass(Integers,3,0);
0(3)
gap> S1 := S0^T;
0(3) U 5(9)
gap> S2 := S1^T;
0(3) U 5(9) U 7(9) U 8(27)
gap> S3 := S2^T;
<union of 20 residue classes (mod 27)>
gap> S4 := S3^T;
<union of 73 residue classes (mod 81)>
gap> S5 := S4^T;
<union of 79 residue classes (mod 81)>
gap> S6 := S5^T;
Integers
gap> S7 := S6^T;
Integers
]]>
</Example>

Thus, every integer is the image of a multiple of&nbsp;3
under&nbsp;<M>T^6</M>. This means that it would be sufficient to prove the
Collatz conjecture for multiples of&nbsp;3.
We can obtain the corresponding result for multiples of&nbsp;5 as follows:

<Example>
<![CDATA[
gap> S := [ResidueClass(Integers,5,0)];
[ 0(5) ]
gap> for i in [1..12] do Add(S,S[i]^T); od;
gap> for s in S do View(s); Print("\n"); od;
0(5)
0(5) U 8(15)
0(5) U 4(15) U 8(15)
0(5) U 2(15) U 4(15) U 8(15) U 29(45)
<union of 73 residue classes (mod 135)>
<union of 244 residue classes (mod 405)>
<union of 784 residue classes (mod 1215)>
<union of 824 residue classes (mod 1215)>
<union of 2593 residue classes (mod 3645)>
<union of 2647 residue classes (mod 3645)>
<union of 2665 residue classes (mod 3645)>
<union of 2671 residue classes (mod 3645)>
1(3) U 2(3) U 0(15)
gap> Union(S[13],ResidueClass(Integers,3,0));
Integers
gap> List(S,Si->Float(Density(Si)));
[ 0.2, 0.266667, 0.333333, 0.422222, 0.540741, 0.602469, 0.645267, 0.678189, 
  0.711385, 0.7262, 0.731139, 0.732785, 0.733333 ]
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:CollatzMapping">
<Heading>Replacing the Collatz mapping by conjugates</Heading>

We can turn the Collatz problem into an equivalent question by
replacing the Collatz mapping&nbsp;<A>T</A> by one of its conjugates under
an element of the pointwise stabilizer of&nbsp;1 in the setwise stabilizer
of the positive integers of RCWA(<M>\Z</M>). Define the Collatz mapping:

<Example>
<![CDATA[
gap> T := RcwaMapping([[1,0,2],[3,1,2]]);
<rcwa mapping of Z with modulus 2>
]]>
</Example>

A suitable bijection:

<Example>
<![CDATA[
gap> a := RcwaMapping([[3,0,2],[3,1,4],[3,0,2],[3,-1,4]]);
<rcwa mapping of Z with modulus 4>
gap> IsBijective(a);
true
gap> 1^a; # The mapping a stabilizes 1
1
]]>
</Example>

Some evidence that <A>a</A> stabilizes the set of positive integers
(of course this can be proved easily ...):

<Example>
<![CDATA[
gap> List([1..50],n->n^a);
[ 1, 3, 2, 6, 4, 9, 5, 12, 7, 15, 8, 18, 10, 21, 11, 24, 13, 27, 14, 30, 16, 
  33, 17, 36, 19, 39, 20, 42, 22, 45, 23, 48, 25, 51, 26, 54, 28, 57, 29, 60, 
  31, 63, 32, 66, 34, 69, 35, 72, 37, 75 ]
]]>
</Example>

Compute <M>T^a</M>:

<Example>
<![CDATA[
gap> f := T^a;;
gap> Display(f);

Rcwa mapping of Z with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0  6                                | n/2
   1  4  7 10                          | 3n
   2  8                                | (3n + 2)/2
   3                                   | (n + 1)/4
   5 11                                | (3n + 1)/2
   9                                   | (n - 1)/4

]]>
</Example>

Have a look at resulting integer sequences:

<Example>
<![CDATA[
gap> seq := function(n)
>             repeat Print(n,","); n := n^f; until n = 1; Print("1.\n");
>           end;
function( n ) ... end
gap> seq(7);
7,21,5,8,13,39,10,30,15,4,12,6,3,1.
gap> seq(10);
10,30,15,4,12,6,3,1.
gap> seq(20);
20,31,93,23,35,53,80,121,363,91,273,68,103,309,77,116,175,525,131,197,296,445,
1335,334,1002,501,125,188,283,849,212,319,957,239,359,539,809,1214,1822,5466,
2733,683,1025,1538,2308,6924,3462,1731,433,1299,325,975,244,732,366,183,46,
138,69,17,26,40,120,60,30,15,4,12,6,3,1.
]]>
</Example>

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->
<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  examples.xml         RCWA documentation          Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$     ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:Examples"><Heading>Examples</Heading>

In this chapter we would like to give some <Q>nice</Q> examples of
rcwa mappings and groups generated by them.
The rcwa mappings used in this chapter can be found in the file
<F>rcwa/examples/examples.g</F>, so there is no need to extract them
from the manual files.
There is an auxiliary function for reading this file without having to
type in the whole path name - see <Ref Func="RCWAReadExamples"/>.

<!-- #################################################################### -->

<Section Label="sec:WildButFiniteCycles">
<Heading>A wild rcwa mapping all of those cycles seem to be finite</Heading>

  In the Introduction (<Ref Label="ch:Introduction"/>) we have seen an
  example of a wild element of RCWA(GF(2)[<M>x</M>]) having only finite
  cycles. It was easy to explain this <Q>phenomenon</Q> by pointing out that
  the degree function gives rise to a partition of GF(2)[<M>x</M>] into
  finite sets which is left invariant by the given permutation.
  Regarding <M>\mathbb{Z}</M> however the situation looks completely
  different -- we do not have a <Q>natural</Q> partition into finite sets
  which might be fixed by a wild rcwa mapping.
  We ask whether in RCWA(<M>\mathbb{Z}</M>) there is a wild mapping having
  only finite cycles, anyway. Trying to answer this question we look at the
  following example (don't ask me how to get the idea to look at these
  particular mappings ...):

<Example>
<![CDATA[
gap> sigma1 := RcwaMapping([[1,0,1],[1,1,1],[1,1,1],[1,-2,1]]);;
gap> sigma2 := RcwaMapping([[1, 0,1],[3,3,2],[1,0,1],[2,0,1],[1,0,1],[1,0,1],
>                           [1,-3,3],[3,3,2],[1,0,1],[1,0,1],[1,0,1],[1,0,1],
>                           [2, 0,1],[3,3,2],[1,0,1],[1,0,1],[1,0,1],[1,0,1]]);;
gap> SetName(sigma1,"sigma1"); SetName(sigma2,"sigma2");
gap> List([sigma1,sigma2],Order);
[ 3, 3 ]
gap> Display(sigma1);

Bijective rcwa mapping of Z with modulus 4, of order 3

                n mod 4                |               n^sigma1
---------------------------------------+--------------------------------------
  0                                    | n
  1 2                                  | n + 1
  3                                    | n - 2

gap> Display(sigma2);

Bijective rcwa mapping of Z with modulus 18, of order 3

               n mod 18                |               n^sigma2
---------------------------------------+--------------------------------------
   0  2  4  5  8  9 10 11 14 15 16 17  | n
   1  7 13                             | (3n + 3)/2
   3 12                                | 2n
   6                                   | (n - 3)/3

gap> IsConjugate(RCWA(Integers),sigma1,sigma2);
true
]]>
</Example>

  Thus we start with two conjugate mappings of order 3.
  Now we form their product:

<Example>
<![CDATA[
gap> sigma := sigma1*sigma2;
<bijective rcwa mapping of Z with modulus 36>
gap> SetName(sigma,"sigma");
gap> Display(sigma);

Bijective rcwa mapping of Z with modulus 36

               n mod 36                |               n^sigma
---------------------------------------+--------------------------------------
   0  4  8 16 20 28 32                 | n
   1  9 10 13 14 17 21 22 25 26 33 34  | n + 1
   2 29                                | 2n + 2
   3 15 27                             | (3n - 3)/2
   5                                   | (n - 2)/3
   6 18 30                             | (3n + 6)/2
   7 11 19 31 35                       | n - 2
  12                                   | 2n
  23                                   | 2n - 4
  24                                   | (n - 3)/3

]]>
</Example>

  By an easy hand calculation we see that for any positive integer <M>k</M>
  the residue class <M>3(4 \cdot 3^{k+1})</M> is a subset of the intersection
  of the image of 3(12) under the <M>k</M>th power of <C>sigma</C> and 3(12)
  itself, thus that <C>sigma</C> is wild. In spite of this, however,
  all cycles of <C>sigma</C> seem to be finite:

<Example>
<![CDATA[
gap> MovedPoints(sigma);
<union of 29 residue classes (mod 36), +0/-2 elements>
gap> Intersection(last,[-20..20]);
[ -19, -18, -17, -15, -14, -13, -12, -11, -10, -9, -7, -5, -3, -2, -1, 1, 2, 
  5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19 ]
gap> Cycle(sigma,1);
[ 1, 2, 6, 12, 24, 7, 5 ]
gap> Cycle(sigma,-1);
[ -1, -3, -2 ]
gap> Cycle(sigma,-5);
[ -5, -7, -12 ]
gap> Cycle(sigma,9);
[ 9, 10, 11 ]
gap> Cycle(sigma,-9);
[ -9, -15, -14, -13, -30, -42, -60, -120, -41, -43, -84, -29, -31, -11, -10 ]
gap> Cycle(sigma,13);
[ 13, 14, 15, 21, 22, 23, 42, 66, 102, 156, 312, 103, 101, 204, 67, 65, 132, 
  43, 41 ]
gap> List([-50..50],n->Length(Cycle(sigma,n)));
[ 31, 31, 5, 31, 31, 31, 1, 15, 15, 15, 1, 3, 3, 3, 1, 31, 31, 31, 1, 15, 15, 
  15, 1, 3, 3, 3, 5, 31, 31, 31, 1, 5, 5, 5, 1, 15, 15, 15, 3, 15, 15, 15, 1, 
  3, 1, 3, 1, 3, 3, 3, 1, 7, 7, 1, 1, 7, 7, 7, 1, 3, 3, 3, 7, 19, 19, 19, 1, 
  9, 9, 9, 1, 19, 19, 19, 7, 23, 23, 23, 1, 9, 9, 9, 1, 3, 3, 3, 1, 23, 23, 
  23, 1, 19, 19, 19, 1, 3, 3, 3, 9, 35, 35 ]
gap> List(ShortOrbits(Group(sigma),[-100..100],1000),Length);
[ 1, 3, 31, 51, 1, 5, 1, 15, 15, 19, 1, 13, 1, 3, 1, 31, 1, 1, 3, 1, 1, 5, 1, 
  1, 3, 1, 1, 1, 3, 1, 1, 3, 1, 1, 1, 3, 1, 7, 1, 1, 1, 3, 19, 1, 9, 1, 23, 
  1, 1, 3, 1, 1, 1, 3, 35, 1, 5, 1, 27, 1, 1, 3, 1, 1, 1, 3, 15, 1, 17, 1, 
  39, 1 ]
gap> Collected(List(ShortOrbits(Group(sigma),[-1000..1000],1000),Length));
[ [ 1, 391 ], [ 3, 112 ], [ 5, 28 ], [ 7, 1 ], [ 9, 14 ], [ 13, 7 ], 
  [ 15, 28 ], [ 17, 3 ], [ 19, 14 ], [ 21, 2 ], [ 23, 22 ], [ 25, 1 ], 
  [ 27, 10 ], [ 29, 1 ], [ 31, 12 ], [ 35, 5 ], [ 39, 7 ], [ 43, 2 ], 
  [ 47, 4 ], [ 51, 2 ], [ 55, 1 ], [ 63, 3 ], [ 67, 2 ] ]
]]>
</Example>

  Remark: We use <C>ShortOrbits</C> for the cyclic group generated by
  <C>sigma</C> in order to count each cycle only once.

  It remains to be said that I neither have a good explanation for this
  nor know a proof that indeed all cycles of <C>sigma</C> are finite --
  maybe there is an easy way to see this, but it may also be that this is
  a hard problem like proving the Collatz conjecture. Looking at its
  transition graph for modulus 36, it is possible to simplify the mapping
  <C>sigma</C> a bit by hand, but this does not seem to make treating this
  problem easier.

</Section>

<!-- #################################################################### -->

<Section Label="sec:SlowlyContractingMapping">
<Heading>
  An rcwa mapping which seems to be contracting, but very slow
</Heading>

  The iterates of an integer under the Collatz mapping <M>T</M> seem to
  approach its contraction centre rather quickly and do not get very large
  before doing so (of course this is a purely heuristic statement as the
  Collatz conjecture has not been proved so far!):

<Example>
<![CDATA[
gap> T := RcwaMapping([[1,0,2],[3,1,2]]);;
gap> S0 := ContractionCentre(T,100,1000);
[ -136, -91, -82, -68, -61, -55, -41, -37, -34, -25, -17, -10, -7, -5, -1, 0, 
  1, 2 ]
gap> S0^T = S0; # This holds by definition of the contraction centre.
true
gap> Trajectory(T,15,S0,"stop");
[ 15, 23, 35, 53, 80, 40, 20, 10, 5, 8, 4, 2 ]
gap> Trajectory(T,27,S0,"stop");
[ 27, 41, 62, 31, 47, 71, 107, 161, 242, 121, 182, 91, 137, 206, 103, 155, 
  233, 350, 175, 263, 395, 593, 890, 445, 668, 334, 167, 251, 377, 566, 283, 
  425, 638, 319, 479, 719, 1079, 1619, 2429, 3644, 1822, 911, 1367, 2051, 
  3077, 4616, 2308, 1154, 577, 866, 433, 650, 325, 488, 244, 122, 61, 92, 46, 
  23, 35, 53, 80, 40, 20, 10, 5, 8, 4, 2 ]
gap> List([1..100],n->Length(Trajectory(T,n,S0,"stop")));
[ 2, 2, 5, 2, 4, 6, 11, 3, 13, 5, 10, 7, 7, 12, 12, 4, 9, 14, 14, 6, 6, 11, 
  11, 8, 16, 8, 70, 13, 13, 13, 67, 5, 18, 10, 10, 15, 15, 15, 23, 7, 69, 7, 
  20, 12, 12, 12, 66, 9, 17, 17, 17, 9, 9, 71, 71, 14, 22, 14, 22, 14, 14, 
  68, 68, 6, 19, 19, 19, 11, 11, 11, 65, 16, 73, 16, 11, 16, 16, 24, 24, 8, 
  16, 70, 70, 8, 8, 21, 21, 13, 21, 13, 59, 13, 13, 67, 67, 10, 75, 18, 18, 
  18 ]
gap> Maximum(List([1..1000],n->Length(Trajectory(T,n,S0,"stop"))));
113
gap> Maximum(List([1..1000],n->Maximum(Trajectory(T,n,S0,"stop"))));
125252
]]>
</Example>

  We can give an example of another mapping which is probably also
  contracting, but yields much longer trajectories:

<Log>
<![CDATA[
gap> f6 := RcwaMapping([[ 1,0,6],[ 5, 1,6],[ 7,-2,6],
>                       [11,3,6],[11,-2,6],[11,-1,6]]);;
gap> SetName(f6,"f6");
gap> Display(f6);

Integral rcwa mapping with modulus 6

                n mod 6                |                 n^f6
---------------------------------------+--------------------------------------
  0                                    | n/6
  1                                    | (5n + 1)/6
  2                                    | (7n - 2)/6
  3                                    | (11n + 3)/6
  4                                    | (11n - 2)/6
  5                                    | (11n - 1)/6

gap> S0 := ContractionCentre(f6,1000,100000);;
gap> Trajectory(f6,25,S0,"stop");
[ 25, 21, 39, 72, 12, 2 ]
gap> List([1..100],n->Length(Trajectory(f6,n,S0,"stop")));
[ 2, 2, 3, 4, 2, 2, 3, 2, 2, 5, 7, 2, 8, 17, 3, 16, 2, 4, 17, 6, 5, 2, 5, 5, 
  6, 2, 4, 2, 15, 2, 2, 3, 2, 5, 13, 3, 2, 3, 4, 2, 8, 4, 4, 2, 7, 19, 23517, 
  3, 9, 3, 2, 18, 14, 2, 20, 23512, 14, 2, 6, 6, 2, 4, 19, 12, 23511, 8, 
  23513, 10, 2, 13, 13, 3, 2, 23517, 7, 20, 7, 9, 9, 6, 12, 8, 6, 18, 14, 
  23516, 31, 12, 23545, 4, 21, 19, 5, 2, 17, 17, 13, 19, 6, 23515 ]
gap> Maximum(Trajectory(f6,47,S0,"stop"));;
736339177776247330443187705477107581873369010805146980871580925673774229545698\
886054
gap> l := Trajectory(f6,3224,S0,"stop");;
gap> Length(l);
19949563
gap> LogInt(Maximum(l),10);
2197
gap> Int(Maximum(l)/10^2197);
3
gap> l[19949563]; # The sequence ends at the fixed point 2.
2
gap> 2^f6;
2
]]>
</Log>

  The computation of the trajectory starting at 3224 is a test whether your
  computer is well-equipped with main memory -- as the trajectory ascends to
  about <M>3 \cdot 10^{2197}</M> before descending again this might require
  roughly 10GB (of course when I computed this sequence I did not store all
  the iterates ...).

  An heuristic <Q>explanation</Q> of this behaviour is that the divergence
  of <C>f6</C> is much closer to 1 than the one of the Collatz mapping
  <M>T</M> is:

<Log>
<![CDATA[
gap> Divergence(T);
0.866025
gap> Divergence(f6);
0.999746
]]>
</Log>

  In order to construct the mapping <C>f6</C> we have chosen the denominators
  of the partial mappings to be equal and the numerators to be numbers
  coprime to the common denominator whose product is just a little bit
  smaller than the <C>Modulus(f6)</C>th power of the denominator -- in our
  example we have <M>5 \cdot 7 \cdot 11^3 = 46585</M> and <M>6^6 = 46656</M>.

</Section>

<!-- #################################################################### -->

<Section Label="sec:AbelianModularGroup">
<Heading>An abelian rcwa group over a polynomial ring</Heading>

We want to have a look at a wild rcwa group over GF(4)[<M>x</M>] which
happens to be abelian (of course in general, rcwa groups also over this ring
are usually far from being abelian -- see below).
We start by defining this group:

<Example>
<![CDATA[
gap> x := Indeterminate(GF(4),1);; SetName(x,"x");
gap> R := PolynomialRing(GF(4),1);
GF(4)[x]
gap> e := One(GF(4));;
gap> p := x^2 + x + e;;    q := x^2 + e;;
gap> r := x^2 + x + Z(4);; s := x^2 + x + Z(4)^2;;
gap> cg := List( AllResidues(R,x^2), pol -> [ p, p * pol mod q, q ] );;
gap> ch := List( AllResidues(R,x^2), pol -> [ r, r * pol mod s, s ] );;
gap> g := RcwaMapping( R, q, cg );
<rcwa mapping of GF(4)[x] with modulus x^2+Z(2)^0>
gap> h := RcwaMapping( R, s, ch );
<rcwa mapping of GF(4)[x] with modulus x^2+x+Z(2^2)^2>
gap> List([g,h],Order);
[ infinity, infinity ]
gap> List([g,h],IsTame);
[ false, false ]
gap> G := Group(g,h);
<rcwa group over GF(4)[x] with 2 generators>
gap> IsAbelian(G);
true
]]>
</Example>

Now we compute the action of the group <C>G</C> on one of its orbits, and
make some statistics of the orbits of <C>G</C> containing polynomials of
degree less than 4:

<Example>
<![CDATA[
gap> orb := Orbit(G,x^5);
[ x^5, x^5+x^4+x^2+Z(2)^0, x^5+x^3+x^2+Z(2^2)*x+Z(2)^0, x^5+x^3, 
  x^5+x^4+x^3+x^2+Z(2^2)^2*x+Z(2^2)^2, x^5+x, x^5+x^4+x^3, x^5+x^2+Z(2^2)^2*x,
  x^5+x^4+x^2+x, x^5+x^3+x^2+Z(2^2)^2*x+Z(2)^0, x^5+x^4+Z(2^2)*x+Z(2^2), 
  x^5+x^3+x, x^5+x^4+x^3+x^2+Z(2^2)*x+Z(2^2), x^5+x^4+x^3+x+Z(2)^0, 
  x^5+x^2+Z(2^2)*x, x^5+x^4+Z(2^2)^2*x+Z(2^2)^2 ]
gap> H := Action(G,orb);
Group([ (1,2,4,7,6,9,12,14)(3,5,8,11,10,13,15,16), 
  (1,3,6,10)(2,5,9,13)(4,8,12,15)(7,11,14,16) ])
gap> IsAbelian(H); # check ...
true
gap> Exponent(H);
8
gap> Collected(List(ShortOrbits(G,AllResidues(R,x^4),100),Length));
[ [ 1, 4 ], [ 2, 6 ], [ 4, 12 ], [ 8, 24 ] ]
]]>
</Example>

Changing the generators a little causes the group structure to change a lot:

<Example>
<![CDATA[
gap> cg[1][2] := cg[1][2] + (x^2 + e) * p * q;;
gap> ch[7][2] := ch[7][2] + x * r * s;;
gap> g := RcwaMapping( R, q, cg );;
gap> h := RcwaMapping( R, s, ch );;
gap> G := Group(g,h);
<rcwa group over GF(4)[x] with 2 generators>
gap> orb := Orbit(G,Zero(R));;
gap> Length(orb);
87
gap> Collected(List(orb,DegreeOfLaurentPolynomial));
[ [ 1, 2 ], [ 2, 4 ], [ 3, 16 ], [ 4, 64 ], [ infinity, 1 ] ]
gap> H := Action(G,orb);
<permutation group with 2 generators>
gap> IsNaturalAlternatingGroup(H);
true
gap> orb := Orbit(G,x^6);;
gap> Length(orb);
512
gap> H := Action(G,orb);
<permutation group with 2 generators>
gap> IsNaturalSymmetricGroup(H);
false
gap> IsNaturalAlternatingGroup(H);
false
gap> blk := Blocks(H,[1..512]);;
gap> List(blk,Length);
[ 128, 128, 128, 128 ]
gap> Action(H,blk,OnSets);
Group([ (1,2)(3,4), (1,3)(2,4) ])
]]>
</Example>

Thus the modified group has a quotient isomorphic to the alternating group
of degree 87, and a quotient isomorphic to some wreath product or a subgroup
thereof acting transitively, but not primitively on 512 points.

</Section>

<!-- #################################################################### -->

<Section Label="sec:StructureOfWildGroup">
<Heading>Exploring the structure of a wild rcwa group</Heading>

In this example we make a simple attempt to investigate the structure of
a given wild group by finding orders of torsion elements.
First of all we define our group:

<Example>
<![CDATA[
gap> u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;
gap> SetName(u,"u");
gap> Display(u);

Rcwa mapping of Z with modulus 5

                n mod 5                |                 n^u
---------------------------------------+--------------------------------------
  0                                    | 3n/5
  1                                    | (9n + 1)/5
  2                                    | (3n - 1)/5
  3                                    | (9n - 2)/5
  4                                    | (9n + 4)/5

gap> nu := RcwaMapping([[1,1,1]]);
Rcwa mapping of Z: n -> n + 1
gap> SetName(nu,"nu");
gap> G := Group(u,nu);
<rcwa group over Z with 2 generators>
gap> IsTame(G);
false
]]>
</Example>

Now we would like to know which orders torsion elements of <C>G</C>
can have -- taking a look at the above generators it seems to make sense
to try commutators:

<Example>
<![CDATA[
gap> l := Filtered([0..100],k->IsTame(Comm(u,nu^k)));
[ 0, 2, 3, 5, 6, 9, 10, 12, 13, 15, 17, 18, 20, 21, 24, 25, 27, 28, 30, 32, 
  33, 35, 36, 39, 40, 42, 43, 45, 47, 48, 50, 51, 54, 55, 57, 58, 60, 62, 63, 
  65, 66, 69, 70, 72, 73, 75, 77, 78, 80, 81, 84, 85, 87, 88, 90, 92, 93, 95, 
  96, 99, 100 ]
gap> List(l,k->Order(Comm(u,nu^k)));
[ 1, 6, 5, 3, 5, 5, 3, infinity, 7, infinity, 7, 5, 3, infinity, infinity, 3, 
  5, 7, infinity, 7, infinity, 3, 5, 5, 3, 5, infinity, infinity, infinity, 
  5, 3, 5, 5, 3, infinity, 7, infinity, 7, 5, 3, infinity, infinity, 3, 5, 7, 
  infinity, 7, infinity, 3, 5, 5, 3, 5, infinity, infinity, infinity, 5, 3, 
  5, 5, 3 ]
gap> Display(Comm(u,nu^13));

Bijective rcwa mapping of Z with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0 3 6                                | n + 5
  1 4 7                                | 3n - 9
  2 8                                  | n - 11
  5                                    | (n + 16)/3

gap> Order(Comm(u,nu^13));
7
gap> u2 := u^2;
<bijective rcwa mapping of Z with modulus 25>
gap> Filtered([1..16],k->IsTame(Comm(u2,nu^k))); # k < 15 -> commutator wild!
[ 15 ]
gap> Order(Comm(u2,nu^15));
infinity
gap> u2nu17 := Comm(u2,nu^17);
<bijective rcwa mapping of Z with modulus 81>
gap> orbs := ShortOrbits(Group(u2nu17),[-100..100],100);;
gap> List(orbs,Length);
[ 72, 72, 73, 72, 73, 72, 72, 73, 72, 72, 72, 73, 72, 72, 73, 72, 72, 73, 72, 
  72, 73, 72, 72 ]
gap> Lcm(last);
5256
gap> u2nu17^5256; # This element has indeed order 2^3*3^2*73 = 5256.
IdentityMapping( Integers )
gap> u2nu18 := Comm(u2,nu^18);
<bijective rcwa mapping of Z with modulus 81>
gap> orbs := ShortOrbits(Group(u2nu18),[-100..100],100);;
gap> List(orbs,Length);
[ 22, 22, 22, 21, 22, 22, 22, 21, 21, 22, 22, 21, 22, 21, 22, 22, 21, 22, 22, 
  21, 22, 22, 21 ]
gap> Lcm(last);
462
gap> u2nu18^462; # This is an element of order 2*3*7*11 = 462.
IdentityMapping( Integers )
gap> Order(Comm(u2,nu^20));
29
gap> Order(Comm(u2,nu^25));
9
gap> Order(Comm(u2,nu^30));
15
]]>
</Example>

We conclude that even this rather simple-minded approach reveals
various different orders of torsion elements, and the involved primes
are also not all quite <Q>small</Q>.

</Section>

<!-- #################################################################### -->

<Section Label="sec:SubgroupOfS9">
<Heading>An rcwa representation of a small group</Heading>

  We give an rcwa representation of the 3-Sylow-subgroup of the symmetric
  group on 9 points. Certainly this group has a very nice permutation
  representation, hence for computational purposes we do not gain anything
  here.

<Example>
<![CDATA[
gap> r := RcwaMapping([[1,0,1],[1,1,1],[3,-3,1],
>                      [1,0,3],[1,1,1],[3,-3,1],
>                      [1,0,1],[1,1,1],[3,-3,1]]);;
gap> s := RcwaMapping([[1,0,1],[1,1,1],[3,6,1],
>                      [1,0,3],[1,1,1],[3,6,1],
>                      [1,0,1],[1,1,1],[3,-21,1]]);;
gap> SetName(r,"r"); SetName(s,"s");
gap> Display(r);

Rcwa mapping of Z with modulus 9

                n mod 9                |                 n^r
---------------------------------------+--------------------------------------
  0 6                                  | n
  1 4 7                                | n + 1
  2 5 8                                | 3n - 3
  3                                    | n/3

gap> Display(s);

Rcwa mapping of Z with modulus 9

                n mod 9                |                 n^s
---------------------------------------+--------------------------------------
  0 6                                  | n
  1 4 7                                | n + 1
  2 5                                  | 3n + 6
  3                                    | n/3
  8                                    | 3n - 21

gap> G := Group(r,s);
<rcwa group over Z with 2 generators>
gap> H := SylowSubgroup(SymmetricGroup(9),3);
Group([ (1,2,3), (4,5,6), (7,8,9), (1,4,7)(2,5,8)(3,6,9) ])
gap> phi := InverseGeneralMapping(IsomorphismGroups(G,H));
[ (1,8,6)(2,9,4)(3,7,5), (1,9,6,2,7,4,3,8,5) ] -> [ r, s ]
gap> (1,2,3)^phi;
<bijective rcwa mapping of Z with modulus 27>
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:RcwaRepresentationOfS10">
<Heading>
  An rcwa representation of the symmetric group on 10 points
</Heading>

  We start by defining some bijections of infinite order and computing
  commutators (the mapping <M>a</M> has already been discussed briefly
  in the Introduction (<Ref Label="ch:Introduction"/>)):

<Example>
<![CDATA[
gap> a := RcwaMapping([[3,0,2],[3, 1,4],[3,0,2],[3,-1,4]]);;
gap> b := RcwaMapping([[3,0,2],[3,13,4],[3,0,2],[3,-1,4]]);;
gap> c := RcwaMapping([[3,0,2],[3, 1,4],[3,0,2],[3,11,4]]);;
gap> SetName(a,"a"); SetName(b,"b"); SetName(c,"c");
gap> List([a,b,c],Order);
[ infinity, infinity, infinity ]
gap> ab := Comm(a,b);; ac := Comm(a,c);; bc := Comm(b,c);;
gap> SetName(ab,"[a,b]"); SetName(ac,"[a,c]"); SetName(bc,"[b,c]");
gap> List([ab,ac,bc],Order);
[ 6, 6, 12 ]
]]>
</Example>

  Now we would like to have a look at [ <A>a</A>, <A>b</A> ] ...

<Example>
<![CDATA[
gap> Display(ab);

Bijective rcwa mapping of Z with modulus 18, of order 6

               n mod 18                |               n^[a,b]
---------------------------------------+--------------------------------------
   0  2  3  8  9 11 12 17              | n
   1 10                                | 2n - 5
   4  7 13 16                          | n + 3
   5 14                                | 2n - 4
   6                                   | (n + 2)/2
  15                                   | (n - 5)/2

]]>
</Example>

  ... form the group generated by [ <A>a</A>, <A>b</A> ]
  and [ <A>a</A>, <A>c</A> ] and compute its action on one of its orbits:

<Example>
<![CDATA[
gap> G := Group(ab,ac);
<rcwa group over Z with 2 generators>
gap> orb := Orbit(G,1);
[ -15, -12, -7, -6, -5, -4, -3, -2, -1, 1 ]
gap> H := Action(G,orb);
Group([ (2,5,8,10,7,6), (1,3,6,9,4,5) ])
gap> Size(H);
3628800
gap> Size(G); # G acts faithful on orb.
3628800
]]>
</Example>

  Hence the group <A>G</A> is isomorphic to the symmetric group on 10 points
  and acts faithfully on the orbit containing 1.

  We also would like to know which groups arise if we take as generators
  either <A>ab</A>, <A>ac</A> or <A>bc</A> and the mapping <A>t</A>, which
  maps each integer to its additive inverse:

<Example>
<![CDATA[
gap> t := RcwaMapping([[-1,0,1]]);
Rcwa mapping of Z: n -> -n
gap> Order(t);
2
gap> G := Group(ab,t);
<rcwa group over Z with 2 generators>
gap> Size(G);
7257600
gap> H := Image(IsomorphismPermGroup(G));;
gap> H2 := Group((1,2),(1,2,3,4,5,6,7,8,9,10),(11,12));;
gap> IsomorphismGroups(H,H2) <> fail; # H = C2 x S10
true
]]>
</Example>

  Thus the group generated by <A>ab</A> and <A>t</A> is isomorphic to 
  <Alt Only="LaTeX"><M>{\rm C}_2 \times {\rm S}_{10}</M></Alt>
  <Alt Not="LaTeX"><M>C_2 x S_{10}</M></Alt>.
  The next group is an extension of a perfect group of order 960:

<Example>
<![CDATA[
gap> G := Group(ac,t);;
gap> Size(G);
3840
gap> H := Image(IsomorphismPermGroup(G));;
gap> P := DerivedSubgroup(H);
Group([ (2,15,3,5,16)(4,6,18,7,17)(9,19,10,12,20)(11,13,22,14,21), 
  (2,3,5,7,16)(4,15,6,18,17)(9,10,12,14,20)(11,19,13,22,21) ])
gap> Size(P);
960
gap> IsPerfect(P);
true
gap> PerfectGroup(PerfectIdentification(P));
A5 2^4'
]]>
</Example>

  The last group is infinite:

<Example>
<![CDATA[
gap> G := Group(bc,t);;
gap> Size(G);
infinity
gap> Order(bc*t);
infinity
gap> Modulus(G);
18
gap> ResidueClassUnionViewingFormat("short");
gap> RespectedClassPartition(G);
[ 0(18), 1(18), 2(18), 4(18), 5(18), 7(18), 8(18), 9(18), 10(18), 11(18), 
  13(18), 14(18), 16(18), 17(18), 3(36), 6(36), 12(36), 15(36), 21(36), 
  24(36), 30(36), 33(36) ]
gap> D := DerivedSubgroup(ActionOnClassPartition(G));;
gap> DegreeAction(D);
20
gap> IsPerfect(D);
true
gap> Size(D);
928972800
gap> RankOfKernelOfActionOnClassPartition(G);
9
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:LocalExample">
<Heading>Some examples over (semi)localizations of the integers</Heading>

We start with something one can observe when trying to <Q>transfer</Q> an
rcwa mapping from the ring of integers to one of its localizations (we take
the mapping <C>a</C> from the last example):

<Example>
<![CDATA[
gap> a2 := RcwaMapping(Z_pi(2),ShallowCopy(Coefficients(a)));
<rcwa mapping of Z_( 2 ) with modulus 4>
gap> IsSurjective(a2); # As expected
true
gap> IsInjective(a2); # Why not??
false
gap> 0^a2;
0
gap> (1/3)^a2; # That's the reason!
0
]]>
</Example>

The above can also be explained easily by pointing out that the modulus
of the inverse of <C>a</C> is 3, and that 3 is a unit of
<M>\mathbb{Z}_{(2)}</M>.
Moving to <M>\mathbb{Z}_{(2,3)}</M> solves this problem:

<Example>
<![CDATA[
gap> a23 := RcwaMapping(Z_pi([2,3]),ShallowCopy(Coefficients(a)));
<rcwa mapping of Z_( 2, 3 ) with modulus 4>
gap> IsBijective(a23);
true
]]>
</Example>

We get additional finite cycles, e.g.:

<Example>
<![CDATA[
gap> List(ShortOrbits(Group(a23),[0..50]/5,50),orb->Cycle(a23,orb[1]));
[ [ 0 ], [ 1/5, 2/5, 3/5 ], 
  [ 4/5, 6/5, 9/5, 8/5, 12/5, 18/5, 27/5, 19/5, 13/5, 11/5, 7/5 ], [ 1 ], 
  [ 2, 3 ], [ 14/5, 21/5, 17/5 ], 
  [ 16/5, 24/5, 36/5, 54/5, 81/5, 62/5, 93/5, 71/5, 52/5, 78/5, 117/5, 89/5, 
      68/5, 102/5, 153/5, 116/5, 174/5, 261/5, 197/5, 149/5, 113/5, 86/5, 
      129/5, 98/5, 147/5, 109/5, 83/5, 61/5, 47/5, 34/5, 51/5, 37/5, 29/5, 
      23/5 ], [ 4, 6, 9, 7, 5 ] ]
gap> List(last,Length);
[ 1, 3, 11, 1, 2, 3, 34, 5 ]
gap> List(ShortOrbits(Group(a23),[0..50]/7,50),orb->Cycle(a23,orb[1]));
[ [ 0 ], [ -1/7, 1/7 ], [ 2/7, 3/7, 4/7, 6/7, 9/7, 5/7 ], [ 1 ], [ 2, 3 ], 
  [ 4, 6, 9, 7, 5 ] ]
gap> List(last,Length);
[ 1, 2, 6, 1, 2, 5 ]
gap> List(ShortOrbits(Group(a23),[0..50]/11,50),orb->Cycle(a23,orb[1]));
[ [ 0 ], [ -5/11, -1/11, 2/11, 3/11, 5/11, 1/11, -2/11, -3/11 ], 
  [ 4/11, 6/11, 9/11 ], [ 1 ], 
  [ 16/11, 24/11, 36/11, 54/11, 81/11, 58/11, 87/11, 68/11, 102/11, 153/11, 
      112/11, 168/11, 252/11, 378/11, 567/11, 428/11, 642/11, 963/11, 725/11, 
      541/11, 403/11, 305/11, 226/11, 339/11, 257/11, 190/11, 285/11, 211/11, 
      161/11, 118/11, 177/11, 130/11, 195/11, 149/11, 109/11, 79/11, 62/11, 
      93/11, 67/11, 53/11, 37/11, 25/11 ], [ 2, 3 ], [ 4, 6, 9, 7, 5 ] ]
gap> List(last,Length);
[ 1, 8, 3, 1, 42, 2, 5 ]
]]>
</Example>

But the group structure remains invariant under the <Q>transfer</Q>
of a group with prime set <M>\{2,3\}</M> from <M>\mathbb{Z}</M> to
<M>\mathbb{Z}_{(2,3)}</M>:

<Example>
<![CDATA[
gap> b23 := RcwaMapping(Z_pi([2,3]),ShallowCopy(Coefficients(b)));;
gap> c23 := RcwaMapping(Z_pi([2,3]),ShallowCopy(Coefficients(c)));;
gap> ab23 := Comm(a23,b23);
<rcwa mapping of Z_( 2, 3 ) with modulus 18>
gap> ac23 := Comm(a23,c23);
<rcwa mapping of Z_( 2, 3 ) with modulus 18>
gap> G := Group(ab23,ac23);
<rcwa group over Z_( 2, 3 ) with 2 generators>
gap> S := Intersection(Enumerator(Rationals){[1..200]},Z_pi([2,3]));
[ -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -12/5, -11/5, -2, -9/5, -12/7, 
  -8/5, -11/7, -10/7, -7/5, -9/7, -6/5, -8/7, -12/11, -1, -10/11, -6/7, 
  -9/11, -4/5, -8/11, -5/7, -7/11, -3/5, -4/7, -6/11, -5/11, -3/7, -2/5, 
  -4/11, -2/7, -3/11, -1/5, -2/11, -1/7, -1/11, 0, 1/13, 1/11, 1/7, 2/13, 
  2/11, 1/5, 3/13, 3/11, 2/7, 4/13, 4/11, 5/13, 2/5, 3/7, 5/11, 6/13, 7/13, 
  6/11, 4/7, 3/5, 8/13, 7/11, 9/13, 5/7, 8/11, 10/13, 4/5, 9/11, 11/13, 6/7, 
  10/11, 12/13, 1, 12/11, 8/7, 13/11, 6/5, 9/7, 7/5, 10/7, 11/7, 8/5, 12/7, 
  9/5, 2, 11/5, 12/5, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ]
gap> orbs := ShortOrbits(G,S,50);;
gap> List(orbs,Length);
[ 10, 10, 1, 10, 1, 10, 10, 10, 10, 10, 1, 10, 10, 10, 1, 10, 10, 10, 10, 10, 
  10, 10, 10, 10, 10, 10, 10, 10, 1, 10, 10, 10, 10, 10, 10, 10, 10, 10, 1, 
  10, 1, 10, 10, 10, 1, 1, 10, 1, 10 ]
gap> ForAll(orbs,orb->IsNaturalSymmetricGroup(Action(G,orb)));
true
]]>
</Example>

<Q>Transferring</Q> a non-invertible rcwa mapping from the ring of integers
to some of its (semi)localizations can also turn it into an invertible one:

<Example>
<![CDATA[
gap> v := RcwaMapping([[6,0,1],[1,-7,2],[6,0,1],[1,-1,1],
>                      [6,0,1],[1, 1,2],[6,0,1],[1,-1,1]]);;
gap> SetName(v,"v");
gap> Display(v);

Rcwa mapping of Z with modulus 8

                n mod 8                |                 n^v
---------------------------------------+--------------------------------------
  0 2 4 6                              | 6n
  1                                    | (n - 7)/2
  3 7                                  | n - 1
  5                                    | (n + 1)/2

gap> IsInjective(v);
true
gap> IsSurjective(v);
false
gap> Image(v);
1(2) U 2(4) U 0(12)
gap> Difference(Integers,last);
4(12) U 8(12)
gap> v2 := RcwaMapping(Z_pi(2),ShallowCopy(Coefficients(v)));
<rcwa mapping of Z_( 2 ) with modulus 8>
gap> IsBijective(v2);
true
gap> Display(v2^-1);

Bijective rcwa mapping of Z_( 2 ) with modulus 4

                n mod 4                |                 n^f
---------------------------------------+--------------------------------------
  0                                    | 1/3 n / 2
  1                                    | 2 n + 7
  2                                    | n + 1
  3                                    | 2 n - 1

gap> S := ResidueClass(Z_pi(2),2,0);; l := [S];;
gap> for i in [1..10] do Add(l,l[Length(l)]^v2); od;
gap> l; # Visibly v2 is wild ...
[ 0(2), 0(4), 0(8), 0(16), 0(32), 0(64), 0(128), 0(256), 0(512), 0(1024), 
  0(2048) ]
gap> w2 := RcwaMapping(Z_pi(2),[[1,0,2],[2,-1,1],[1,1,1],[2,-1,1]]);;
gap> v2w2 := Comm(v2,w2);; SetName(v2w2,"[v2,w2]"); v2w2^-1;;
gap> Display(v2w2);

Bijective rcwa mapping of Z_( 2 ) with modulus 8

                n mod 8                |              n^[v2,w2]
---------------------------------------+--------------------------------------
  0 3 4 7                              | n
  1                                    | n + 4
  2 6                                  | 3 n
  5                                    | n - 4

]]>
</Example>

  Again, viewed as an rcwa mapping of the integers the commutator given at
  the end of our example would not be surjective.

</Section>

<!-- #################################################################### -->

<Section Label="sec:Twisting257CyclesToModulus32">
<Heading>
  Twisting 257-cycles into an rcwa mapping with modulus 32
</Heading>

  We define an rcwa mapping <A>x</A> of order 257 with modulus 32
  (the easiest way to construct such a mapping is to prescribe the
  graph and then to assign suitable affine mappings to its vertices).

<Example>
<![CDATA[
gap> x := RcwaMapping([[ 16,  2,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1, 16,  1], [ 16, 18,  1],
>                      [  1,  0, 16], [ 16, 18,  1],
>                      [  1,-14,  1], [ 16, 18,  1],
>                      [  1,-14,  1], [ 16, 18,  1],
>                      [  1,-14,  1], [ 16, 18,  1],
>                      [  1,-14,  1], [ 16, 18,  1],
>                      [  1,-14,  1], [ 16, 18,  1],
>                      [  1,-14,  1], [ 16, 18,  1],
>                      [  1,-14,  1], [  1,-31,  1]]);;
gap> SetName(x,"x");
gap> Display(x);

Rcwa mapping of Z with modulus 32

               n mod 32                |                 n^x
---------------------------------------+--------------------------------------
   0                                   | 16n + 2
   1  3  5  7  9 11 13 15 17 19 21 23  | 
  25 27 29                             | 16n + 18
   2  4  6  8 10 12 14                 | n + 16
  16                                   | n/16
  18 20 22 24 26 28 30                 | n - 14
  31                                   | n - 31

gap> Order(x);
257
gap> List([-20..20],n->n^x);
[ -4, -286, -2, -254, -1, -222, -28, -190, -26, -158, -24, -126, -22, -94, 
  -20, -62, -18, -30, -16, -32, 2, 34, 18, 66, 20, 98, 22, 130, 24, 162, 26, 
  194, 28, 226, 30, 258, 1, 290, 4, 322, 6 ]
]]>
</Example>

  Certainly we would like to know how a cycle of this permutation looks
  like:

<Example>
<![CDATA[
gap> Cycle(x,[1],0);
[ 0, 2, 18, 4, 20, 6, 22, 8, 24, 10, 26, 12, 28, 14, 30, 16, 1, 34, 50, 36, 
  52, 38, 54, 40, 56, 42, 58, 44, 60, 46, 62, 48, 3, 66, 82, 68, 84, 70, 86, 
  72, 88, 74, 90, 76, 92, 78, 94, 80, 5, 98, 114, 100, 116, 102, 118, 104, 
  120, 106, 122, 108, 124, 110, 126, 112, 7, 130, 146, 132, 148, 134, 150, 
  136, 152, 138, 154, 140, 156, 142, 158, 144, 9, 162, 178, 164, 180, 166, 
  182, 168, 184, 170, 186, 172, 188, 174, 190, 176, 11, 194, 210, 196, 212, 
  198, 214, 200, 216, 202, 218, 204, 220, 206, 222, 208, 13, 226, 242, 228, 
  244, 230, 246, 232, 248, 234, 250, 236, 252, 238, 254, 240, 15, 258, 274, 
  260, 276, 262, 278, 264, 280, 266, 282, 268, 284, 270, 286, 272, 17, 290, 
  306, 292, 308, 294, 310, 296, 312, 298, 314, 300, 316, 302, 318, 304, 19, 
  322, 338, 324, 340, 326, 342, 328, 344, 330, 346, 332, 348, 334, 350, 336, 
  21, 354, 370, 356, 372, 358, 374, 360, 376, 362, 378, 364, 380, 366, 382, 
  368, 23, 386, 402, 388, 404, 390, 406, 392, 408, 394, 410, 396, 412, 398, 
  414, 400, 25, 418, 434, 420, 436, 422, 438, 424, 440, 426, 442, 428, 444, 
  430, 446, 432, 27, 450, 466, 452, 468, 454, 470, 456, 472, 458, 474, 460, 
  476, 462, 478, 464, 29, 482, 498, 484, 500, 486, 502, 488, 504, 490, 506, 
  492, 508, 494, 510, 496, 31 ]
gap> Length(last);
257
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ModuliOfPowers">
<Heading> The behaviour of the moduli of powers </Heading>

  In this section we give some examples illustrating how different the
  series of the moduli of powers of a given rcwa mapping of the integers
  can look like.

<Example>
<![CDATA[
gap> List([0..4],i->Modulus(a^i));
[ 1, 4, 16, 64, 256 ]
gap> List([0..6],i->Modulus(ab^i));
[ 1, 18, 18, 18, 18, 18, 1 ]
gap> List([0..3],i->Modulus(r^i));
[ 1, 9, 9, 1 ]
gap> List([0..9],i->Modulus(s^i));
[ 1, 9, 9, 27, 27, 27, 27, 27, 27, 1 ]
gap> g := RcwaMapping([[2,2,1],[1,4,1],[1,0,2],[2,2,1],[1,-4,1],[1,-2,1]]);;
gap> List([0..7],i->Modulus(g^i));
[ 1, 6, 12, 12, 12, 12, 6, 1 ]
gap> u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;
gap> List([0..3],i->Modulus(u^i));
[ 1, 5, 25, 125 ]
gap> v6 := RcwaMapping([[-1,2,1],[1,-1,1],[1,-1,1]]);;
gap> List([0..6],i->Modulus(v6^i));
[ 1, 3, 3, 3, 3, 3, 1 ]
gap> w8 := RcwaMapping([[-1,3,1],[1,-1,1],[1,-1,1],[1,-1,1]]);;
gap> List([0..8],i->Modulus(w8^i));
[ 1, 4, 4, 4, 4, 4, 4, 4, 1 ]
gap> z := RcwaMapping([[2,  1, 1],[1,  1,1],[2, -1,1],[2, -2,1],
>                      [1,  6, 2],[1,  1,1],[1, -6,2],[2,  5,1],
>                      [1,  6, 2],[1,  1,1],[1,  1,1],[2, -5,1],
>                      [1,  0, 1],[1, -4,1],[1,  0,1],[2,-10,1]]);;
gap> SetName(z,"z");
gap> Order(z);
infinity
gap> Display(z);

Bijective rcwa mapping of Z with modulus 16, of order infinity

               n mod 16                |                 n^z
---------------------------------------+--------------------------------------
   0                                   | 2n + 1
   1  5  9 10                          | n + 1
   2                                   | 2n - 1
   3                                   | 2n - 2
   4  8                                | (n + 6)/2
   6                                   | (n - 6)/2
   7                                   | 2n + 5
  11                                   | 2n - 5
  12 14                                | n
  13                                   | n - 4
  15                                   | 2n - 10

gap> List([0..25],i->Modulus(z^i));
[ 1, 16, 32, 64, 64, 128, 128, 128, 128, 128, 128, 256, 256, 256, 256, 256, 
  256, 512, 512, 512, 512, 512, 512, 1024, 1024, 1024 ]
gap> e1 := RcwaMapping([[1,4,1],[2,0,1],[1,0,2],[2,0,1]]);;
gap> e2 := RcwaMapping([[1,4,1],[2,0,1],[1,0,2],[1,0,1],
>                       [1,4,1],[2,0,1],[1,0,1],[1,0,1]]);;
gap> List([e1,e2],Order);
[ infinity, infinity ]
gap> List([1..20],i->Modulus(e1^i));
[ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 ]
gap> List([1..20],i->Modulus(e2^i));
[ 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4 ]
gap> SetName(e1,"e1"); SetName(e2,"e2");
gap> Display(e2);

Bijective rcwa mapping of Z with modulus 8, of order infinity

                n mod 8                |                 n^e2
---------------------------------------+--------------------------------------
  0 4                                  | n + 4
  1 5                                  | 2n
  2                                    | n/2
  3 6 7                                | n

gap> e2^2 = Restriction(RcwaMapping([[1,2,1]]),RcwaMapping([[4,0,1]]));
true
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:CollatzImagesAndPreImages">
<Heading> Images and preimages under the Collatz mapping </Heading>

  We would like to have a look at the images of the residue class 1(2)
  under powers of the Collatz mapping.

<Example>
<![CDATA[
gap> T := RcwaMapping([[1,0,2],[3,1,2]]);;
gap> S0 := ResidueClass(Integers,2,1);
1(2)
gap> S1 := S0^T;
2(3)
gap> S2 := S1^T;
1(3) U 8(9)
gap> S3 := S2^T;
2(3) U 4(9)
gap> S4 := S3^T;
1(3) U 2(9) U 8(9)
gap> S5 := S4^T;
2(3) U 1(9) U 4(9)
gap> S6 := S5^T;
1(3) U 2(3)
gap> S7 := S6^T;
1(3) U 2(3)
]]>
</Example>

  We see that the image gets stable after applying the mapping <M>T</M> for
  the 6th time, hence that <M>T^6</M> maps the residue class 1(2)
  surjectively onto the union of the residue classes 1(3) and 2(3), which is
  setwisely stabilized by <M>T</M>.
  Now we would like to determine the preimages of 1(3) resp. 2(3) in 1(2)
  under <M>T^6</M>. The residue class 1(2) has to be the disjoint union of
  these sets.

<Example>
<![CDATA[
gap> U := ResidueClass(Integers,3,1);;
gap> for i in [1..6] do U := PreImage(T,U); od;
gap> U := Intersection(U,S0);
<union of 11 residue classes (mod 64)>
gap> V := ResidueClass(Integers,3,2);;
gap> for i in [1..6] do V := PreImage(T,V); od;
gap> V := Intersection(V,S0);
<union of 21 residue classes (mod 64)>
gap> Display(U);

The union of the residue classes r ( mod 64 )  for r =

  1  5  7  9 21 23 29 31 49 51 59

gap> Display(V);

The union of the residue classes r ( mod 64 )  for r =

  3 11 13 15 17 19 25 27 33 35 37 39 41 43 45 47 53 55 57 61 63

gap> Union(U,V) = S0 and Intersection(U,V) = [];  # consistency check
true
]]>
</Example>

  Now we want to determine the images of the residue class 0(3) under
  powers of <M>T</M>:

<Example>
<![CDATA[
gap> S0 := ResidueClass(Integers,3,0);
0(3)
gap> S1 := S0^T;
0(3) U 5(9)
gap> S2 := S1^T;
0(3) U 5(9) U 7(9) U 8(27)
gap> S3 := S2^T;
<union of 20 residue classes (mod 27)>
gap> S4 := S3^T;
<union of 73 residue classes (mod 81)>
gap> S5 := S4^T;
<union of 79 residue classes (mod 81)>
gap> S6 := S5^T;
Integers
gap> S7 := S6^T;
Integers
]]>
</Example>

  Thus, every integer is the image of a multiple of 3 under <M>T^6</M>.
  This means that it would be sufficient to prove the Collatz conjecture
  for multiples of 3.
  We can obtain the corresponding result for multiples of 5 as follows:

<Example>
<![CDATA[
gap> S := [ResidueClass(Integers,5,0)];
[ 0(5) ]
gap> for i in [1..12] do Add(S,S[i]^T); od;
gap> for s in S do View(s); Print("\n"); od;
0(5)
0(5) U 8(15)
0(5) U 4(15) U 8(15)
0(5) U 2(15) U 4(15) U 8(15) U 29(45)
<union of 73 residue classes (mod 135)>
<union of 244 residue classes (mod 405)>
<union of 784 residue classes (mod 1215)>
<union of 824 residue classes (mod 1215)>
<union of 2593 residue classes (mod 3645)>
<union of 2647 residue classes (mod 3645)>
<union of 2665 residue classes (mod 3645)>
<union of 2671 residue classes (mod 3645)>
1(3) U 2(3) U 0(15)
gap> Union(S[13],ResidueClass(Integers,3,0));
Integers
gap> List(S,Si->Float(Length(Residues(Si))/Modulus(Si)));
[ 0.2, 0.266667, 0.333333, 0.422222, 0.540741, 0.602469, 0.645267, 0.678189, 
  0.711385, 0.7262, 0.731139, 0.732785, 0.733333 ]
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:CollatzMapping">
<Heading>Replacing the Collatz mapping by conjugates</Heading>

  This is probably not the most interesting application of this package,
  but we can turn the Collatz-problem into an equivalent question by
  replacing the Collatz mapping <A>T</A> by one of its conjugates under an
  element of the pointwise stabilizer of 1 in the setwise stabilizer of the
  positive integers of RCWA(<M>\Z</M>). Define the Collatz mapping:

<Example>
<![CDATA[
gap> T := RcwaMapping([[1,0,2],[3,1,2]]);
<rcwa mapping of Z with modulus 2>
]]>
</Example>

  A suitable bijection:

<Example>
<![CDATA[
gap> a := RcwaMapping([[3,0,2],[3,1,4],[3,0,2],[3,-1,4]]);
<rcwa mapping of Z with modulus 4>
gap> IsBijective(a);
true
gap> 1^a; # The mapping a stabilizes 1
1
]]>
</Example>

  Some evidence that <A>a</A> stabilizes the set of positive integers (this
  certainly can be proved easily ...):

<Example>
<![CDATA[
gap> List([1..50],n->n^a);
[ 1, 3, 2, 6, 4, 9, 5, 12, 7, 15, 8, 18, 10, 21, 11, 24, 13, 27, 14, 30, 16, 
  33, 17, 36, 19, 39, 20, 42, 22, 45, 23, 48, 25, 51, 26, 54, 28, 57, 29, 60, 
  31, 63, 32, 66, 34, 69, 35, 72, 37, 75 ]
]]>
</Example>

  Compute <M>T^a</M>:

<Example>
<![CDATA[
gap> f := T^a;;
gap> Display(f);

Rcwa mapping of Z with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0  6                                | n/2
   1  4  7 10                          | 3n
   2  8                                | (3n + 2)/2
   3                                   | (n + 1)/4
   5 11                                | (3n + 1)/2
   9                                   | (n - 1)/4

]]>
</Example>

  Have a look at resulting integer sequences:

<Example>
<![CDATA[
gap> seq := function(n)
>             repeat Print(n,","); n := n^f; until n = 1; Print("1.\n");
>           end;
function( n ) ... end
gap> seq(7);
7,21,5,8,13,39,10,30,15,4,12,6,3,1.
gap> seq(10);
10,30,15,4,12,6,3,1.
gap> seq(20);
20,31,93,23,35,53,80,121,363,91,273,68,103,309,77,116,175,525,131,197,296,445,
1335,334,1002,501,125,188,283,849,212,319,957,239,359,539,809,1214,1822,5466,
2733,683,1025,1538,2308,6924,3462,1731,433,1299,325,975,244,732,366,183,46,
138,69,17,26,40,120,60,30,15,4,12,6,3,1.
]]>
</Example>

  It seems that they all end up with 1, like the original
  <M>3n+1</M> sequences ... .

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->






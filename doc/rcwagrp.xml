<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  rcwagrp.xml         RCWA documentation           Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$     ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:RcwaGroups">
<Heading>Residue-Class-Wise Affine Groups</Heading>

In this chapter, we describe how to construct residue-class-wise affine
groups and how to compute with them.

<!-- #################################################################### -->

<Section Label="sec:ContructingRcwaGroups">
<Heading>Constructing residue-class-wise affine groups</Heading>

<Index Key="Group"><C>Group</C></Index>
<Index Key="GroupByGenerators"><C>GroupByGenerators</C></Index>
<Index Key="GroupWithGenerators"><C>GroupWithGenerators</C></Index>

As any other groups in &GAP;, residue-class-wise affine groups
can be constructed by <C>Group</C>, <C>GroupByGenerators</C> or
<C>GroupWithGenerators</C>.

<Example>
<![CDATA[
gap> G := Group(ClassTransposition(0,2,1,4),ClassShift(0,5));
<rcwa group over Z with 2 generators>
gap> IsTame(G); Size(G); IsSolvable(G); IsPerfect(G);
true
infinity
false
false
]]>
</Example>

<Index Key="View" Subkey="for an rcwa group"><C>View</C></Index>
<Index Key="Display" Subkey="for an rcwa group"><C>Display</C></Index>
<Index Key="Print" Subkey="for an rcwa group"><C>Print</C></Index>
<Index Key="String" Subkey="for an rcwa group"><C>String</C></Index>

There are methods for the operations <C>View</C>, <C>Display</C>,
<C>Print</C> and <C>String</C> which are applicable to rcwa groups.
All rcwa groups over a ring <M>R</M> are subgroups of RCWA(<M>R</M>).
The group RCWA(<M>R</M>) itself is not finitely generated, thus cannot
be constructed as described above. It is handled as a special case:

<ManSection>
  <Func Name="RCWA"
        Arg="R" Label="the group of all rcwa permutations of a ring"/>
  <Returns>
    The group RCWA(<A>R</A>) of all residue-class-wise affine
    permutations of the ring&nbsp;<A>R</A>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> RCWA_Z := RCWA(Integers);
RCWA(Z)
gap> IsSubgroup(RCWA_Z,G);
true
]]>
</Example>
  </Description>
</ManSection>

Examples of rcwa permutations can be obtained via
<C>Random(RCWA(<A>R</A>))</C>, see Section&nbsp;<Ref Label="sec:Random"/>.
<P/>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

We denote the group which is generated by all
class transpositions of the ring&nbsp;<M>R</M> by CT(<M>R</M>).
This group is handled as a special case as well:

<ManSection>
  <Func Name="CT" Arg="R"
        Label="the group generated by all class transpositions of a ring"/>
  <Returns>
    The group CT(<A>R</A>) which is generated by all
    class transpositions of the ring&nbsp;<M>R</M>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> CT_Z := CT(Integers);
CT(Z)
gap> IsSimple(CT_Z); # One of a longer list of stored attributes/properties.
true
gap> IsSubgroup(CT_Z,G);
false
]]>
</Example>
  </Description>
</ManSection>

Another way of constructing an rcwa group is taking the image of an
rcwa representation:

<ManSection>
  <Attr Name="IsomorphismRcwaGroup"
        Arg="G, R" Label="for a group, over a given ring"/>
  <Attr Name="IsomorphismRcwaGroup"
        Arg="G" Label="for a group"/>
  <Returns>
    A monomorphism from the group <A>G</A> to&nbsp;RCWA(<A>R</A>)
    or to&nbsp;RCWA(<M>\Z</M>), respectively.
  </Returns>
  <Description>
    The best-supported case is <A>R</A> = <M>\Z</M>.
    Currently there are methods available for finite groups, for
    free products of finite groups and for free groups. The method for
    free products of finite groups uses the Table-Tennis Lemma
    (cp. e.g. Section&nbsp;II.B. in&nbsp;<Cite Key="LaHarpe00"/>), and the
    method for free groups uses an adaptation of the construction given
    on page&nbsp;27 in&nbsp;<Cite Key="LaHarpe00"/> from
    PSL(2,<M>\C</M>) to RCWA(<M>\Z</M>). <P/>
<Example>
<![CDATA[
gap> F := FreeProduct(Group((1,2)(3,4),(1,3)(2,4)),Group((1,2,3)),
>                     SymmetricGroup(3));
<fp group on the generators [ f1, f2, f3, f4, f5 ]>
gap> IsomorphismRcwaGroup(F);
[ f1, f2, f3, f4, f5 ] -> [ <bijective rcwa mapping of Z with modulus 12>,
  <bijective rcwa mapping of Z with modulus 24>,
  <bijective rcwa mapping of Z with modulus 12>,
  <bijective rcwa mapping of Z with modulus 72>,
  <bijective rcwa mapping of Z with modulus 36> ]
gap> IsomorphismRcwaGroup(FreeGroup(2));
[ f1, f2 ] -> [ <wild bijective rcwa mapping of Z with modulus 8>,
  <wild bijective rcwa mapping of Z with modulus 8> ]
gap> F2 := Image(last);
<wild rcwa group over Z with 2 generators>
]]>
</Example>
  </Description>
</ManSection>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<ManSection>
  <Meth Name="StructureDescription" Arg="G" Label="for an rcwa group"/>
  <Returns>
    A string which describes the structure of the rcwa group&nbsp;<A>G</A>
    to some extent.
  </Returns>
  <Description>
    The attribute <C>StructureDescription</C> for finite groups is
    documented in the &GAP; Reference Manual. Therefore we describe here
    only issues which are specific to infinite groups, and in particular
    to rcwa groups. <P/>

    Wreath products are denoted by&nbsp;<C>wr</C>, and free products are
    denoted by&nbsp;<C>*</C>. The infinite cyclic group <M>(\Z,+)</M> is
    denoted by&nbsp;<C>Z</C>, the infinite dihedral group is denoted
    by&nbsp;<C>D0</C> and free groups of rank <M>2,3,4,\dots</M>
    are denoted by&nbsp;<C>F2</C>, <C>F3</C>, <C>F4</C>,&nbsp;<M>\dots</M>.
    While for finite groups the symbol&nbsp;<C>.</C> is used to denote a
    non-split extension, for rcwa groups in general it stands for an
    extension which may be split or not.
    For wild groups in most cases it happens that there is a large section
    on which no structural information can be obtained. Such sections of the
    group with unknown structure are denoted by <C>&lt;unknown&gt;</C>.
    In general, the structure of a section denoted by <C>&lt;unknown&gt;</C>
    can be very complicate and very difficult to exhibit.
    While for isomorphic finite groups always the same structure
    description is computed, this cannot be guaranteed for isomorphic
    rcwa groups.
<Example>
<![CDATA[
gap> G := Group(ClassTransposition(0,2,1,4),ClassShift(0,5));;
gap> StructureDescription(G);
"(Z x Z x Z x Z x Z x Z x Z) . (C2 x S7)"
gap> G := Group(ClassTransposition(0,2,1,4),
>               ClassShift(2,4),ClassReflection(1,2));;
gap> StructureDescription(G:short);
"Z^2.((S3xS3):2)"
gap> F2 := Image(IsomorphismRcwaGroup(FreeGroup(2)));;
gap> PSL2Z := Image(IsomorphismRcwaGroup(FreeProduct(CyclicGroup(3),
>                                                    CyclicGroup(2))));;
gap> G := DirectProduct(PSL2Z,F2);
<wild rcwa group over Z with 4 generators>
gap> StructureDescription(G);
"(C3 * C2) x F2"
gap> G := WreathProduct(G,CyclicGroup(IsRcwaGroupOverZ,infinity));
<wild rcwa group over Z with 5 generators>
gap> StructureDescription(G);
"((C3 * C2) x F2) wr Z"
gap> Collatz := RcwaMapping([[2,0,3],[4,-1,3],[4,1,3]]);;
gap> G := Group(Collatz,ClassShift(0,1));;
gap> StructureDescription(G:short);
"<unknown>.Z"
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:DirectProductsAndWreathProducts">
<Heading>Direct products and wreath products</Heading>

The class of groups which can faithfully be represented as rcwa groups
over the integers is closed under taking direct products, under taking
wreath products with finite groups and under taking wreath products with
the infinite cyclic group <M>(\Z,+)</M>.

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<ManSection>
  <Meth Name="DirectProduct"
        Arg="G1, G2, ..." Label="for rcwa groups over Z"/>
  <Returns>
    An rcwa group isomorphic to the direct product of the rcwa groups
    over&nbsp;<M>\Z</M> given as arguments.
  </Returns>
  <Description>
    There is certainly no unique or canonical way to embed a direct
    product of rcwa groups into RCWA(<M>\Z</M>). 
    This method chooses to embed the groups <A>G1</A>, <A>G2</A>,
    <A>G3</A>&nbsp;... via restrictions by <M>n \mapsto mn</M>,
    <M>n \mapsto mn+1</M>, <M>n \mapsto mn+2</M>&nbsp;...
    (<M>\rightarrow</M>&nbsp;<Ref Oper="Restriction"
    Label="of an rcwa group, by an injective rcwa mapping"/>),
    where <M>m</M> denotes the number of groups given as arguments.
<Example>
<![CDATA[
gap> F2 := Image(IsomorphismRcwaGroup(FreeGroup(2)));;
gap> F2xF2 := DirectProduct(F2,F2);
<wild rcwa group over Z with 4 generators>
gap> Image(Projection(F2xF2,1)) = F2;
true
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="WreathProduct" Arg="G, P"
        Label="for an rcwa group over Z and a permutation group"/>
  <Meth Name="WreathProduct" Arg="G, Z"
        Label="for an rcwa group over Z and the infinite cyclic group"/>
  <Returns>
    An rcwa group isomorphic to the wreath product of the rcwa
    group&nbsp;<A>G</A> over&nbsp;<M>\Z</M> with the finite permutation
    group&nbsp;<A>P</A> or with the infinite cyclic group&nbsp;<A>Z</A>,
    respectively.
  </Returns>
  <Description>
    The first-mentioned method embeds the <C>DegreeAction(<A>P</A>)</C>th
    direct power of&nbsp;<A>G</A> using the method for <C>DirectProduct</C>,
    and lets the permutation group&nbsp;<A>P</A> act naturally on the set of
    residue classes modulo <C>DegreeAction(<A>P</A>)</C>.
    The second-mentioned method restricts
    (<M>\rightarrow</M>&nbsp;<Ref Oper="Restriction"
    Label="of an rcwa group, by an injective rcwa mapping"/>)
    the group&nbsp;<A>G</A> to the residue class&nbsp;3(4), and maps the
    generator of the infinite cyclic group&nbsp;<A>Z</A>
    to <C>ClassTransposition(0,2,1,2) * ClassTransposition(0,2,1,4)</C>.
<Example>
<![CDATA[
gap> F2 := Image(IsomorphismRcwaGroup(FreeGroup(2)));;
gap> F2wrA5 := WreathProduct(F2,AlternatingGroup(5));;
gap> Embedding(F2wrA5,1);
[ <wild bijective rcwa mapping of Z with modulus 8>,
  <wild bijective rcwa mapping of Z with modulus 8> ] ->
[ <wild bijective rcwa mapping of Z with modulus 40>,
  <wild bijective rcwa mapping of Z with modulus 40> ]
gap> Embedding(F2wrA5,2);
[ (1,2,3,4,5), (3,4,5) ] ->
[ <bijective rcwa mapping of Z with modulus 5, of order 5>,
  <bijective rcwa mapping of Z with modulus 5, of order 3> ]
gap> ZwrZ := WreathProduct(Group(ClassShift(0,1)),Group(ClassShift(0,1)));
<wild rcwa group over Z with 2 generators>
gap> Embedding(ZwrZ,1);
[ ClassShift(0,1) ] ->
[ <tame bijective rcwa mapping of Z with modulus 4, of order infinity> ]
gap> Embedding(ZwrZ,2);
[ ClassShift(0,1) ] -> [ <wild bijective rcwa mapping of Z with modulus 4> ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:MembershipTest">
<Heading>
  The membership test
</Heading>

<Index Key="rcwa group" Subkey="membership test">rcwa group</Index>

There is a method for the operation <C>in</C>.
Given an rcwa group&nbsp;<C>G</C> and an rcwa mapping&nbsp;<C>g</C>, this
method tries to decide whether <C>g</C> is an element of&nbsp;<C>G</C> or
not. It can always decide this question if <C>G</C> is tame.
For wild groups this is sometimes not the case. On Info level&nbsp;2 of
<C>InfoRCWA</C> the method gives information on reasons why <C>g</C> is
an element of&nbsp;<C>G</C> or&nbsp;not. <P/>

The direct product of two free groups of rank&nbsp;2 can faithfully be
represented as an rcwa group. According to&nbsp;<Cite Key="Mihailova58"/>
this implies that in general the membership problem for rcwa groups is
algorithmically undecidable.

<Example>
<![CDATA[
gap> G := Group(ClassShift(0,3),ClassTransposition(0,3,2,6));;
gap> ClassShift(2,6)^7*ClassTransposition(0,3,2,6)*ClassShift(0,3)^-3 in G;
true
gap> ClassShift(0,1) in G;
false
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:AttributesAndProperties">
<Heading>Basic attributes and properties of rcwa groups</Heading>

<Index Key="Size" Subkey="for an rcwa group"><C>Size</C></Index>
There is a method available for the operation <C>Size</C>. An rcwa group
is finite if and only if it is tame and its action on a suitably chosen
respected partition (see&nbsp;<Ref Attr="RespectedPartition"
Label="of a tame rcwa group"/>) is faithful.
Hence the problem of computing the order of an rcwa group reduces to
the problem of deciding whether it is tame, the problem of deciding whether
it acts faithfully on a respected partition and the problem of computing the
order of the finite permutation group induced on the respected partition.

<Index Key="rcwa group" Subkey="modulus">rcwa group</Index>
<Index Key="rcwa group" Subkey="multiplier">rcwa group</Index>
<Index Key="rcwa group" Subkey="divisor">rcwa group</Index>
<Index Key="rcwa group" Subkey="prime set">rcwa group</Index>

<Index Key="Modulus" Subkey="of an rcwa group"><C>Modulus</C></Index>
<Index Key="Mod" Subkey="for an rcwa group"><C>Mod</C></Index>
<Index Key="ModulusOfRcwaMonoid" Subkey="for an rcwa group">
  <C>ModulusOfRcwaMonoid</C>
</Index>
<Index Key="Multiplier" Subkey="of an rcwa group"><C>Multiplier</C></Index>
<Index Key="Mult" Subkey="for an rcwa group"><C>Mult</C></Index>
<Index Key="Divisor" Subkey="of an rcwa group"><C>Divisor</C></Index>
<Index Key="Div" Subkey="for an rcwa group"><C>Div</C></Index>
<Index Key="PrimeSet" Subkey="of an rcwa group"><C>PrimeSet</C></Index>

Basic attributes derived from the affine partial mappings of the elements of
an rcwa group and their coefficients are <C>Modulus</C>, <C>Multiplier</C>,
<C>Divisor</C> and <C>PrimeSet</C>.
The <E>modulus</E> of an rcwa group is the lcm of the moduli of its
elements in case such an lcm exists and 0 otherwise.
The <E>multiplier</E> resp. <E>divisor</E> of an rcwa group is the lcm
of the multipliers resp. divisors of its elements in case such an lcm exists
and <M>\infty</M> otherwise.
The <E>prime set</E> of an rcwa group is the union of the prime sets of
its elements.
There are shorthands <C>Mod</C>, <C>Mult</C> and <C>Div</C> defined for
<C>Modulus</C>, <C>Multiplier</C> resp. <C>Divisor</C>. 
Technically, the modulus of an rcwa group is stored as an attribute
<C>ModulusOfRcwaMonoid</C>. <P/>

<Index Key="rcwa group" Subkey="integral">rcwa group</Index>
<Index Key="rcwa group" Subkey="class-wise order-preserving">
  rcwa group
</Index>

<Index Key="IsTame" Subkey="for an rcwa group"><C>IsTame</C></Index>
<Index Key="IsIntegral" Subkey="for an rcwa group"><C>IsIntegral</C></Index>
<Index Key="IsClassWiseOrderPreserving" Subkey="for an rcwa group">
  <C>IsClassWiseOrderPreserving</C>
</Index>

A tame rcwa group, i.e. one with modulus&nbsp;0, has the property
<C>IsTame</C>. An rcwa group is called <E>integral</E> resp.
<E>class-wise order-preserving</E> if all of its elements are so.
There are corresponding methods available for <C>IsIntegral</C>
and <C>IsClassWiseOrderPreserving</C>.

<Example>
<![CDATA[
gap> g1 := RcwaMapping((1,2),[1..2]);;
gap> g2 := RcwaMapping((1,2,3),[1..3]);;
gap> g3 := RcwaMapping((1,2,3,4,5),[1..5]);;
gap> List([g1,g2,g3],Modulus);
[ 2, 3, 5 ]
gap> G := Group(g1,g2,g3);;
gap> Size(G);
265252859812191058636308480000000
gap> List([Modulus,Multiplier,Divisor,PrimeSet,
>          IsIntegral,IsClassWiseOrderPreserving],f->f(G));
[ 30, 1, 1, [ 2, 3, 5 ], true, true ]
]]>
</Example>

</Section>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<!-- #################################################################### -->

<Section Label="sec:PermutationAndMatrixReps">
<Heading>
  Permutation- and matrix representations
</Heading>

<ManSection>
  <Meth Name="IsomorphismPermGroup" Arg="G" Label="for an rcwa group"/>
  <Returns>
    An isomorphism from the finite rcwa group&nbsp;<A>G</A> to
    a finite-degree permutation group.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> IsomorphismPermGroup(Group(ClassTransposition(0,2,1,2),
>                               ClassTransposition(0,3,1,3)));
[ ClassTransposition(0,2,1,2), ClassTransposition(0,3,1,3) ] -> 
[ (1,2)(3,4)(5,6), (1,2)(4,5) ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="IsomorphismMatrixGroup" Arg="G" Label="for an rcwa group"/>
  <Returns>
    An isomorphism from the rcwa group&nbsp;<A>G</A> to a matrix group,
    provided that <A>G</A> embeds into a matrix group and that there is
    a suitable method available. Both conditions are fulfilled if
    <A>G</A> is tame.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> G := Group(ClassTransposition(0,2,1,4),ClassShift(2,4));
<rcwa group over Z with 2 generators>
gap> phi := IsomorphismMatrixGroup(G);;
gap> FieldOfMatrixGroup(Image(phi));
Rationals
gap> DegreeOfMatrixGroup(Image(phi));
10
gap> Display(GeneratorsOfGroup(Image(phi))[1]*One(GF(5)));
 . . . . . . 3 2 . .
 . . . . . . . 1 . .
 . . . . . . . . 3 2
 . . . . . . . . . 1
 . . . . 1 . . . . .
 . . . . . 1 . . . .
 2 1 . . . . . . . .
 . 1 . . . . . . . .
 . . 2 1 . . . . . .
 . . . 1 . . . . . .
gap> Display(GeneratorsOfGroup(Image(phi))[2]*One(GF(5)));
 1 . . . . . . . . .
 . 1 . . . . . . . .
 . . 1 4 . . . . . .
 . . . 1 . . . . . .
 . . . . 1 . . . . .
 . . . . . 1 . . . .
 . . . . . . 1 . . .
 . . . . . . . 1 . .
 . . . . . . . . 1 .
 . . . . . . . . . 1
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ElementFactorization">
<Heading>
  Factoring elements into generators
</Heading>

<ManSection>
  <Meth Name ="PreImagesRepresentative" Arg="phi, g"
        Label="for an epi. from a free group to an rcwa group"/>
  <Returns>
    A representative of the set of preimages of&nbsp;<A>g</A> under
    the epimorphism&nbsp;<A>phi</A> from a free group to an rcwa group.
  </Returns>
  <Description>
    The epimorphism <A>phi</A> must map the generators of the free
    group to the generators of the rcwa group one-by-one. <P/>

    This method can be used for factoring elements of rcwa groups into
    generators. It can also be used for finding nontrivial relations among
    the generators if the respective group is not free and the method returns
    a factorization which is not equal to one which is already known.
    The method is also suitable for wild groups. The implementation
    is based on <Ref Oper="RepresentativeActionPreImage"
                     Label="G, source, destination, action, F"/>.
<Example>
<![CDATA[
gap> a  := RcwaMapping([[2,0,3],[4,-1,3],[4,1,3]]);; # Collatz' permutation.
gap> nu := RcwaMapping([[1,1,1]]);;                  # n -> n + 1.
gap> SetName(nu,"nu"); SetName(a,"a"); # For displaying purposes.
gap> G  := Group(a,nu);
<rcwa group over Z with 2 generators>
gap> phi := EpimorphismFromFreeGroup(G);
[ a, nu ] -> [ a, nu ]
gap> F := Source(phi);
<free group on the generators [ a, nu ]>
gap> w := Comm(F.1^2*F.2^4,F.1*F.2^3);
nu^-4*a^-2*nu^-3*a*nu^4*a*nu^3
gap> g := w^phi;
<bijective rcwa mapping of Z with modulus 8>
gap> pre := PreImagesRepresentative(phi,g);
nu^-4*a^-1*nu^-1*a^-1*nu^3*a*nu^-1*a*nu^3
gap> rel := w/pre; # pre <> w --> We have a nontrivial relation!
nu^-4*a^-2*nu^-3*a*nu^5*a^-1*nu^-3*a*nu*a*nu^4
gap> rel := rel^(F.2^-4*F.1^-1); # Cyclically reduced form.
a^-1*nu^-3*a*nu^5*a^-1*nu^-3*a*nu
gap> rel^phi;
IdentityMapping( Integers )
]]>
</Example>
  </Description>
</ManSection>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<ManSection>
  <Oper Name ="PreImagesRepresentatives" Arg="phi, g"
        Label="for an epi. from a free group to an rcwa group"/>
  <Returns>
    A list of representatives of the set of preimages of&nbsp;<A>g</A> under
    the epimorphism&nbsp;<A>phi</A> from a free group to an rcwa group.
  </Returns>
  <Description>
    The epimorphism <A>phi</A> must map the generators of the free
    group to the generators of the rcwa group one-by-one. <P/>

    Quite frequently, computing several preimages is not harder than
    computing just one, i.e. often several preimages are found
    simultaneously. This operation is called by
    <Ref Meth ="PreImagesRepresentative"
    Label="for an epi. from a free group to an rcwa group"/>,
    which simply chooses one of the shortest representatives.
<Example>
<![CDATA[
gap> w := Comm(F.1*F.2,Comm(F.1,F.2^2)); # We continue the example above.
nu^-1*a^-1*nu^-2*a^-1*nu^2*a^2*nu*a^-1*nu^-2*a*nu^2
gap> g := w^phi;
<bijective rcwa mapping of Z with modulus 16>
gap> pre := PreImagesRepresentatives(phi,g);
[ nu^-1*a^-2*nu^-2*a*nu^2*a*nu^-1*a^-1*nu^2*a,
  nu^-1*a^-1*nu^-2*a^-1*nu^2*a^2*nu^-1*a^-1*nu^2*a ]
gap> rel := pre[1]/pre[2];
nu^-1*a^-2*nu^-2*a*nu^2*a^-1*nu^-2*a*nu^2*a*nu
gap> rel := (rel^(F.2^-1*F.1^-1))^-1; # Cyclically reduced form.
nu^-2*a^-1*nu^2*a*nu^-2*a^-1*nu^2*a
gap> rel^phi;
IdentityMapping( Integers )
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ActionOnR">
<Heading>The action of an rcwa group on the underlying ring</Heading>

<Index Key="Support" Subkey="of an rcwa group"><C>Support</C></Index>
<Index Key="MovedPoints" Subkey="of an rcwa group"><C>MovedPoints</C></Index>

The support, i.e. set of moved points, of an rcwa group can be determined
by <C>Support</C> or <C>MovedPoints</C> (these are synonyms).
Testing for transitivity on the underlying ring is often feasible.
Further it is often possible to determine group elements which map a
given tuple of elements of the underlying ring to a given other tuple,
if such elements exist.

<ManSection>
  <Meth Name="IsTransitive"
        Arg="G, R" Label="for an rcwa group, on its underlying ring"/>
  <Returns>
    <C>true</C> if the rcwa group&nbsp;<A>G</A> acts transitively
    on&nbsp;<A>R</A> and <C>false</C> otherwise.
  </Returns>
  <Description>
    If <A>G</A> is wild, this may fail or run into an infinite loop.
<Example>
<![CDATA[
gap> G := Group(ClassTransposition(1,2,0,4),ClassShift(0,2));;
gap> IsTransitive(G,Integers);
true
]]>
</Example>
  </Description>
</ManSection>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<ManSection>
  <Meth Name="RepresentativeAction" Arg="G, source, destination, action"
        Label="G, source, destination, action"/>
  <Returns>
    An element of <A>G</A> which maps <A>source</A>
    to&nbsp;<A>destination</A> under the action given by&nbsp;<A>action</A>.
  </Returns>
  <Description>
    If an element satisfying this condition does not exist, this method
    either returns <C>fail</C> or runs into an infinite loop.
    The problem whether <A>source</A> and <A>destination</A> lie in
    the same orbit under the action <A>action</A> of&nbsp;<A>G</A> is hard,
    and in its general form most likely computationally undecidable.
    The method is based on <Ref Oper="RepresentativeActionPreImage"
    Label="G, source, destination, action, F"/>, and it computes just
    an image under an epimorphism. This involves multiplications
    of rcwa mappings, and can therefore be quite expensive if the group
    <A>G</A> is wild, the preimage is a rather long word and coefficient
    explosion occurs.
<Example>
<![CDATA[
gap> a := RcwaMapping([[2,0,3],[4,-1,3],[4,1,3]]);; # Collatz' permutation.
gap> G := Group(a,ClassShift(1,4));
<rcwa group over Z with 2 generators>
gap> elm := RepresentativeAction(G,[7,4,9],[4,5,13],OnTuples);
<bijective rcwa mapping of Z with modulus 12>
gap> Display(elm);

Bijective rcwa mapping of Z with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0  2  3  6  8 11                    | n
   1  7 10                             | n - 3
   4                                   | n + 1
   5  9                                | n + 4

gap> List([7,4,9],n->n^elm);
[ 4, 5, 13 ]
gap> elm := RepresentativeAction(G,[5,4,9],[13,5,4],OnTuples);
<bijective rcwa mapping of Z with modulus 9>
gap> Display(elm);

Bijective rcwa mapping of Z with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0                                    | 4n/9
  1                                    | (8n - 26)/9
  2                                    | (8n + 2)/9
  3                                    | (8n + 3)/9
  4                                    | (16n - 19)/9
  5                                    | (16n + 37)/9
  6                                    | (8n + 33)/9
  7                                    | (16n - 49)/9
  8                                    | (16n + 7)/9

gap> RepresentativeAction(G,[7,4,9],[4,5,8],OnTuples);
<bijective rcwa mapping of Z with modulus 256>
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="RepresentativeActionPreImage"
        Arg="G, source, destination, action, F"
        Label="G, source, destination, action, F"/>
  <Returns>
    <C>RepresentativeAction(&nbsp;<A>G</A>, <A>source</A>,
    <A>destination</A>, <A>action</A>&nbsp;)</C> expressed as a word
    in generators, where <A>F</A> is a free group whose rank equals
    the number of stored generators of&nbsp;<A>G</A> and whose generators
    are used as letters in place of the generators of&nbsp;<A>G</A>.
  </Returns>
  <Description>
    Actually <C>RepresentativeAction</C> calls
    <C>RepresentativeActionPreImage</C>, thus the dependency is in the
    opposite direction than suggested above.
    The evaluation of the word sometimes takes much more time than its
    determination. For this reason, <C>RepresentativeActionPreImage</C>
    is often much faster than <C>RepresentativeAction</C>.
    The algorithm is based on computing balls of increasing radius
    around <A>source</A> and <A>destination</A> until they intersect
    nontrivially. It avoids multiplying rcwa mappings.
    The other warnings given in the description of
    <Ref Meth="RepresentativeAction" Label="G, source, destination, action"/>
    certainly apply to this operation as well.
<Example>
<![CDATA[
gap> g := ClassTransposition(0,2,1,2)*ClassShift(0,3);;      SetName(g,"g");
gap> h := ClassTransposition(3,4,4,6)*ClassReflection(0,4);; SetName(h,"h");
gap> G := Group(g,h);;
gap> F := FreeGroup("g","h");; phi := EpimorphismByGenerators(F,G);;
gap> w1 := RepresentativeActionPreImage(G,[1,2,3,4],[2,3,5,7],OnPoints,F);
h^-1*g^3*h^-1*g^-1*h^-2
gap> elm1 := w1^phi;
<bijective rcwa mapping of Z with modulus 864>
gap> List([1,2,3,4],n->n^elm1); # `OnPoints' permits reordering
[ 2, 7, 3, 5 ]
gap> w2 := RepresentativeActionPreImage(G,[1,2,3,4],[2,3,5,7],OnTuples,F);
g*h^-1*g^-1*h^-1*g^-2*h*g^-2*h^2*g^-1*h*g
gap> elm2 := w2^phi;
<bijective rcwa mapping of Z with modulus 432>
gap> List([1,2,3,4],n->n^elm2); # `OnTuples' does not permit reordering
[ 2, 3, 5, 7 ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="RepresentativeAction" Arg="RCWA(R), P1, P2"
        Label="for RCWA(R) and 2 partitions of R into residue classes"/>
  <Returns>
    An element of RCWA(<M>R</M>) which maps the partition&nbsp;<A>P1</A>
    to&nbsp;<A>P2</A>.
  </Returns>
  <Description>
    The arguments <A>P1</A> and <A>P2</A> must be partitions of the
    underlying ring <M>R</M> into the same number of unions of residue
    classes.
    The method for <M>R = \Z</M> recognizes the option <C>IsTame</C>,
    which demands a tame result. If this option is set and there is
    no tame rcwa permutation which maps <A>P1</A> to&nbsp;<A>P2</A>,
    the method runs into an infinite loop. This happens if the condition
    in Theorem&nbsp;2.8.9 in&nbsp;<Cite Key="Kohl05"/> is not satisfied.
    If the option <C>IsTame</C> is not set and the partitions <A>P1</A>
    and <A>P2</A> both consist entirely of single residue classes, then
    the returned mapping is affine on any residue class in&nbsp;<A>P1</A>.
<Example>
<![CDATA[
gap> P1 := List([[0,3],[1,3],[2,9],[5,9],[8,9]],ResidueClass);
[ 0(3), 1(3), 2(9), 5(9), 8(9) ]
gap> P2 := List([[0,2],[1,8],[5,16],[3,4],[13,16]],ResidueClass);
[ 0(2), 1(8), 5(16), 3(4), 13(16) ]
]]>
</Example>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<Example>
<![CDATA[
gap> elm := RepresentativeAction(RCWA(Integers),P1,P2);
<bijective rcwa mapping of Z with modulus 9>
gap> P1^elm = P2;
true
gap> Display(elm);

Bijective rcwa mapping of Z with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0 3 6                                | 2n/3
  1 4 7                                | (8n - 5)/3
  2                                    | (16n + 13)/9
  5                                    | (4n + 7)/9
  8                                    | (16n - 11)/9

gap> elm := RepresentativeAction(RCWA(Integers),P1,P2:IsTame);
<tame bijective rcwa mapping of Z with modulus 1152>
gap> P := RespectedPartition(elm);;
gap> Length(P);
313
gap> elm := RepresentativeAction(RCWA(Integers),
>             [ResidueClass(1,3),Union(ResidueClass(0,3),ResidueClass(2,3))],
>             [Union(ResidueClass(2,5),ResidueClass(4,5)),
>              Union(ResidueClass(0,5),ResidueClass(1,5),ResidueClass(3,5))]);
<bijective rcwa mapping of Z with modulus 6>
gap> [ResidueClass(1,3),Union(ResidueClass(0,3),ResidueClass(2,3))]^elm;
[ 2(5) U 4(5), Z \ 2(5) U 4(5) ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="ShortOrbits" Arg="G, S, maxlng"
        Label="for rcwa group, set of points and bound on length"/>
  <Oper Name="ShortCycles" Arg="g, S, maxlng"
        Label="for rcwa permutation, set of points and bound on length"/>
  <Oper Name="ShortCycles" Arg="g, maxlng"
        Label="for rcwa permutation and bound on length"/>
  <Returns>
    In the first form a list of all finite orbits of the rcwa
    group&nbsp;<A>G</A> of length at most <A>maxlng</A> which intersect
    nontrivially with the set&nbsp;<A>S</A>. <P/>

    In the second form a list of all cycles of the rcwa permutation <A>g</A>
    of length at most&nbsp;<A>maxlng</A> which intersect nontrivially with
    the set&nbsp;<A>S</A>. <P/>

    In the third form a list of all cycles of the rcwa permutation <A>g</A>
    of length at most <A>maxlng</A> which do not correspond to cycles
    consisting of residue classes.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> G := Group(ClassTransposition(1,4,2,4)  * ClassTransposition(1,4,3,4),
>               ClassTransposition(3,9,6,18) * ClassTransposition(1,6,3,9));;
gap> List(ShortOrbits(G,[-15..15],100),orb->StructureDescription(Action(G,orb)));
[ "A15", "A4", "1", "1", "C3", "1", "((C2 x C2 x C2) : C7) : C3", "1", "1", 
  "C3", "A19" ]
]]>
</Example>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<Example>
<![CDATA[
gap> ShortCycles(mKnot(7),[1..100],20);
[ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7, 8 ], [ 9, 10 ], [ 11, 12 ], 
  [ 13, 14, 16, 18, 20, 22, 19, 17, 15 ], [ 21, 24 ], [ 23, 26 ], 
  [ 25, 28, 32, 36, 31, 27, 30, 34, 38, 33, 29 ], [ 35, 40 ], 
  [ 37, 42, 48, 54, 47, 41, 46, 52, 45, 39, 44, 50, 43 ], 
  [ 77, 88, 100, 114, 130, 148, 127, 109, 124, 107, 122, 105, 120, 103, 89 ] ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name ="Projections"
        Arg="G, m" Label="for an rcwa group and a modulus"/>
  <Returns>
    The projections of the rcwa group&nbsp;<A>G</A> to the unions of
    residue classes (mod&nbsp;<A>m</A>) which it fixes setwise.
  </Returns>
  <Description>
    The corresponding partition of a set of representatives for
    the residue classes (mod&nbsp;<A>m</A>) can be obtained by the
    operation <C>OrbitsModulo(<A>G</A>,<A>m</A>)</C>.
    <Index Key="OrbitsModulo" Subkey="for an rcwa group and a modulus">
      <C>OrbitsModulo</C>
    </Index>
<Example>
<![CDATA[
gap> G := Group(ClassTransposition(0,2,1,2),ClassShift(3,4));;
gap> Projections(G,4);
[ [ ClassTransposition(0,2,1,2), ClassShift(3,4) ] ->
    [ <bijective rcwa mapping of Z with modulus 4>,
      IdentityMapping( Integers ) ],
  [ ClassTransposition(0,2,1,2), ClassShift(3,4) ] ->
    [ <bijective rcwa mapping of Z with modulus 4>,
      <bijective rcwa mapping of Z with modulus 4> ] ]
gap> List(last,phi->Support(Image(phi)));
[ 0(4) U 1(4), 2(4) U 3(4) ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name ="Ball" Arg="G, g, r"
        Label="for rcwa group, element and radius"/>
  <Meth Name ="Ball" Arg="G, p, r, action"
        Label="for rcwa group, point, radius and action"/>
  <Returns>
    The ball of radius&nbsp;<A>r</A> around the element&nbsp;<A>g</A> in
    the group&nbsp;<A>G</A>, respectively
    the ball of radius&nbsp;<A>r</A> around the point&nbsp;<A>p</A> under
    the action&nbsp;<A>action</A> of the group&nbsp;<A>G</A>.
  </Returns>
  <Description>
    All balls are understood with respect to
    <C>GeneratorsOfGroup(<A>G</A>)</C>.
    As membership tests can be expensive, the former method does not check
    whether <A>g</A> is indeed an element of&nbsp;<A>G</A>.
    The methods require that element- / point comparisons are cheap.
    They are not only applicable to rcwa groups.
<Example>
<![CDATA[
gap> PSL2Z := Image(IsomorphismRcwaGroup(FreeProduct(CyclicGroup(2),
>                                                    CyclicGroup(3))));
<wild rcwa group over Z with 2 generators>
gap> List([1..10],k->Length(Ball(PSL2Z,[0,1],k,OnTuples)));
[ 4, 8, 14, 22, 34, 50, 74, 106, 154, 218 ]
gap> Ball(Group((1,2),(2,3),(3,4)),(),2);
[ (), (3,4), (2,3), (2,3,4), (2,4,3), (1,2), (1,2)(3,4), (1,2,3), (1,3,2) ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ConjugacyInRCWA_R">
<Heading>Conjugacy in RCWA(R) and CT(R)</Heading>

<ManSection>
  <Meth Name="IsConjugate" Arg="RCWA(R), f, g"
        Label="for rcwa permutations of R in RCWA(R)"/>
  <Meth Name="IsConjugate" Arg="CT(R), f, g"
        Label="for rcwa permutations of R in CT(R)"/>
  <Returns>
    <C>true</C> if the bijective rcwa mappings <A>f</A> and&nbsp;<A>g</A>
    are conjugate in RCWA(<M>R</M>) or CT(<M>R</M>), respectively, and
    <C>false</C> otherwise.
  </Returns>
  <Description>
    The author does not know a general way to solve the conjugacy problem
    for elements of RCWA(<M>R</M>) or CT(<M>R</M>), thus the method may fail
    or run into an infinite loop.
<Example>
<![CDATA[
gap> IsConjugate(RCWA(Integers),ClassTransposition(0,2,1,4),
>                               ClassTransposition(1,2,0,4));
true
gap> IsConjugate(RCWA(Integers),ClassTransposition(0,2,1,4),ClassShift(0,1));
false
]]>
</Example>
  </Description>
</ManSection>

If there is a value of <A>maxlng</A> for which the two lists
<C>List(ShortCycles(<A>f</A>,<A>maxlng</A>),Length)</C> and
<C>List(ShortCycles(<A>g</A>,<A>maxlng</A>),Length)</C> differ, then
<A>f</A> and <A>g</A> are clearly not conjugate
(<M>\rightarrow</M>&nbsp;<Ref Oper="ShortCycles"
Label="for rcwa permutation and bound on length"/>).

<ManSection>
  <Meth Name="RepresentativeAction" Arg="RCWA(R), f, g"
        Label="for RCWA(R) and conjugate elements thereof"/>
  <Meth Name="RepresentativeAction" Arg="CT(R), f, g"
        Label="for CT(R) and conjugate elements thereof"/>
  <Returns>
    An rcwa mapping&nbsp;<C>x</C> such that
    <C><A>f</A>&circum;x = <A>g</A></C>, if such an <C>x</C>
    exists and <C>fail</C> otherwise.
  </Returns>
  <Description>
    This method may fail for the same reasons as
    <Ref Meth="IsConjugate" Label="for rcwa permutations of R in RCWA(R)"/>.
<Example>
<![CDATA[
gap> rep := RepresentativeAction(RCWA(Integers),ClassTransposition(0,2,1,4),
>                                               ClassTransposition(1,2,0,4));
<bijective rcwa mapping of Z with modulus 2>
gap> ClassTransposition(0,2,1,4)^rep = ClassTransposition(1,2,0,4); # check
true
gap> Factorization(rep);
[ ClassTransposition(0,2,1,2) ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Func Name="NrConjugacyClassesOfRCWAZOfOrder" Arg="order" Label="order"/>
  <Returns>
    The number of conjugacy classes of RCWA(<M>\Z</M>) of elements
    of order&nbsp;<A>order</A>, as given in Corollary&nbsp;2.7.1&nbsp;(b)
    in&nbsp;<Cite Key="Kohl05"/>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> List([2,105],NrConjugacyClassesOfRCWAZOfOrder);
[ infinity, 218 ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:RestrictionAndInduction">
<Heading>Restriction and induction</Heading>

There are monomorphisms from the group RCWA(<M>\Z</M>) into itself.
The support of the image of such a monomorphism is the image of a given
injective rcwa mapping. For this reason, these monomorphisms are called
<E>restriction monomorphisms</E>. They play a key role in various methods
to construct rcwa groups of certain types. To mention the simplest example:
Given a set of rcwa groups, their images under restriction monomorphisms
associated to rcwa mappings with pairwise distjoint images generate
a group which is isomorphic to their direct product
(cp. Section&nbsp;<Ref Label="sec:DirectProductsAndWreathProducts"/>).

<ManSection>
  <Oper Name="Restriction"
        Arg="g, f" Label="of an rcwa mapping, by an injective rcwa mapping"/>
  <Oper Name="Restriction"
        Arg="G, f" Label="of an rcwa group, by an injective rcwa mapping"/>
  <Returns>
    The <E>restriction</E> of the rcwa mapping <A>g</A> (respectively the
    rcwa group <A>G</A>) by the injective rcwa mapping&nbsp;<A>f</A>.
  </Returns>
  <Description>
    By definition, the restriction <M>g_f</M> of an rcwa mapping <A>g</A>
    by an injective rcwa mapping&nbsp;<A>f</A> is the unique rcwa mapping
    which satisfies the equation <M>f \cdot g_f = g \cdot f</M> and which
    fixes the complement of the image of <A>f</A> pointwise.
    If <A>f</A> is bijective, the restriction of <A>g</A> by <A>f</A>
    is just the conjugate of <A>g</A> under&nbsp;<A>f</A>. <P/>

    The restriction of an rcwa group&nbsp;<A>G</A> by an injective
    rcwa mapping&nbsp;<A>f</A> is defined as the group whose elements are
    the restrictions of the elements of&nbsp;<A>G</A> by&nbsp;<A>f</A>.
    The restriction of&nbsp;<A>G</A> by&nbsp;<A>f</A> acts on the
    image of&nbsp;<A>f</A> and fixes its complement pointwise.
<Example>
<![CDATA[
gap> F2tilde := Restriction(F2,RcwaMapping([[5,3,1]]));
<wild rcwa group over Z with 2 generators>
gap> Support(F2tilde);
3(5)
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name ="Induction"
        Arg="g, f" Label="of an rcwa mapping, by an injective rcwa mapping"/>
  <Oper Name ="Induction"
        Arg="G, f" Label="of an rcwa group, by an injective rcwa mapping"/>
  <Returns>
    The <E>induction</E> of the rcwa mapping <A>g</A> (respectively the rcwa
    group <A>G</A>) by the injective rcwa mapping&nbsp;<A>f</A>.
  </Returns>
  <Description>
    Induction is the right inverse of restriction, i.e. it is
    <C>Induction(Restriction(<A>g</A>,<A>f</A>),<A>f</A>) = <A>g</A></C> and
    <C>Induction(Restriction(<A>G</A>,<A>f</A>),<A>f</A>) = <A>G</A></C>.
    The mapping&nbsp;<A>g</A> respectively the group&nbsp;<A>G</A> must not
    move points outside the image of&nbsp;<A>f</A>.
<Example>
<![CDATA[
gap> Induction(F2tilde,RcwaMapping([[5,3,1]])) = F2;
true
]]>
</Example>
  </Description>
</ManSection>

</Section>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<!-- #################################################################### -->

<Section Label="sec:Random">
<Heading>Generating pseudo-random elements of RCWA(R) and CT(R)</Heading>

<Index Key="Random" Subkey="RCWA(R)"><C>Random</C></Index>
<Index Key="Random" Subkey="CT(R)"><C>Random</C></Index>
There are methods for the operation <C>Random</C> for RCWA(<M>R</M>)
and CT(<M>R</M>). These methods are designed to be suitable for generating
interesting examples. No particular distribution is guaranteed.

<Log>
<![CDATA[
gap> elm := Random(RCWA(Integers));
<bijective rcwa mapping of Z with modulus 60>
gap> Display(elm);

Bijective rcwa mapping of Z with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0  2  4  6  8 10                    | 3n + 2
   1  5  9                             | -n + 2
   3  7                                | (n - 7)/2
  11                                   | (-n + 20)/3

]]>
</Log>

The elements which are returned by this method are obtained by
multiplying class shifts (see <Ref Func="ClassShift" Label="r, m"/>),
class reflections (see <Ref Func="ClassReflection" Label="r, m"/>) and
class transpositions (see <Ref Func="ClassTransposition"
                          Label="r1, m1, r2, m2"/>).
These factors can be retrieved by factoring:

<Log>
<![CDATA[
gap> Factorization(elm);
[ ClassTransposition(0,2,3,4), ClassTransposition(3,4,4,6),
  ClassShift(0,2)^-1, ClassReflection(3,4), ClassReflection(1,4) ]
]]>
</Log>

There is an auxiliary function <C>ClassPairs([<A>R</A>,] <A>m</A>)</C>,
which is used in this context.
<Index Key="ClassPairs" Subkey="m"><C>ClassPairs</C></Index>
<Index Key="ClassPairs" Subkey="R, m"><C>ClassPairs</C></Index>
In its one-argument form, this function returns a list of 4-tuples
<M>(r_1,m_1,r_2,m_2)</M> of integers corresponding to the unordered
pairs of disjoint residue classes <M>r_1(m_1)</M> and <M>r_2(m_2)</M>
with <M>m_1, m_2 \leq m</M>. In its two-argument form, it does
<Q>the equivalent</Q> for the ring&nbsp;<A>R</A>.

<Example>
<![CDATA[
gap> List(ClassPairs(4),ClassTransposition);
[ ClassTransposition(0,2,1,2), ClassTransposition(0,2,1,4),
  ClassTransposition(0,2,3,4), ClassTransposition(0,3,1,3),
  ClassTransposition(0,3,2,3), ClassTransposition(0,4,1,4),
  ClassTransposition(0,4,2,4), ClassTransposition(0,4,3,4),
  ClassTransposition(1,2,0,4), ClassTransposition(1,2,2,4),
  ClassTransposition(1,3,2,3), ClassTransposition(1,4,2,4),
  ClassTransposition(1,4,3,4), ClassTransposition(2,4,3,4) ]
gap> List(last,TransposedClasses);
[ [ 0(2), 1(2) ], [ 0(2), 1(4) ], [ 0(2), 3(4) ], [ 0(3), 1(3) ],
  [ 0(3), 2(3) ], [ 0(4), 1(4) ], [ 0(4), 2(4) ], [ 0(4), 3(4) ],
  [ 1(2), 0(4) ], [ 1(2), 2(4) ], [ 1(3), 2(3) ], [ 1(4), 2(4) ],
  [ 1(4), 3(4) ], [ 2(4), 3(4) ] ]
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:MethodsForTameGroups">
<Heading>Special attributes for tame rcwa groups</Heading>

There is a couple of attributes which a priori make only sense for tame
rcwa groups. In the sequel, these attributes are described in detail. <P/>

With their help, various structural information about a given tame rcwa
group can be obtained. For example there are methods for <C>IsSolvable</C>
and <C>IsPerfect</C> available for tame rcwa groups, while testing wild
groups for solvability or perfectness is currently not always feasible.
It is often also possible to compute the derived subgroup of a tame
rcwa group. 

<ManSection>
  <Attr Name ="RespectedPartition"
        Arg="G" Label="of a tame rcwa group"/>
  <Attr Name ="RespectedPartition"
        Arg="g" Label="of a tame rcwa permutation"/>
  <Returns>
    A respected partition of the rcwa group <A>G</A> /
    of the rcwa permutation&nbsp;<A>g</A>.
  </Returns>
  <Description>
    A tame element <M>g</M>&nbsp;<M>\in</M>&nbsp;RCWA(<M>R</M>) permutes a
    partition of&nbsp;<M>R</M> into finitely many residue classes on all of
    which it is affine.
    Given a tame group <M>G</M>&nbsp;<M>&lt;</M>&nbsp;RCWA(<M>R</M>),
    there is a common such partition for all elements of&nbsp;<M>G</M>.
    We call the mentioned partitions <E>respected partitions</E>
    of&nbsp;<M>g</M> or&nbsp;<M>G</M>, respectively. <P/>

    An rcwa group or an rcwa permutation has a respected partition
    if and only if it is tame (see&nbsp;<Cite Key="Kohl05"/>,
    Theorem&nbsp;2.5.8). <P/>

    <Index Key="RespectedPartitionShort" Subkey="for a tame rcwa group">
      <C>RespectedPartitionShort</C>
    </Index>
    <Index Key="RespectedPartitionShort" Subkey="for a tame rcwa permutation">
      <C>RespectedPartitionShort</C>
    </Index>
    <Index Key="RespectedPartitionLong" Subkey="for a tame rcwa group">
      <C>RespectedPartitionLong</C>
    </Index>
    <Index Key="RespectedPartitionLong" Subkey="for a tame rcwa permutation">
      <C>RespectedPartitionLong</C>
    </Index>
    Related attributes are <C>RespectedPartitionShort</C> and
    <C>RespectedPartitionLong</C>. The first of these denotes a respected
    partition consisting of residue classes <M>r(m)</M> where <M>m</M>
    divides the modulus of&nbsp;<A>G</A> or&nbsp;<A>g</A>, respectively.
    The second denotes a respected partition consisting of residue classes
    <M>r(m)</M> where the modulus of <A>G</A> (respectively <A>g</A>)
    divides&nbsp;<M>m</M>. <P/>

    <Index Key="RespectsPartition" Subkey="for an rcwa group">
      <C>RespectsPartition</C>
    </Index>
    <Index Key="RespectsPartition" Subkey="for an rcwa permutation">
      <C>RespectsPartition</C>
    </Index>
    There is an operation <C>RespectsPartition(<A>G</A>,<A>P</A>)</C> /
    <C>RespectsPartition(<A>g</A>,<A>P</A>)</C>, which tests whether
    <A>G</A> or&nbsp;<A>g</A> respects a given partition&nbsp;<A>P</A>.
    The permutation induced by <A>g</A> on&nbsp;<C>P</C> can be computed
    efficiently by <C>PermutationOpNC(<A>g</A>,P,OnPoints)</C>.
    <Index Key="PermutationOpNC" Subkey="g, P, OnPoints">
      <C>PermutationOpNC</C>
    </Index>
<Example>
<![CDATA[
gap> G := Group(ClassTransposition(0,4,1,6),ClassShift(0,2));;
<rcwa group over Z with 2 generators>
gap> IsTame(G);
true
gap> Size(G);
infinity
gap> P := RespectedPartition(G);
[ 3(6), 5(6), 0(8), 2(8), 4(8), 6(8), 1(12), 7(12) ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="ActionOnRespectedPartition"
        Arg="G" Label="for a tame rcwa group"/>
  <Returns>
    The action of the tame rcwa group&nbsp;<A>G</A> on
    <C>RespectedPartition(<A>G</A>)</C>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> H := ActionOnRespectedPartition(G);
Group([ (3,7)(5,8), (3,4,5,6) ])
gap> H = Action(G,P);
true
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="KernelOfActionOnRespectedPartition"
        Arg="G" Label="for a tame rcwa group"/>
  <Returns>
    The kernel of the action of the tame rcwa group&nbsp;<A>G</A> on
    <C>RespectedPartition(<A>G</A>)</C>.
  </Returns>
  <Description>
    The method for <C>KernelOfActionOnRespectedPartition</C> uses the
    package <Package>Polycyclic</Package>&nbsp;<Cite Key="Polycyclic"/>.

    The rank of the largest free abelian subgroup of the kernel of the
    action of&nbsp;<A>G</A> on its stored respected partition can be
    computed by <C>RankOfKernelOfActionOnRespectedPartition(<A>G</A>)</C>.
<Example>
<![CDATA[
gap> K := KernelOfActionOnRespectedPartition(G);
<rcwa group over Z with 3 generators>
gap> RankOfKernelOfActionOnRespectedPartition(G);
3
gap> Index(G,K);
48
gap> List(GeneratorsOfGroup(K),Factorization);
[ [ ClassShift(0,4)^2 ], [ ClassShift(2,4)^2 ], [ ClassShift(1,6)^2 ] ]
gap> IsomorphismPcpGroup(K);
[ <bijective rcwa mapping of Z with modulus 4>,
  <bijective rcwa mapping of Z with modulus 4>,
  <bijective rcwa mapping of Z with modulus 6> ] -> [ g6*g10, g8*g12, g14*g16
 ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name ="IntegralConjugate" Arg="G" Label="of a tame rcwa group"/>
  <Attr Name ="IntegralConjugate" Arg="g" Label="of a tame rcwa permutation"/>
  <Returns>
    Some integral conjugate of the tame rcwa group&nbsp;<A>G</A> respectively
    of the tame bijective rcwa mapping&nbsp;<A>g</A> in the group
    RCWA(<M>R</M>).
  </Returns>
  <Description>
    Such conjugates exist, see&nbsp;<Cite Key="Kohl05"/>,
    Theorem&nbsp;2.5.14. In general there are infinitely many of them.
    An rcwa mapping mapping&nbsp;<A>x</A> such that
    <C><A>G</A>&circum;<A>x</A>=IntegralConjugate(<A>G</A>)</C> resp.
    <C><A>g</A>&circum;<A>x</A>=IntegralConjugate(<A>g</A>)</C>
    is stored as an attribute <C>IntegralizingConjugator</C>.
    <Index Key="IntegralizingConjugator" Subkey="of a tame rcwa group">
      <C>IntegralizingConjugator</C>
    </Index>
    <Index Key="IntegralizingConjugator" Subkey="of a tame rcwa permutation">
      <C>IntegralizingConjugator</C>
    </Index>
<Example>
<![CDATA[
gap> IsIntegral(IntegralConjugate(G));
true
gap> G^IntegralizingConjugator(G) = IntegralConjugate(G);
true
gap> RespectedPartition(G);
[ 3(6), 5(6), 0(8), 2(8), 4(8), 6(8), 1(12), 7(12) ]
gap> RespectedPartition(G)^IntegralizingConjugator(G);
[ 0(8), 1(8), 2(8), 3(8), 4(8), 5(8), 6(8), 7(8) ]
gap> last = RespectedPartition(IntegralConjugate(G));
true
]]>
</Example>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<Example>
<![CDATA[
gap> Display(IntegralizingConjugator(G));

Bijective rcwa mapping of Z with modulus 24

               n mod 24                |                 n^f
---------------------------------------+--------------------------------------
   0  8 16                             | n + 2
   1 13                                | (2n + 16)/3
   2 10 18                             | n + 1
   3  9 15 21                          | (4n - 12)/3
   4 12 20                             | n
   5 11 17 23                          | (4n - 17)/3
   6 14 22                             | n - 1
   7 19                                | (2n + 7)/3

]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:DrawingPictures">
<Heading>Drawing pictures of orbits on <M>\Z^2</M> </Heading>

&RCWA; permits drawing pictures of orbits of rcwa groups on&nbsp;<M>\Z^2</M>.
The pictures are written to files in bitmap- (bmp-) format.
The author has successfully tested this feature both under Linux and under
Windows, and the produced pictures can be processed further with many common
graphics programs.

<ManSection>
  <Func Name="DrawOrbitPicture"
        Arg="G, p0, r, h, w, colored, palette, filename"
        Label="G, p0, r, h, w, colored, palette, filename"/>
  <Returns> Nothing. </Returns>
  <Description>
    Draws a picture of the orbit(s) of the point(s) <A>p0</A> under the
    action of the group <A>G</A> on&nbsp;<M>\Z^2</M>.
    The argument <A>p0</A> is either one point or a list of points.
    The argument <A>r</A> denotes the radius of the ball around <A>p0</A>
    to be computed. The size of the created picture is
    <A>h</A>&nbsp;x&nbsp;<A>w</A> pixels.
    The argument <A>colored</A> is a boolean which indicates whether a 24-bit
    True-Color picture or a monochrome picture should be drawn.
    In the former case, <A>palette</A> must be a list of triples of integers
    in the range <M>0, \dots, 255</M>, denoting the RGB values of colors to
    be used. In the latter case, <A>palette</A> is not used, and any value
    can be passed. The picture is written in bitmap- (bmp-) format to a file
    named <A>filename</A>.
<Log>
<![CDATA[
gap> PSL2Z := Image(IsomorphismRcwaGroup(FreeProduct(CyclicGroup(2),
>                                                    CyclicGroup(3))));;
gap> DrawOrbitPicture(PSL2Z,[0,1],20,512,512,false,fail,"~/images/example1.bmp");
gap> DrawOrbitPicture(PSL2Z,Combinations([1..4],2),20,512,512,true,
>                     [[255,0,0],[0,255,0],[0,0,255]],"~/images/example2.bmp");
gap> G := Group(ClassShift(0,1),ClassTransposition(1,2,0,4));;
gap> DrawOrbitPicture(G,[0,1],20,512,512,true,
>                     List([1..20],i->[255-12*i,255-12*i,255]),
>                     "~/images/example3.bmp");
]]>
</Log>
  </Description>
</ManSection>

<Ref Func="DrawOrbitPicture"
     Label="G, p0, r, h, w, colored, palette, filename"/>
makes use of the following utility function:

<ManSection>
  <Func Name="SaveAsBitmapPicture"
        Arg="picture, filename" Label="picture, filename"/>
  <Returns> Nothing. </Returns>
  <Description>
    Writes the pixel matrix <A>picture</A> to a bitmap- (bmp-)
    picture file named <A>filename</A>. The filename should include
    the entire pathname.

    The argument <A>picture</A> can be a GF(2) matrix, in which case a
    monochrome picture file is generated. In this case, zeros stand for
    black pixels and ones stand for white pixels.

    The argument <A>picture</A> can also be an integer matrix, in which case
    a 24-bit True Color picture file is generated. In this case, the entries
    of the matrix are supposed to be integers <M>n = 65536 \cdot red + 256
    \cdot green + blue</M> in the range <M>0, \dots, 2^{24}-1</M> specifying
    the RGB values of the colors of the pixels. <P/>
<Index Key="ReadFromBitmapPicture" Subkey="filename">
  <C>ReadFromBitmapPicture</C>
</Index>
    The picture can be read back into &GAP; by the function
    <C>ReadFromBitmapPicture(<A>filename</A>)</C>.
<Log>
<![CDATA[
gap> color   := n->32*(n mod 8)+256*32*(Int(n/8) mod 8)+65536*32*Int(n/64);;
gap> picture := List([1..512],y->List([1..512],x->color(Gcd(x,y)-1)));;
gap> SaveAsBitmapPicture(picture,"~/images/gcd.bmp");
]]>
</Log>
  </Description>
</ManSection>

The pictures created in the examples are shown on &RCWA;'s webpage.

</Section>

<!-- #################################################################### -->

<Section Label="sec:UtilityFunctions">
<Heading>Some general utility functions</Heading>

<Index Key="GeneratorsAndInverses" Subkey="for a group">
  <C>GeneratorsAndInverses</C>
</Index>
<Index Key="EpimorphismByGenerators" Subkey="for two groups">
  <C>EpimorphismByGenerators</C>
</Index>
<Index Key="ListOfPowers"><C>ListOfPowers</C></Index>
<Index Key="AllProducts"><C>AllProducts</C></Index>

&RCWA; introduces a few small utility functions which can be used for
groups in general: The function <C>GeneratorsAndInverses(<A>G</A>)</C>
returns a list of generators of <A>G</A> and their inverses,
<C>EpimorphismByGenerators(<A>G</A>,<A>H</A>)</C> is
a shorthand for <C>GroupHomomorphismByImages(<A>G</A>,<A>H</A>,
GeneratorsOfGroup(<A>G</A>),GeneratorsOfGroup(<A>H</A>))</C>
(there is also an <C>NC</C> version of this), the function
<C>ListOfPowers(<A>g</A>,<A>exp</A>)</C> returns the list
<C>[<A>g</A>,<A>g</A>&circum;2,...,<A>g</A>&circum;<A>exp</A>]</C>
of powers of&nbsp;<A>g</A>, and the function
<C>AllProducts(<A>l</A>,<A>k</A>)</C> returns the list of
all products of <A>k</A> entries of the list&nbsp;<A>l</A>.

</Section>

<!-- #################################################################### -->

<Section Label="sec:CategoriesOfRcwaGroups">
<Heading>The categories of rcwa groups</Heading>

<ManSection>
  <Filt Name="IsRcwaGroup" Arg="G"/>
  <Filt Name="IsRcwaGroupOverZ" Arg="G"/>
  <Filt Name="IsRcwaGroupOverZ_pi" Arg="G"/>
  <Filt Name="IsRcwaGroupOverGFqx" Arg="G"/>
  <Returns>
    <C>true</C> if <A>G</A> is an rcwa group,
    an rcwa group over the ring of integers,
    an rcwa group over a semilocalization of the ring of integers or
    an rcwa group over a polynomial ring in one variable over a finite field,
    respectively, and <C>false</C> otherwise.
  </Returns>
  <Description>

    <Index Key="IsRcwaGroupOverZOrZ_pi">
      <C>IsRcwaGroupOverZOrZ&uscore;pi</C>
    </Index>

    Often the same methods can be used for rcwa groups over the ring of
    integers and over its semilocalizations. For this reason there is
    a category <C>IsRcwaGroupOverZOrZ&uscore;pi</C> which is the union of
    <C>IsRcwaGroupOverZ</C> and <C>IsRcwaGroupOverZ&uscore;pi</C>. <P/>

    <Index Key="IsNaturalRCWA"><C>IsNaturalRCWA</C></Index>
    <Index Key="IsNaturalCT"><C>IsNaturalCT</C></Index>

    To allow distinguishing the groups RCWA(<M>R</M>) and CT(<M>R</M>) from
    others, they have the characteristic property <C>IsNaturalRCWA</C> or
    <C>IsNaturalCT</C>, respectively.

  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->

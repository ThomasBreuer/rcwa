<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  rcwagrp.xml         RCWA documentation           Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$      ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:RcwaGroups">
<Heading>Residue Class-Wise Affine Groups</Heading>

This chapter describes the functionality provided by this package for
computing with residue class-wise affine groups.

<!-- #################################################################### -->

<Section Label="sec:ContructingRcwaGroups">
<Heading>Constructing residue class-wise affine groups</Heading>

Residue class-wise affine groups can be constructed using either
<C>Group</C>, <C>GroupByGenerators</C> or <C>GroupWithGenerators</C>,
as usual (see the reference manual). Note that currently except of the
groups RCWA(<M>R</M>) only finitely generated rcwa groups are supported.

<Example>
<![CDATA[
gap> g := RcwaMapping([[1,0,1],[1,1,1],[3,6,1],
>                      [1,0,3],[1,1,1],[3,6,1],
>                      [1,0,1],[1,1,1],[3,-21,1]]);;
gap> h := RcwaMapping([[1,0,1],[1,1,1],[3,6,1],
>                      [1,0,3],[1,1,1],[3,-21,1],
>                      [1,0,1],[1,1,1],[3,6,1]]);;
gap> List([g,h],Order);
[ 9, 9 ]
gap> G := Group(g,h);
<rcwa group over Z with 2 generators>
gap> Size(G);
infinity
]]>
</Example>

For rcwa groups, there are methods available for the operations
<C>Display</C> and <C>Print</C>. <P/>

All rcwa groups over the ring <M>R</M> are subgroups of RCWA(<M>R</M>).
The group RCWA(<M>R</M>) is not finitely generated, thus cannot be
constructed as described above. It is handled as a special case:

<ManSection>
  <Func Name="RCWA" Arg="R" Label="R"/>
  <Returns>
    The group RCWA(<A>R</A>) of all bijective rcwa mappings
    of the ring&nbsp;<A>R</A>.
  </Returns>
  <Description>
<Alt Only="LaTeX">\pagebreak[4]</Alt>
<Example>
<![CDATA[
gap> RCWA_Z := RCWA(Integers);
RCWA(Z)
gap> Size(RCWA_Z);
infinity
gap> IsFinitelyGeneratedGroup(RCWA_Z);
false
gap> One(RCWA_Z);
IdentityMapping( Integers )
gap> IsSolvable(RCWA_Z);
false
gap> IsPerfect(RCWA_Z);
false
gap> Centre(RCWA_Z);
Trivial rcwa group over Z
gap> IsSubgroup(RCWA_Z, Group(RcwaMapping((1,2,3),[1..4]),
>                             RcwaMapping(2,[[0,1],[1,0],[2,3],[3,2]])));
true
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="Random" Arg="RCWA_Z" Label="RCWA( Integers )"/>
  <Returns>
    A pseudo-random element of the group RCWA(<M>\mathbb{Z}</M>).
  </Returns>
  <Description>
    This method is designed to be suitable for generating interesting
    examples. No particular distribution is guaranteed -- in fact, the
    author has no idea what a <Q>reasonable</Q> random distribution
    on RCWA(<M>\mathbb{Z}</M>) should be.
<Log>
<![CDATA[
gap> elm := Random(RCWA_Z);
<bijective rcwa mapping of Z with modulus 60>
gap> Display(elm);

Bijective rcwa mapping of Z with modulus 60

               n mod 60                |                 n^f
---------------------------------------+--------------------------------------
   0  4  6  8 10 14 16 18 20 24 26 28  | 
  30 34 36 38 40 44 46 48 50 54 56 58  | -3n - 5
   1                                   | (n - 1)/5
   2 22 42                             | (3n + 24)/5
   3  9 15 21 27 33 39 45 51 57        | (-5n + 12)/3
   5 11 17 29 35 41 47 59              | -n + 2
   7 13 19 25 37 43 49 55              | -n
  12 32 52                             | (3n + 4)/5
  23                                   | (n - 3)/5
  31                                   | (n + 19)/5
  53                                   | (n + 17)/5

]]>
</Log>

    The elements returned by this method are obtained by multiplying
    class shifts (see <Ref Func="ClassShift" Label="r, m"/>),
    class reflections (see <Ref Func="ClassReflection" Label="r, m"/>) and
    class transpositions (see <Ref Func="ClassTransposition"
                              Label="r1, m1, r2, m2"/>).
    These factors are stored as an attribute value:

<Log>
<![CDATA[
gap> Perform(FactorizationIntoGenerators(elm),Display);

Rcwa mapping of Z with modulus 6

                n mod 6                |                 n^f
---------------------------------------+--------------------------------------
  0 2 4                                | 3n + 5
  1 3                                  | n
  5                                    | (n - 5)/3


Rcwa mapping of Z with modulus 6

                n mod 6                |                 n^f
---------------------------------------+--------------------------------------
  0 2 4                                | 3n + 3
  1 5                                  | n
  3                                    | (n - 3)/3


Rcwa mapping of Z with modulus 10

               n mod 10                |                 n^f
---------------------------------------+--------------------------------------
   0  2  4  6  8                       | 5n + 1
   1                                   | (n - 1)/5
   3  5  7  9                          | n


Rcwa mapping of Z with modulus 4

                n mod 4                |                 n^f
---------------------------------------+--------------------------------------
  0 1 3                                | n
  2                                    | n + 4

Rcwa mapping of Z: n -> -n

Rcwa mapping of Z with modulus 2

                n mod 2                |                 n^f
---------------------------------------+--------------------------------------
  0                                    | -n
  1                                    | n

]]>
</Log>
  </Description>
</ManSection>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

Another possible way to get an rcwa group is by taking the image of an
rcwa representation, or by <Q>translating</Q> a permutation group:

<ManSection>
  <Attr Name="IsomorphismRcwaGroup" Arg="G" Label="G"/>
  <Func Name="RcwaGroupByPermGroup" Arg="G" Label="G"/>
  <Returns>
    A monomorphism from the finite group <A>G</A> to&nbsp;RCWA(<M>\Z</M>),
    resp. an rcwa group over <M>\mathbb{Z}</M>, which is isomorphic to the
    (finite) permutation group&nbsp;<A>G</A>, and acts on the range
    <C>[1..LargestMovedPoint(</C><A>G</A><C>)]</C> as <A>G</A> does.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> G := GL(2,5);;
gap> IsomorphismRcwaGroup(G);
CompositionMapping( 
[ (2,3,5,8)(4,7,12,18)(6,10,17,22)(9,15,21,24)(13,14,19,23), 
  (1,2,4)(3,6,11)(5,9,16)(7,13,12)(8,14,20)(10,18,17)(15,22,21)(19,24,23) 
 ] -> [ <rcwa mapping of Z with modulus 24>, <rcwa mapping of Z with modulus 
    24> ], <action isomorphism> )
gap> H := RcwaGroupByPermGroup(Group((1,2),(3,4),(5,6),(7,8),
>                                    (1,3)(2,4),(1,3,5,7)(2,4,6,8)));
<rcwa group over Z with 6 generators>
gap> Size(H);; List(DerivedSeries(H),Size);
[ 384, 96, 32, 2, 1 ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:AttributesAndProperties">
<Heading>Attributes and properties of rcwa groups</Heading>

<ManSection>
  <Meth Name="Modulus" Arg="G" Label="G"/>
  <Meth Name="Mod"     Arg="G" Label="G"/>
  <Returns> The modulus of the rcwa group&nbsp;<A>G</A>. </Returns>
  <Description>
    The <E>Modulus</E> of an rcwa group is the lcm of the moduli of its
    elements in case such an lcm exists and 0 otherwise. <P/>

    See also <Ref Prop="IsTame" Label="G"/>.
<Example>
<![CDATA[
gap> Modulus(Group(g,h));
27
gap> g1 := RcwaMapping((1,2),[1..2]);
<rcwa mapping of Z with modulus 2>
gap> g2 := RcwaMapping((1,2,3),[1..3]);
<rcwa mapping of Z with modulus 3>
gap> g3 := RcwaMapping((1,2,3,4,5),[1..5]);
<rcwa mapping of Z with modulus 5>
]]>
</Example>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<Example>
<![CDATA[
gap> G := Group(g1,g2,g3);
<rcwa group over Z with 3 generators>
gap> Modulus(G);
30
gap> a := RcwaMapping([[3,0,2],[3,1,4],[3,0,2],[3,-1,4]]);; SetName(a,"a");
gap> b := ClassShift(1,4)*a;; SetName(b,"b");
gap> c := ClassShift(3,4)*a;; SetName(c,"c");
gap> Modulus(Group(a,b));
0
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Prop Name="IsTame" Arg="G" Label="G"/>
  <Returns>
    <C>true</C> if the rcwa group&nbsp;<A>G</A> is tame and <C>false</C>
    otherwise.
  </Returns>
  <Description>
    An rcwa group is called <E>tame</E> if its modulus is not equal
    to&nbsp;0.
<Example>
<![CDATA[
gap> IsTame(G);
true
gap> IsTame(Group(a,b));
false
gap> IsTame(Group(Comm(a,b),Comm(a,c)));
true
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="PrimeSet" Arg="G" Label="G"/>
  <Returns> The prime set of the rcwa group&nbsp;<A>G</A>. </Returns>
  <Description>
    The <E>prime set</E> of an rcwa group is the union of the prime
    sets of its elements. See also&nbsp;<Ref Oper="PrimeSet" Label="f"/>
    for rcwa mappings.
<Example>
<![CDATA[
gap> [ PrimeSet(G), PrimeSet(H) ];
[ [ 2, 3, 5 ], [ 2 ] ]
]]>
</Example>
  </Description>
</ManSection>

An rcwa group is called integral resp. class-wise order-preserving
if all of its elements are so. There are corresponding methods available
for <C>IsIntegral</C> and <C>IsClassWiseOrderPreserving</C>.

</Section>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<!-- #################################################################### -->

<Section Label="sec:MembershipOrderMatPerm">
<Heading>
  Membership testing, order computation,
  permutation- / matrix representations
</Heading>

<Index Key="rcwa group" Subkey="element testing"></Index>
<ManSection>
  <Meth Name="\in" Arg="g, G" Label="g, G"/>
  <Returns>
    <C>true</C> if the rcwa mapping&nbsp;<A>g</A> is an element of the
    rcwa group&nbsp;<A>G</A> and <C>false</C> if not.
  </Returns>
  <Description>
    Tries to figure out whether <A>g</A> is an element of <A>G</A> or not.
    This will be successful if <A>G</A> is tame and class-wise
    order-preserving. For wild groups only a number of easy cases are
    covered. On <C>InfoLevel(InfoRCWA) = 3</C> the method will give
    information about reasons why <A>g</A> is an element of <A>G</A> or not.
<Example>
<![CDATA[
gap> u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;
gap> u in H;
false
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="Size" Arg="G" Label="G"/>
  <Returns> The order of the rcwa group&nbsp;<A>G</A>. </Returns>
  <Description>
<Example>
<![CDATA[
gap> Size(G);
265252859812191058636308480000000
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="IsomorphismPermGroup" Arg="G" Label="G"/>
  <Returns>
    An isomorphism from the finite rcwa group&nbsp;<A>G</A> to some
    permutation group.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> H := Group(g1,g2);
<rcwa group over Z with 2 generators>
gap> phi := IsomorphismPermGroup(H);
[ <bijective rcwa mapping of Z with modulus 2, of order 2>, 
  <bijective rcwa mapping of Z with modulus 3, of order 3> ] -> 
[ (1,2)(3,4)(5,6), (1,2,3)(4,5,6) ]
]]>
</Example>
  </Description>
</ManSection>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<ManSection>
  <Attr Name="IsomorphismMatrixGroup" Arg="G" Label="G"/>
  <Returns>
    An isomorphism from the rcwa group&nbsp;<A>G</A> to some matrix group.
  </Returns>
  <Description>
    Currently, there is only a method installed which works for
    tame rcwa groups.
<Example>
<![CDATA[
gap> g := RcwaMapping([[2,2,1],[1, 4,1],[1,0,2],[2,2,1],[1,-4,1],[1,-2,1]]);;
gap> h := RcwaMapping([[2,2,1],[1,-2,1],[1,0,2],[2,2,1],[1,-1,1],[1, 1,1]]);;
gap> SetName(g,"g"); SetName(h,"h");
gap> G := Group(g,h);
<rcwa group over Z with 2 generators>
gap> phi := IsomorphismMatrixGroup(G);;
gap> FieldOfMatrixGroup(Image(phi));
Rationals
gap> DegreeOfMatrixGroup(Image(phi));
28
gap> List(GeneratorsOfGroup(Image(phi)),Order);
[ 7, 12 ]
gap> Display(GeneratorsOfGroup(Image(phi))[1]*One(GF(5)));
 . . . . . . 1 1 . . . . . . . . . . . . . . . . . . . .
 . . . . . . . 1 . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . 3 . . . . . . .
 . . . . . . . . . . . . . . . . . . . . . 1 . . . . . .
 . . . . . . . . 1 3 . . . . . . . . . . . . . . . . . .
 . . . . . . . . . 1 . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . . . 3 . . . . .
 . . . . . . . . . . . . . . . . . . . . . . . 1 . . . .
 . . 1 4 . . . . . . . . . . . . . . . . . . . . . . . .
 . . . 1 . . . . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . 1 1 . . . . . . . . . .
 . . . . . . . . . . . . . . . . . 1 . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . . . . . 3 . . .
 . . . . . . . . . . . . . . . . . . . . . . . . . 1 . .
 . . . . . . . . . . . . . . . . . . 1 3 . . . . . . . .
 . . . . . . . . . . . . . . . . . . . 1 . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . . . . . . . 3 .
 . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
 . . . . . . . . . . . . 1 4 . . . . . . . . . . . . . .
 . . . . . . . . . . . . . 1 . . . . . . . . . . . . . .
 2 2 . . . . . . . . . . . . . . . . . . . . . . . . . .
 . 1 . . . . . . . . . . . . . . . . . . . . . . . . . .
 . . . . 2 2 . . . . . . . . . . . . . . . . . . . . . .
 . . . . . 1 . . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . 2 2 . . . . . . . . . . . . . . . .
 . . . . . . . . . . . 1 . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . 2 2 . . . . . . . . . . . .
 . . . . . . . . . . . . . . . 1 . . . . . . . . . . . .
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ElementFactorization">
<Heading>
  Factoring elements into generators
</Heading>

<ManSection>
  <Meth Name ="PreImagesRepresentative" Arg="phi, g" Label="phi, g"/>
  <Returns>
    A representative of the set of preimages of&nbsp;<A>g</A> under
    the homomorphism&nbsp;<A>phi</A> from a free group to an rcwa group
    over&nbsp;<M>\mathbb{Z}</M>.
  </Returns>
  <Description>
    This method can be used for factoring elements of rcwa groups
    over <M>\mathbb{Z}</M> into generators, and for finding non-trivial
    relations among the generators if the respective group is not free
    and the method returns a factorization which does not happen to be
    equal to one which is known a priori.
    The homomorphism <A>phi</A> must map the generators of the free
    group to the generators of the rcwa group one-by-one.
    This method is also suitable for wild groups. The implementation
    is based on <Ref Oper="RepresentativeActionPreImage"
                     Label="G, src, dest, act, F"/>.
<Example>
<![CDATA[
gap> G := Group(g,h);
<rcwa group over Z with 2 generators>
gap> phi := EpimorphismFromFreeGroup(G);
[ g, h ] -> [ g, h ]
gap> PreImagesRepresentative(phi,h*g^3*h^2*g^-1*h*g*h^-3);
h*g^3*h^2*g^-1*h*g*h^-3
gap> nu := RcwaMapping([[1,1,1]]);
Rcwa mapping of Z: n -> n + 1
gap> SetName(nu,"nu");
gap> G := Group(a,nu);
<rcwa group over Z with 2 generators>
gap> IsTame(G);
false
gap> phi := EpimorphismFromFreeGroup(G);
[ a, nu ] -> [ a, nu ]
gap> F := Source(phi);
<free group on the generators [ a, nu ]>
gap> w := Comm(F.1,Comm(F.1,F.2^2));
a^-1*nu^-2*a^-1*nu^2*a*nu^-2*a*nu^2
gap> f := w^phi;
<bijective rcwa mapping of Z with modulus 18>
gap> IsTame(f);
false
gap> pre := PreImagesRepresentative(phi,f);
a^-2*nu^-2*a^2*nu^2
gap> one := w*pre^-1; # pre <> w --> We have a non-trivial relation!
a^-1*nu^-2*a^-1*nu^2*a*nu^-2*a^-1*nu^2*a^2
gap> one^phi;
IdentityMapping( Integers )
]]>
</Example>
  </Description>
</ManSection>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<ManSection>
  <Oper Name ="PreImagesRepresentatives" Arg="phi, g" Label="phi, g"/>
  <Returns>
    A list of representatives of the set of preimages of&nbsp;<A>g</A>
    under the homomorphism&nbsp;<A>phi</A> from a free group to an rcwa
    group over&nbsp;<M>\mathbb{Z}</M>.
  </Returns>
  <Description>
    Quite frequently, computing several preimages is not harder than
    computing just one, i.e. often several preimages are found
    simultaneously. This operation is called by
    <Ref Meth ="PreImagesRepresentative" Label="phi, g"/>,
    which simply chooses the shortest representative -- for a slightly
    more concise description see there.
<Example>
<![CDATA[
gap> G := Group(g,h);
<rcwa group over Z with 2 generators>
gap> phi := EpimorphismFromFreeGroup(G);
[ g, h ] -> [ g, h ]
gap> f := g^3*h*g^-4*h^5*g;
<bijective rcwa mapping of Z with modulus 12>
gap> RCWAInfo(2);
gap> pre := PreImagesRepresentatives(phi,f);
#I  Orbit lengths after extension step 1: [ 4, 5 ]
#I  |Candidates| = 1
#I  Orbit lengths after extension step 1: [ 5, 5 ]
#I  Orbit lengths after extension step 2: [ 17, 15 ]
#I  Orbit lengths after extension step 3: [ 52, 39 ]
#I  |Candidates| = 1
#I  Orbit lengths after extension step 1: [ 5, 5 ]
#I  Orbit lengths after extension step 2: [ 17, 15 ]
#I  Orbit lengths after extension step 3: [ 53, 43 ]
#I  Orbit lengths after extension step 4: [ 158, 119 ]
#I  |Candidates| = 1
#I  Orbit lengths after extension step 1: [ 5, 5 ]
#I  Orbit lengths after extension step 2: [ 17, 17 ]
#I  Orbit lengths after extension step 3: [ 53, 53 ]
#I  Orbit lengths after extension step 4: [ 159, 158 ]
#I  Orbit lengths after extension step 5: [ 472, 462 ]
#I  Orbit lengths after extension step 6: [ 1356, 1309 ]
#I  Orbit lengths after extension step 7: [ 3822, 3643 ]
#I  |Candidates| = 11
[ g^3*h*g^3*h^5*g, g^-3*h^-4*g^-3*h^-1*g*h*g, g^3*h*g^-4*h^5*g ]
gap> RCWAInfo(0);
gap> List(pre,Length);
[ 13, 14, 14 ]
gap> Set(List(pre,w->w^phi)) = [f];
true
gap> w := pre[1]*pre[2]^-1;
g^3*h*g^3*h^4*g^-1*h*g^3*h^4*g^3
gap> Length(w);
23
gap> w^phi; # A relation of length 23.
IdentityMapping( Integers )
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ActionOnR">
<Heading>The action of an rcwa group on the underlying ring R</Heading>

The support (set of moved points) of an rcwa group can be determined by
<C>MovedPoints</C>. <P/>

In some cases -- in particular in the case that the group in question is
tame -- testing for transitivity on the underlying ring is feasible.
Furthermore it is often possible to determine group elements which map a
given tuple of elements of the underlying ring to a given other tuple,
if such elements exist.

<ManSection>
  <Meth Name="IsTransitive" Arg="G, Integers" Label="G, Integers"/>
  <Returns>
    <C>true</C> if the rcwa group&nbsp;<A>G</A> acts transitive
    on&nbsp;<M>\Z</M> and <C>false</C> otherwise.
  </Returns>
  <Description>
    Depending on the particular group this might fail or run into an
    infinite loop, but for tame groups things should work.
<Log>
<![CDATA[
gap> G := Group(g,h);;
gap> RCWAInfo(3);
gap> IsTransitive(G,Integers);
#I  IsTransitive: testing for finiteness and searching short orbits ...
#I  IsTame: balancedness criterion.
#I  IsTame:`dead end' criterion.
#I  IsTame: loop criterion.
#I  IsTame:`finite order or integral power' criterion.

  [ ... ]

#I  Order: the 4th power of the argument is RcwaMapping(
[ [ 1, 12, 1 ], [ 1, 12, 1 ], [ 1, -6, 2 ], [ 2, -10, 1 ], [ 1, -7, 1 ],
  [ 2, -8, 1 ], [ 1, 12, 1 ], [ 1, 12, 1 ], [ 1, -10, 2 ], [ 2, -10, 1 ],
  [ 1, -7, 1 ], [ 2, -8, 1 ] ] );
There is a `class shift' on the residue class 0(12).
#I  Trying probabilistic random walk, initial m = 12
#I  checking modulus ...
#I  Size: use action on respected partition.
#I  KernelOfActionOnRespectedPartition: gen. #1, lng = 1
#I  KernelOfActionOnRespectedPartition: gen. #2, lng = 2

                       [ ... ]

#I  KernelOfActionOnRespectedPartition: gen. #14, lng = 10
#I  Searching for class shifts ...
#I  ... in generators
#I  ... in commutators of the generators
#I  The cyclic group generated by RcwaMapping(
[ [ 1, -9, 1 ], [ 1, 0, 1 ], [ 1, 6, 1 ], [ 1, -3, 1 ], [ 1, 0, 1 ],
  [ 1, 6, 1 ] ] ) acts transitively on the residue class 2(6).
#I  OrbitUnion: initial set = ResidueClassUnion( Integers, 6, [ 2 ] )
#I  Image = Integers
true
gap> RCWAInfo(0);
]]>
</Log>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="RepresentativeAction"
        Arg="G, src, dest, act" Label="G, src, dest, act"/>
  <Returns>
    An element of <A>G</A> which maps <A>src</A> to&nbsp;<A>dest</A>
    under the action given by&nbsp;<A>act</A>.
  </Returns>
  <Description>
    If an element satisfying this condition does not exist, this method
    either returns <C>fail</C> or runs into an infinite loop.
    The problem of whether <A>src</A> and <A>dest</A> lie in the same
    orbit under the action of <A>G</A> in general seems to be hard.
    The given method is based on <Ref Oper="RepresentativeActionPreImage"
    Label="G, src, dest, act, F"/>, and it basically just computes an image
    under an homomorphism. As this involves multiplications of rcwa mappings,
    this can be quite expensive if the group <A>G</A> is wild, the preimage
    is a rather long word and coefficient explosion happens to occur.
<Example>
<![CDATA[
gap> G := Group(a,b);
<rcwa group over Z with 2 generators>
gap> elm := RepresentativeAction(G,[7,4,9],[4,5,13],OnTuples);
<bijective rcwa mapping of Z with modulus 12>
gap> Display(elm);

Bijective rcwa mapping of Z with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0  2  3  6  8 11                    | n
   1  7 10                             | n - 3
   4                                   | n + 1
   5  9                                | n + 4

gap> List([7,4,9],n->n^elm);
[ 4, 5, 13 ]
gap> elm := RepresentativeAction(G,[5,4,9],[13,5,4],OnTuples);
<bijective rcwa mapping of Z with modulus 9>
gap> Display(elm);

Bijective rcwa mapping of Z with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0                                    | 4n/9
  1                                    | (8n - 26)/9
  2                                    | (8n + 2)/9
  3                                    | (8n + 3)/9
  4                                    | (16n - 19)/9
  5                                    | (16n + 37)/9
  6                                    | (8n + 33)/9
  7                                    | (16n - 49)/9
  8                                    | (16n + 7)/9

gap> List([5,4,9],n->n^elm);
[ 13, 5, 4 ]
gap> RepresentativeAction(G,[7,4,9],[4,5,8],OnTuples);
<bijective rcwa mapping of Z with modulus 256>
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="RepresentativeActionPreImage"
        Arg="G, src, dest, act, F" Label="G, src, dest, act, F"/>
  <Returns>
    The result of <C>RepresentativeAction( <A>G</A>, <A>src</A>,
    <A>dest</A>, <A>act</A> )</C> as a word in the generators.
  </Returns>
  <Description>
    The argument <A>F</A> is a free group to be used to express the
    resulting word. Note that the dependency is just the other way round
    than suggested above (<C>RepresentativeAction</C> calls
    <C>RepresentativeActionPreImage</C>) and that the evaluation of the
    word sometimes takes much more time than its determination (the latter
    however depends very much on the particular case and is hard to
    predict). This causes <C>RepresentativeActionPreImage</C> sometimes to
    be much faster than <C>RepresentativeAction</C>.
    The employed algorithm is not inefficient, as the last two of the
    examples below suggest -- it is based on separate progressive
    computations of the orbits of <A>src</A> and <A>dest</A> until they
    intersect non-trivially. It avoids multiplying rcwa mappings.
    Of course the other warnings given in the description of
    <Ref Meth="RepresentativeAction" Label="G, src, dest, act"/>
    apply to this operation, too.
<Example>
<![CDATA[
gap> F := FreeGroup("a","b");;
gap> w := RepresentativeActionPreImage(G,[7,4,9],[4,5,13],OnPoints,F);
b^-1*a*b*a^-1
gap> w := RepresentativeActionPreImage(G,[5,4,9],[13,5,4],OnTuples,F);
b^-1*a^-1*b*a^-1
gap> w := RepresentativeActionPreImage(G,[7,4,9],[4,5,8],OnPoints,F);
b^2*a^2
gap> phi := GroupHomomorphismByImages(F,G,[F.1,F.2],[a,b]);
[ a, b ] -> [ a, b ]
gap> w^phi;
<bijective rcwa mapping of Z with modulus 256>
gap> w^phi = RepresentativeAction(G,[7,4,9],[4,5,8],OnPoints);
true
gap> List([7,4,9],n->n^(w^phi));
[ 4, 5, 8 ]
gap> w := RepresentativeActionPreImage(G,[37,4,9],[4,51,8],OnPoints,F);
a^-1*b^-1*a*b^4*a
gap> w^phi;
<bijective rcwa mapping of Z with modulus 4608>
gap> w := RepresentativeActionPreImage(G,[37,4,9],[4,51,8],OnTuples,F);
b*a^6*b*a^-3*b^-3*a^-1*b*a^2
gap> w := RepresentativeActionPreImage(G,[17,14,9],[4,51,8],OnPoints,F);
a^-1*b^-1*a^3*b^2*a*b*a*b^-1*a^2
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="RepresentativeAction" Arg="RCWA_Z, P1, P2"
                                    Label="RCWA( Integers ), P1, P2"/>
  <Returns>
    An element of RCWA(<M>\Z</M>) which maps the partition&nbsp;<A>P1</A>
    to&nbsp;<A>P2</A>.
  </Returns>
  <Description>
    The arguments <A>P1</A> and <A>P2</A> must be partitions of the
    underlying ring <M>R</M> into the same number of disjoint
    residue classes.
    It recognizes the option <C>IsTame</C> -- if this option is set,
    the returned mapping is tame provided that there is a tame
    mapping satisfying the required condition.

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<Example>
<![CDATA[
gap> rc := function(r,m) return ResidueClass(DefaultRing(m),m,r); end;;
gap> P1 := [rc(0,3),rc(1,3),rc(2,9),rc(5,9),rc(8,9)];
[ 0(3), 1(3), 2(9), 5(9), 8(9) ]
gap> P2 := [rc(0,2),rc(1,8),rc(5,16),rc(3,4),rc(13,16)];
[ 0(2), 1(8), 5(16), 3(4), 13(16) ]
gap> elm := RepresentativeAction(RCWA(Integers),P1,P2);
<rcwa mapping of Z with modulus 9>
gap> Display(elm);

Rcwa mapping of Z with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0 3 6                                | 2n/3
  1 4 7                                | (8n - 5)/3
  2                                    | (16n + 13)/9
  5                                    | (4n + 7)/9
  8                                    | (16n - 11)/9

gap> P1^elm = P2;
true
gap> elm := RepresentativeAction(RCWA(Integers),P1,P2:IsTame);
<tame rcwa mapping of Z with modulus 1152>
gap> P := RespectedPartition(elm);;
gap> Length(P);
313
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="ShortOrbits" Arg="G, S, maxlng" Label="G, S, maxlng"/>
  <Returns>
    A list of all finite orbits of the rcwa group&nbsp;<A>G</A> of maximal
    length&nbsp;<A>maxlng</A>, which intersect non-trivially with the
    set&nbsp;<A>S</A>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> A5 := IntegralRcwaGroupByPermGroup(AlternatingGroup(5));;
gap> ShortOrbits(A5,[-10..10],100);
[ [ -14, -13, -12, -11, -10 ], [ -9, -8, -7, -6, -5 ], [ -4, -3, -2, -1, 0 ], 
  [ 1, 2, 3, 4, 5 ], [ 6, 7, 8, 9, 10 ] ]
gap> Action(A5,last[2]);
Group([ (1,2,3,4,5), (3,4,5) ])
gap> G := Group(Comm(a,b),Comm(a,c));;
gap> orb := ShortOrbits(G,[-15..15],100);
[ [ -15, -12, -7, -6, -5, -4, -3, -2, -1, 1 ], 
  [ -33, -30, -24, -21, -16, -14, -13, -11, -10, -8 ], [ -9 ], [ 0 ], 
  [ 2, 3, 4, 5, 6, 7, 8, 10, 12, 15 ], [ 9 ], 
  [ 11, 13, 14, 16, 17, 19, 21, 24, 30, 33 ] ]
]]>
</Example>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<Example>
<![CDATA[
gap> Action(G,orb[1]);
Group([ (2,5,8,10,7,6), (1,3,6,9,4,5) ])
gap> ShortOrbits(Group(u),[-30..30],100);
[ [ -13, -8, -7, -5, -4, -3, -2 ], [ -10, -6 ], [ -1 ], [ 0 ], [ 1, 2 ], 
  [ 3, 5 ], [ 24, 36, 39, 40, 44, 48, 60, 65, 67, 71, 80, 86, 93, 100, 112, 
      128, 138, 155, 167, 187, 230, 248, 312, 446, 520, 803, 867, 1445 ] ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name ="OrbitsModulo" Arg="G, m" Label="G, m"/>
  <Returns>
    A partition of <C>[0..<A>m</A>-1]</C>, such that <M>i</M> and
    <M>j</M> lie in the same subset if and only if there is an element
    <M>g</M> of <A>G</A> which moves an element from the residue class
    <M>i(m)</M> to the residue class <M>j(m)</M>.
  </Returns>
  <Description>
    The argument <A>G</A> must be an rcwa group over <M>\mathbb{Z}</M>.
    See also <Ref Oper ="OrbitsModulo" Label="f, m"/> for rcwa mappings.
<Example>
<![CDATA[
gap> OrbitsModulo(G,36);
[ [ 0 ], [ 1, 11, 13, 14, 16, 17, 19, 21, 24, 29, 30, 31, 32, 33, 34, 35 ], 
  [ 2, 3, 4, 5, 6, 7, 8, 10, 12, 15, 20, 22, 23, 25, 26, 28 ], [ 9 ], [ 18 ], 
  [ 27 ] ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ConjugacyInRCWA_R">
<Heading>Conjugacy in RCWA(R)</Heading>

<ManSection>
  <Meth Name="IsConjugate" Arg="RCWA_Z, f, g"
                           Label="RCWA( Integers ), f, g"/>
  <Returns>
    <C>true</C> if the bijective rcwa mappings <A>f</A> and&nbsp;<A>g</A>
    are conjugate in RCWA(<M>\mathbb{Z}</M>), and <C>false</C> otherwise.
  </Returns>
  <Description>
    This may fail or run into an infinite loop.
    In particular the support for wild rcwa mappings is currently very poor,
    since the author does not know a way to solve the conjugacy problem for
    these. Some easy cases are handled anyway.
<Example>
<![CDATA[
gap> IsConjugate(RCWA(Integers),g,h);
false
gap> IsConjugate(RCWA(Integers),g,g^a);
true
gap> IsConjugate(RCWA(Integers),a,b);
false
]]>
</Example>
  </Description>
</ManSection>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<ManSection>
  <Meth Name="RepresentativeAction" Arg="RCWA_Z, f, g"
                                    Label="RCWA( Integers ), f, g"/>
  <Returns>
    An rcwa mapping&nbsp;<C>x</C> such that
    <C><A>f</A>&circum;x = <A>g</A></C>, if such an <C>x</C>
    exists and <C>fail</C> otherwise.
  </Returns>
  <Description>
    This method currently works only for tame rcwa mappings
    of&nbsp;<M>\Z</M>, since the author does not know a way to solve the
    conjugacy problem for wild rcwa mappings.
<Example>
<![CDATA[
gap> elm := RepresentativeAction(RCWA(Integers),h,h^g);
<bijective rcwa mapping of Z with modulus 24>
gap> h^elm = h^g; # check ...
true
gap> Order(elm);
10
gap> cent := g*elm^-1;
<bijective rcwa mapping of Z with modulus 24>
gap> Comm(cent,h); # cent must lie in the centralizer of h in RCWA(Z)
IdentityMapping( Integers )
gap> Order(cent);
12
gap> Display(cent);

Bijective rcwa mapping of Z with modulus 24, of order 12

               n mod 24                |                 n^f
---------------------------------------+--------------------------------------
   0  4 10 12 16 22                    | n - 1
   1 13                                | 2n
   2                                   | (n - 2)/2
   3  9 15 21                          | 2n + 2
   5  6  7 14 17 18 19                 | n
   8 20                                | n/2
  11 23                                | n + 2

]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="ShortCycles" Arg="f, maxlng" Label="f, maxlng"/>
  <Returns>
    All <Q>single</Q> finite cycles of the rcwa mapping&nbsp;<A>f</A>
    of length at most <A>maxlng</A>.
  </Returns>
  <Description>
    In this context, <Q>single</Q> finite cycles are finite cycles not
    belonging to an infinite series, i.e. there is no constant <M>m</M>
    such that adding any multiple of <M>m</M> to the elements of the
    cycle always yields a new cycle. <P/>

    Since &GAP;-permutations cannot move negative integers, rationals
    or even polynomials, the cycles are returned as lists. For example,
    the list <C>[-3,1,2,-2]</C> denotes the cycle <C>(-3,1,2,-2)</C>.
    Mappings having different sets of finite cycle lengths are obviously
    not conjugate in RCWA(<M>R</M>).
<Alt Only="LaTeX">\pagebreak[4]</Alt>
<Example>
<![CDATA[
gap> ShortCycles(a,5);
[ [ 0 ], [ 1 ], [ -1 ], [ 2, 3 ], [ -3, -2 ], [ 4, 6, 9, 7, 5 ], 
  [ -9, -7, -5, -4, -6 ] ]
gap> ShortCycles(u,2);
[ [ 0 ], [ -1 ], [ 1, 2 ], [ 3, 5 ], [ -10, -6 ] ]
gap> ShortCycles(Comm(a,b),10);
[  ]
gap> ShortCycles(a*b,2);
[ [ 0 ], [ 2 ], [ 3 ], [ -26 ], [ 7 ], [ -3 ], [ -1 ] ]
gap> v := RcwaMapping([[-1,2,1],[1,-1,1],[1,-1,1]]);;
gap> w := RcwaMapping([[-1,3,1],[1,-1,1],[1,-1,1],[1,-1,1]]);;
gap> List( [ v, w ], Order );
[ 6, 8 ]
gap> [ ShortCycles(v,10), ShortCycles(w,10) ];
[ [ [ 0, 2, 1 ] ], [ [ 0, 3, 2, 1 ] ] ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Func Name="NrConjugacyClassesOfRCWAZOfOrder" Arg="ord" Label="ord"/>
  <Returns>
    The number of conjugacy classes of RCWA(<M>\Z</M>) of elements
    of order&nbsp;<A>ord</A>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> NrConjugacyClassesOfRCWAZOfOrder(2);
infinity
gap> NrConjugacyClassesOfRCWAZOfOrder(105);
218
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:RestrictionMonomorphisms">
<Heading>Restriction monomorphisms</Heading>

<ManSection>
  <Oper Name ="Restriction" Arg="g, f" Label = "g, f"/>
  <Returns> The <E>restriction</E> of <A>g</A> by&nbsp;<A>f</A>. </Returns>
  <Description>
    By definition, the restriction <M>g_f</M> of <A>g</A> by <A>f</A>
    is the uniquely-determined rcwa mapping satisfying
    <M>f \cdot g_f = g \cdot f</M> and pointwisely fixing the complement of
    the image of <A>f</A>. The mapping <A>f</A> has to be injective.
    If <A>f</A> is bijective, the returned mapping is just the conjugate
    of <A>g</A> by <A>f</A>.
    See also <Ref Oper="Restriction" Label="G, f"/> for rcwa groups.
<Example>
<![CDATA[
gap> Comm(Restriction(a,RcwaMapping([[2,0,1]])),
>         Restriction(u,RcwaMapping([[2,1,1]])));
IdentityMapping( Integers )
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name ="Restriction" Arg="G, f" Label="G, f"/>
  <Returns> The restriction of <A>G</A> by&nbsp;<A>f</A>. </Returns>
  <Description>
    The mapping <A>f</A> has to be injective.
    The returned group acts on the image of <A>f</A> and fixes its
    complement pointwise. If <A>f</A> is bijective the returned
    group is just the conjugate of <A>G</A> by <A>f</A>. <P/>
    The elements of the restricted group are the restrictions
    of the elements of <A>G</A> by <A>f</A>. For a definition see
    <Ref Oper="Restriction" Label="g, f"/> for rcwa mappings.
<Example>
<![CDATA[
gap> G := Restriction(Group(a,b),RcwaMapping([[5,3,1]]));
<rcwa group over Z with 2 generators>
gap> MovedPoints(G);
3(5) \ [ -2, 3 ]
]]>
</Example>
  </Description>
</ManSection>

Restriction monomorphisms allow to form direct products of any
rcwa groups (regardless of whether they are tame or not):

<ManSection>
  <Oper Name ="DirectProduct" Arg="G1, G2, ..." Label="G1, G2, ..."/>
  <Returns>
    The direct product of the rcwa groups over&nbsp;<M>\Z</M>
    given as arguments.
  </Returns>
  <Description>
    As there is no unique or canonical way to embed a direct product
    of rcwa groups into RCWA(<M>\mathbb{Z}</M>), this method may choose
    any such embedding.
<Example>
<![CDATA[
gap> G := DirectProduct(Group(g,h),Group(a,b),Group(u));;
gap> Embedding(G,1);
[ g, h ] -> [ <bijective rcwa mapping of Z with modulus 18, of order 7>, 
  <bijective rcwa mapping of Z with modulus 18, of order 12> ]
gap> Projection(G,2);
[ <bijective rcwa mapping of Z with modulus 18, of order 7>, 
  <bijective rcwa mapping of Z with modulus 18, of order 12>, 
  <wild bijective rcwa mapping of Z with modulus 12>, 
  <wild bijective rcwa mapping of Z with modulus 12>, 
  <bijective rcwa mapping of Z with modulus 15> ] -> 
[ IdentityMapping( Integers ), IdentityMapping( Integers ), a, b, 
  IdentityMapping( Integers ) ]
gap> List([1..3],i->MovedPoints(Image(Embedding(G,i))));
[ 0(3), 1(3) \ [ -2, 1 ], 2(3) \ [ -1, 2 ] ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<!-- #################################################################### -->

<Section Label="sec:MethodsForTameGroups">
<Heading>Special attributes for tame rcwa groups</Heading>

There is a couple of attributes which a priori make only sense for tame
rcwa groups. In the sequel, these attributes are described in detail. <P/>

With their help, various structural information about a given tame rcwa
group can be obtained. For example, there are methods for <C>IsSolvable</C>
and <C>IsPerfect</C> available for tame rcwa groups (the latter works in
some cases by other means also for wild groups). Often it is also feasible
to compute the derived subgroup of a tame rcwa group. 

<ManSection>
  <Attr Name ="RespectedPartition" Arg="G" Label="G"/>
  <Attr Name ="RespectedPartition" Arg="sigma" Label="sigma"/>
  <Returns>
    A <E>respected partition</E> of <A>G</A> resp. <A>sigma</A>.
  </Returns>
  <Description>
    This is a partition of the base ring&nbsp;<M>R</M> into a finite number
    of residue classes which the group&nbsp;<A>G</A> resp. the permutation
    <A>sigma</A> acts on, and on those elements all elements
    of&nbsp;<A>G</A> resp. the group generated by <A>sigma</A> are affine.
    <P/>

    In the author's forthcoming PhD thesis, it will be proved that such
    a partition exists if and only if <A>G</A> resp. <A>sigma</A> is tame.
<Example>
<![CDATA[
gap> G := Group(g,h);;
gap> Size(G);
infinity
gap> P := RespectedPartition(G);
[ 0(12), 1(12), 3(12), 4(12), 5(12), 6(12), 7(12), 9(12), 10(12), 11(12), 
  2(24), 8(24), 14(24), 20(24) ]
gap> Permutation(g,P);
(1,11,2,5,3,12,4)(6,13,7,10,8,14,9)
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="ActionOnRespectedPartition" Arg="G" Label="G"/>
  <Returns>
    The action of the tame rcwa group&nbsp;<A>G</A> on
    <C>RespectedPartition(<A>G</A>)</C>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> H := ActionOnRespectedPartition(G);
Group([ (1,11,2,5,3,12,4)(6,13,7,10,8,14,9), (1,11,2,10)(3,12,4)(5,6,13,7)(8,
    14,9) ])
gap> H = Action(G,P);
true
gap> [ Size(H), Size(DerivedSubgroup(H)), IsPerfect(DerivedSubgroup(H)) ];
[ 322560, 161280, true ]
]]>
</Example>
  </Description>
</ManSection>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<ManSection>
  <Attr Name ="IntegralConjugate" Arg="G" Label="G"/>
  <Attr Name ="IntegralConjugate" Arg="f" Label="f"/>
  <Returns>
    Some integral conjugate of the tame rcwa group&nbsp;<A>G</A> resp.
    of the tame bijective rcwa mapping&nbsp;<A>f</A> in the group
    RCWA(<M>\mathbb{Z}</M>).
  </Returns>
  <Description>
    In the author's forthcoming PhD thesis, it will be proved that such a
    representative exists. Since the result is not defined uniquely,
    methods for this operation will just choose one such mapping.
<Example>
<![CDATA[
gap> Print(LaTeXObj(IntegralConjugate(g)));
n \ \longmapsto \
\begin{cases}
  n + 10 & \text{if} \ n \in 0(14), \\
  n + 3  & \text{if} \ n \in 1(14) \cup 6(14), \\
  n + 9  & \text{if} \ n \in 2(14), \\
  n - 3  & \text{if} \ n \in 3(14) \cup 8(14), \\
  n - 2  & \text{if} \ n \in 4(14) \cup 9(14), \\
  n + 7  & \text{if} \ n \in 5(14), \\
  n + 6  & \text{if} \ n \in 7(14), \\
  n - 9  & \text{if} \ n \in 10(14), \\
  n - 8  & \text{if} \ n \in 11(14), \\
  n - 6  & \text{if} \ n \in 12(14), \\
  n - 5  & \text{if} \ n \in 13(14).
\end{cases}
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name ="IntegralizingConjugator" Arg="G" Label="G"/>
  <Attr Name ="IntegralizingConjugator" Arg="f" Label="f"/>
  <Returns>
    An rcwa mapping mapping&nbsp;<A>x</A> such that
    <A>G</A>&circum;<A>x</A> resp. <A>f</A>&circum;<A>x</A> is integral. 
  </Returns>
  <Description>
    This is of course not defined uniquely, but it holds that
    <C><A>G</A>&circum;IntegralizingConjugator(<A>G</A>) =
    IntegralConjugate(<A>G</A>)</C> resp.
    <C><A>f</A>&circum;IntegralizingConjugator(<A>f</A>) =
    IntegralConjugate(<A>f</A>)</C>.
<Example>
<![CDATA[
gap> Print(LaTeXObj(IntegralizingConjugator(g)));
n \ \longmapsto \
\begin{cases}
  \frac{7n}{6}        & \text{if} \ n \in 0(12), \\
  \frac{7n - 1}{6}    & \text{if} \ n \in 1(12), \\
  \frac{7n + 106}{12} & \text{if} \ n \in 2(24), \\
  \frac{7n - 9}{6}    & \text{if} \ n \in 3(12), \\
  \frac{7n - 10}{6}   & \text{if} \ n \in 4(12), \\
  \frac{7n - 11}{6}   & \text{if} \ n \in 5(12), \\
  \frac{7n - 12}{6}   & \text{if} \ n \in 6(12), \\
  \frac{7n - 13}{6}   & \text{if} \ n \in 7(12), \\
  \frac{7n + 76}{12}  & \text{if} \ n \in 8(24), \\
  \frac{7n - 21}{6}   & \text{if} \ n \in 9(12), \\
  \frac{7n - 22}{6}   & \text{if} \ n \in 10(12), \\
  \frac{7n - 23}{6}   & \text{if} \ n \in 11(12), \\
  \frac{7n + 46}{12}  & \text{if} \ n \in 14(24), \\
  \frac{7n + 16}{12}  & \text{if} \ n \in 20(24).
\end{cases}
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:CategoriesOfRcwaGroups">
<Heading>The categories and families of rcwa groups</Heading>

<ManSection>
  <Filt Name="IsRcwaGroup" Arg="G" Label="G"/>
  <Filt Name="IsIntegralRcwaGroup" Arg="G" Label="G"/>
  <Filt Name="IsSemilocalIntegralRcwaGroup" Arg="G" Label="G"/>
  <Filt Name="IsModularRcwaGroup" Arg="G" Label="G"/>
  <Returns>
    <C>true</C> if <A>G</A> is an rcwa group resp.
    an rcwa group over the ring of integers resp.
    an rcwa group over a semilocalization of the ring of integers resp.
    an rcwa group over a polynomial ring in one variable over a finite field,
    and <C>false</C> otherwise.
  </Returns>
</ManSection>

<ManSection>
  <Fam Name="IntegralRcwaGroupsFamily"/>
  <Description>
    The family of all rcwa groups over the ring of integers.
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->

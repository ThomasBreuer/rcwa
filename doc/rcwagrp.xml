<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  rcwagrp.xml         RCWA documentation           Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$      ## -->
<!-- ##                                                                ## -->
<!-- ##  Copyright (C) 2003 by Stefan Kohl, Fachbereich Mathematik,    ## -->
<!-- ##  Universit\"at Stuttgart, Germany                              ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:RcwaGroups">
<Heading>Residue Class-Wise Affine Groups</Heading>

This chapter describes the functionality available for calculating with
rcwa groups. <P/>

<!-- #################################################################### -->

<Section Label="sec:CategoriesOfRcwaGroups">
<Heading>The categories of rcwa groups</Heading>

  <ManSection>
    <Filt Name="IsRcwaGroup" Arg="G"/>
    <Description>
      The category of all rcwa groups.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsRationalBasedRcwaGroup" Arg="G"/>
    <Description>
      The category of all <Q>rational-based</Q> (hence all integral
      and all semilocal integral) rcwa groups.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsIntegralRcwaGroup" Arg="G"/>
    <Description>
      The category of all integral rcwa groups.
    </Description>
  </ManSection>

  <ManSection>
    <Fam Name="IntegralRcwaGroupsFamily"/>
    <Description>
      The family of all integral rcwa groups.
    </Description>
  </ManSection>

  All integral rcwa groups are supergroups of

  <ManSection>
    <Var Name="TrivialIntegralRcwaGroup"/>
    <Description>
      The trivial integral rcwa group.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsSemilocalIntegralRcwaGroup" Arg="G"/>
    <Description>
      The category of all semilocal integral rcwa groups.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsModularRcwaGroup" Arg="G"/>
    <Description>
      The category of all modular rcwa groups.
    </Description>
  </ManSection>

  All rcwa groups over the ring <A>R</A> are subgroups of

  <ManSection>
    <Func Name="RCWA" Arg="R"/>
    <Returns>
      the group RCWA(<A>R</A>) of all bijective rcwa mappings
      over the ring <A>R</A>.
    </Returns>
    <Description>
      This group is (at least in general) not finitely generated,
      hence no generators are stored.
<Example>
<![CDATA[
gap> RCWA_Z := RCWA(Integers);
RCWA(Z)
gap> Size(RCWA_Z);
infinity
gap> IsFinitelyGeneratedGroup(RCWA_Z);
false
gap> One(RCWA_Z);
IdentityMapping( Integers )
gap> IsSubgroup(RCWA_Z, Group(RcwaMapping([[-1,0,1]]),
>                             RcwaMapping((1,2,3),[1..4]),
>                             RcwaMapping(2,[[0,1],[1,0],[2,3],[3,2]])));
true
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ContructingRcwaGroups">
<Heading>Constructing rcwa groups</Heading>

  Rcwa groups can be constructed using either <C>Group</C>,
  <C>GroupByGenerators</C> or <C>GroupWithGenerators</C>, as usual
  (see reference manual).
  Note that currently except of the whole groups <C>RCWA( <A>R</A> )</C>
  only finitely generated rcwa groups are supported.

<Example>
<![CDATA[
gap> g := RcwaMapping([[1,0,1],[1,1,1],[3,6,1],
>                      [1,0,3],[1,1,1],[3,6,1],
>                      [1,0,1],[1,1,1],[3,-21,1]]);;
gap> h := RcwaMapping([[1,0,1],[1,1,1],[3,6,1],
>                      [1,0,3],[1,1,1],[3,-21,1],
>                      [1,0,1],[1,1,1],[3,6,1]]);;
gap> Order(g);
9
gap> Order(h);
9
gap> G := Group(g,h);
<integral rcwa group with 2 generators>
gap> Size(G);
infinity
]]>
</Example>

  Another possible way to get an rcwa group is by <Q>translating</Q> a
  permutation group, or by taking the image of an rcwa representation.

  <ManSection>
    <Func Name="IntegralRcwaGroupByPermGroup" Arg="G"/>
    <Func Name="RcwaGroupByPermGroup" Arg="G"/>
    <Returns>
      an integral rcwa group isomorphic to the (finite) permutation
      group <A>G</A>, which acts on the range
      <C>[ 1 .. LargestMovedPoint( </C><A>G</A><C> ) ]</C> as <A>G</A> does.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> H := RcwaGroupByPermGroup(Group((1,2),(3,4),(5,6),(7,8),
>                                    (1,3)(2,4),(1,3,5,7)(2,4,6,8)));
<integral rcwa group with 6 generators>
gap> Size(H);
384
gap> IsSolvable(H);
true
gap> List(DerivedSeries(H),Size);
[ 384, 96, 32, 2, 1 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="IsomorphismIntegralRcwaGroup" Arg="G"/>
    <Attr Name="IsomorphismRcwaGroup" Arg="G"/>
    <Description>
      A faithful integral rcwa representation of the group <A>G</A>.
      Currently only supported for finite groups.
<Example>
<![CDATA[
gap> G := GL(2,5);
GL(2,5)
gap> IsomorphismRcwaGroup(G);
CompositionMapping( 
[ (1,2,4,8)(3,6,12,18)(5,10,17,22)(9,15,21,24)(13,14,19,23), 
  (1,3,7)(2,5,11)(4,9,16)(6,13,12)(8,14,20)(10,18,17)(15,22,21)(19,24,23) 
 ] -> [ <integral rcwa mapping with modulus 24>, 
  <integral rcwa mapping with modulus 24> ], <action isomorphism> )
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="Display" Arg="G"/>
    <Description>
      Displays the rcwa group <A>G</A>.
<Example>
<![CDATA[
gap> a := RcwaMapping([[3,0,2],[3, 1,4],[3,0,2],[3,-1,4]]);;
gap> b := RcwaMapping([[3,0,2],[3,13,4],[3,0,2],[3,-1,4]]);;
gap> c := RcwaMapping([[3,0,2],[3, 1,4],[3,0,2],[3,11,4]]);;
gap> H := Group(a,b);
<integral rcwa group with 2 generators>
gap> Display(H);

Integral rcwa group, generated by

[

Bijective integral rcwa mapping with modulus 4

                n mod 4                |                 n^f
---------------------------------------+--------------------------------------
  0 2                                  | 3n/2
  1                                    | (3n + 1)/4
  3                                    | (3n - 1)/4


Bijective integral rcwa mapping with modulus 4

                n mod 4                |                 n^f
---------------------------------------+--------------------------------------
  0 2                                  | 3n/2
  1                                    | (3n + 13)/4
  3                                    | (3n - 1)/4

]

]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ComputingWithRcwaGroups">
<Heading>Computing with rcwa groups</Heading>

  <Index Key="rcwa group" Subkey="element testing"></Index>
  <ManSection>
    <Meth Name="\in" Arg="g, G"/>
    <Description>
      Tries to figure out whether <A>g</A> is an element of <A>G</A> or not.
      This will be successful if <A>G</A> is tame. For wild groups only a
      number of easy cases are covered. On <C>InfoLevel(InfoRCWA) = 3</C>
      the method will give information about reasons why <A>g</A> is an
      element of <A>G</A> or not.
<Example>
gap> u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;
gap> u in H;
false
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="Size" Arg="G"/>
    <Description>
      Tries to compute the order of the rcwa group <A>G</A>. <P/>

      This is a probabilistic method.
      It may return the size of a proper factor group of <A>G</A>,
      or run in an infinite loop. You can increase the option value
      <A>Steps</A> to decrease the probability of getting a wrong result.
      The default value for <A>Steps</A> is 10.
<Example>
<![CDATA[
gap> g1 := RcwaMapping((1,2),[1..2]);
<integral rcwa mapping with modulus 2>
gap> g2 := RcwaMapping((1,2,3),[1..3]);
<integral rcwa mapping with modulus 3>
gap> g3 := RcwaMapping((1,2,3,4,5),[1..5]);
<integral rcwa mapping with modulus 5>
gap> G := Group(g1,g2,g3);
<integral rcwa group with 3 generators>
gap> Size(G);
265252859812191058636308480000000
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="IsomorphismPermGroup" Arg="G"/>
    <Description>
      Tries to compute an isomorphism from a finite rcwa group <A>G</A> to
      some permutation group. <P/>

      This is a probabilistic method, also.
      It may return a homomorphism to a permutation group isomorphic to a
      proper factor group of <A>G</A>. You can increase the option value
      <A>Steps</A> to decrease the probability of getting a wrong result.
      The default value for <A>Steps</A> is 10.
<Example>
<![CDATA[
gap> H := Group(g1,g2);
<integral rcwa group with 2 generators>
gap> phi := IsomorphismPermGroup(H);
[ <bijective integral rcwa mapping with modulus 2, of order 2>, 
  <bijective integral rcwa mapping with modulus 3, of order 3> ] -> 
[ (1,2)(3,4)(5,6), (1,2,3)(4,5,6) ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="IsomorphismMatrixGroup" Arg="G"/>
    <Description>
      An isomorphism from a tame rcwa group <A>G</A> to
      some matrix group. The implemented algorithm uses the classification
      of groups having tame <M>R</M>-rcwa representations.
<Example>
<![CDATA[
gap> g := RcwaMapping([[2,2,1],[1, 4,1],[1,0,2],[2,2,1],[1,-4,1],[1,-2,1]]);;
gap> h := RcwaMapping([[2,2,1],[1,-2,1],[1,0,2],[2,2,1],[1,-1,1],[1, 1,1]]);;
gap> H := Group(g,h);
<integral rcwa group with 2 generators>
gap> phi := IsomorphismMatrixGroup(H);;
gap> FieldOfMatrixGroup(Image(phi));
Rationals
gap> DegreeOfMatrixGroup(Image(phi));
28
gap> List(GeneratorsOfGroup(Image(phi)),Order);
[ 7, 12 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="NiceMonomorphism" Arg="G"/>
    <Returns>
      the result of <C>IsomorphismMatrixGroup</C> in case the group is tame.
    </Returns>
  </ManSection>

  <ManSection>
    <Meth Name="NiceObject" Arg="G"/>
    <Returns>the image of <C>NiceMonomorphism</C>( <A>G</A> ).</Returns>
    <Description>
<Example>
gap> NiceObject(G);
Group([ (1,2)(3,4)(5,6)(7,8)(9,10)(11,12)(13,14)(15,16)(17,18)(19,20)(21,
    22)(23,24)(25,26)(27,28)(29,30), (1,2,3)(4,5,6)(7,8,9)(10,11,12)(13,14,
    15)(16,17,18)(19,20,21)(22,23,24)(25,26,27)(28,29,30), 
  (1,2,3,4,5)(6,7,8,9,10)(11,12,13,14,15)(16,17,18,19,20)(21,22,23,24,25)(26,
    27,28,29,30) ])
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="Modulus" Arg="G" Label = "Modulus of an rcwa group"/>
    <Returns>the modulus of the rcwa group <A>G</A>.</Returns>
    <Description>
      See also <Ref Oper="Modulus" Label="Modulus of an rcwa mapping"/>
      for rcwa mappings, and <Ref Prop="IsTame" Label="Tame rcwa group"/>.
<Example>
gap> Modulus(G);
30
gap> Modulus(Group(a,b));
0
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="PrimeSet" Arg="G" Label="Prime set of an rcwa group"/>
    <Returns>the prime set of the rcwa group <A>G</A>.</Returns>
    <Description>
      See also <Ref Oper="PrimeSet" Label="Prime set of an rcwa mapping"/>
      for rcwa mappings.
<Example>
gap> PrimeSet(G);
[ 2, 3, 5 ]
gap> PrimeSet(H);
[ 2, 3 ]
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsFlat" Arg="G" Label="Flat rcwa group"/>
    <Description>
      Indicates whether or not the rcwa group <A>G</A> is flat. <P/>

      See also <Ref Prop="IsFlat" Label="Flat rcwa mapping"/>
      for rcwa mappings.
<Example>
gap> IsFlat(AlternatingGroup(IsIntegralRcwaGroup,5));
true
gap> IsFlat(Group(a,b));
false
gap> IsFlat(Group(g));
false
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsClassWiseOrderPreserving" Arg="G"
          Label="Class-wise order-preserving rcwa group"/>
    <Description>
      Indicates whether the integral rcwa group <A>G</A> is class-wise
      order-preserving or not. <P/>

     See also <Ref Prop="IsClassWiseOrderPreserving"
     Label="Class-wise order-preserving rcwa mapping"/>
     for rcwa mappings.
<Example>
gap> IsClassWiseOrderPreserving(Group(a,b));
true
gap> IsClassWiseOrderPreserving(G);
true
gap> t := RcwaMapping([[-1,0,1]]);;
gap> IsClassWiseOrderPreserving(Group(t,g,h));
false
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsTame" Arg="G" Label="Tame rcwa group"/>
    <Description>
      Indicates whether or not the rcwa group <A>G</A> is tame. <P/>

      See also <Ref Prop="IsTame" Label="Tame rcwa mapping"/>
      for rcwa mappings.
<Example>
gap> IsTame(G);
true
gap> IsTame(Group(a,b));
false
gap> IsTame(Group(Comm(a,b),Comm(a,c)));
true
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="MovedPoints" Arg="G"/>
    <Returns>
      the set of moved points (support) of the rcwa group <A>G</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> MovedPoints(Group(Comm(a,b),Comm(a,c)));
<union of 8 residue classes (mod 9)>
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="ShortOrbits" Arg="G, S, maxlng"/>
    <Returns>
      a list of all finite orbits of the rcwa group <A>G</A> of maximal
      length <A>maxlng</A>, which intersect non-trivially with the set
      <A>S</A>.
    </Returns>
    <Description>
<Example>
gap> A5 := AlternatingGroup(IsIntegralRcwaGroup,5);;
gap> ShortOrbits(A5,[-10..10],100);
[ [ -14, -13, -12, -11, -10 ], [ -9, -8, -7, -6, -5 ], [ -4, -3, -2, -1, 0 ], 
  [ 1, 2, 3, 4, 5 ], [ 6, 7, 8, 9, 10 ] ]
gap> Action(A5,last[2]);
Group([ (1,2,3,4,5), (3,4,5) ])
gap> ab := Comm(a,b);; ac := Comm(a,c);;
gap> G := Group(ab,ac);;
gap> orb := ShortOrbits(G,[-20..20],100);
[ [ -51, -48, -42, -39, -25, -23, -22, -20, -19, -17 ], [ -18 ], 
  [ -33, -30, -24, -21, -16, -14, -13, -11, -10, -8 ], 
  [ -15, -12, -7, -6, -5, -4, -3, -2, -1, 1 ], [ -9 ], [ 0 ], 
  [ 2, 3, 4, 5, 6, 7, 8, 10, 12, 15 ], [ 9 ], 
  [ 11, 13, 14, 16, 17, 19, 21, 24, 30, 33 ], [ 18 ], 
  [ 20, 22, 23, 25, 26, 28, 39, 42, 48, 51 ] ]
gap> Action(G,orb[1]);
Group([ (2,6,8,10,4,7), (1,5,7,9,3,6) ])
gap> ShortOrbits(Group(u),[-30..30],100);
[ [ -13, -8, -7, -5, -4, -3, -2 ], [ -10, -6 ], [ -1 ], [ 0 ], [ 1, 2 ], 
  [ 3, 5 ], [ 24, 36, 39, 40, 44, 48, 60, 65, 67, 71, 80, 86, 93, 100, 112, 
      128, 138, 155, 167, 187, 230, 248, 312, 446, 520, 803, 867, 1445 ] ]
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="OrbitsModulo" Arg="G, m"
          Label="OrbitsModulo for rcwa group"/>
    <Returns>
      `the set of orbits on the set of residue classes (mod <A>m</A>)
      under the action of <A>G</A>'.
    </Returns>
    <Description>
      This method computes a partition of <C>[0..<A>m</A>-1]</C>, such that
      <M>i</M> and <M>j</M> lie in the same subset if and only if there is an
      element <M>g</M> in <A>G</A> such that <M>M_{i,j} = 1</M>, where
      <M>M</M> is the transition matrix of degree <A>m</A> of <M>g</M>. <P/>

      See also <Ref Oper="OrbitsModulo" Label="OrbitsModulo for rcwa mapping"/>
      for rcwa mappings.
<Example>
gap> OrbitsModulo(G,72);
[ [ 0 ], [ 1, 29, 31, 32, 34, 35, 37, 57, 60, 65, 66, 67, 68, 69, 70, 71 ], 
  [ 2, 3, 4, 5, 6, 7, 8, 10, 12, 15, 38, 40, 41, 43, 44, 46 ], [ 9 ], 
  [ 11, 13, 14, 16, 17, 19, 21, 24, 30, 33, 47, 49, 50, 52, 53, 55 ], [ 18 ], 
  [ 20, 22, 23, 25, 26, 28, 39, 42, 48, 51, 56, 58, 59, 61, 62, 64 ], [ 27 ], 
  [ 36 ], [ 45 ], [ 54 ], [ 63 ] ]
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="RespectedClassPartition" Arg="G"
          Label="Respected class partition for rcwa group"/>
    <Description>
      A partition of the base ring <M>R</M> into a finite number of residue
      classes, on which the group <A>G</A> acts as a permutation group, and
      on those elements all elements of <A>G</A> are affine. 
      The partition is non-trivial as long as the modulus of <A>G</A> is not
      equal to 1. Such a partition exists always if <A>G</A> is tame.

      See also <Ref Attr="RespectedClassPartition"
      Label="Respected class partition for rcwa mapping"/>
      for rcwa mappings.
<Example>
<![CDATA[
gap> g := RcwaMapping([[2,2,1],[1, 4,1],[1,0,2],[2,2,1],[1,-4,1],[1,-2,1]]);;
gap> h := RcwaMapping([[2,2,1],[1,-2,1],[1,0,2],[2,2,1],[1,-1,1],[1, 1,1]]);;
gap> SetName(g,"g");; SetName(h,"h");;
gap> G := Group(g,h);;
gap> Size(G);
infinity
gap> Display(G);

Integral rcwa group of size infinity, generated by

[

Bijective integral rcwa mapping with modulus 6, of order 7

                n mod 6                |                 n^g
---------------------------------------+--------------------------------------
  0 3                                  | 2n + 2
  1                                    | n + 4
  2                                    | n/2
  4                                    | n - 4
  5                                    | n - 2


Bijective integral rcwa mapping with modulus 6, of order 12

                n mod 6                |                 n^h
---------------------------------------+--------------------------------------
  0 3                                  | 2n + 2
  1                                    | n - 2
  2                                    | n/2
  4                                    | n - 1
  5                                    | n + 1

]
gap> pcp := RespectedClassPartition(G);
[ The residue class 0(12), The residue class 1(12), The residue class 3(12), 
  The residue class 4(12), The residue class 5(12), The residue class 6(12), 
  The residue class 7(12), The residue class 9(12), The residue class 10(12), 
  The residue class 11(12), The residue class 2(24), The residue class 8(24), 
  The residue class 14(24), The residue class 20(24) ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="ActionOnClassPartition" Arg="G"/>
    <Description>
      The action of the tame rcwa group <A>G</A> on
      <C>RespectedClassPartition( <A>G</A> )</C>.
<Example>
<![CDATA[
gap> H := ActionOnClassPartition(G);
Group([ (1,11,2,5,3,12,4)(6,13,7,10,8,14,9), (1,11,2,10)(3,12,4)(5,6,13,7)(8,
    14,9) ])
gap> H = Action(G,pcp);
true
gap> Size(H);
322560
gap> D := DerivedSubgroup(H);;
gap> Size(D);
161280
gap> IsPerfect(D);
true
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="RankOfKernelOfActionOnClassPartition" Arg="G"/>
    <Description>
      The rank of the largest free abelian subgroup of the kernel of the
      action of the tame rcwa group <A>G</A> on
      <C>RespectedClassPartition( <A>G</A> )</C>.
<Example>
<![CDATA[
gap> RankOfKernelOfActionOnClassPartition(G);
6
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="KernelOfActionOnClassPartition" Arg="G"/>
    <Description>
      The kernel of the action of the tame rcwa group <A>G</A> on
      <C>RespectedClassPartition( <A>G</A> )</C>.
<Example>
<![CDATA[
gap> K := KernelOfActionOnClassPartition(G);
<integral rcwa group with 6 generators>
gap> Modulus(K);
12
gap> IsAbelian(K);
true
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="KernelOfActionOnClassPartitionHNFMat" Arg="G"/>
    <Description>
      A matrix of vectors in Hermite Normal Form spanning the lattice
      corresponding to the kernel of the action of the tame rcwa group
      <A>G</A> on <C>RespectedClassPartition( <A>G</A> )</C>.
<Log>
<![CDATA[
gap> L := KernelOfActionOnClassPartitionHNFMat(G);
[ [ 12, 0, 0, 0, 0, 12, 0, 0, 0, 0, 336, -360, 336, -360 ],
  [ 0, 12, 0, 0, 0, 0, 12, 0, 0, 0, 480, -504, 480, -504 ],
  [ 0, 0, 12, 0, 0, 0, 0, 12, 0, 0, 888, -912, 888, -912 ],
  [ 0, 0, 0, 12, 0, 0, 0, 0, 12, 0, 1128, -1152, 1128, -1152 ],
  [ 0, 0, 0, 0, 12, 0, 0, 0, 0, 12, 48, -72, 48, -72 ],
  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1560, -1560, 1560, -1560 ] ]
]]>
</Log>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="FlatConjugate" Arg="G"
          Label="Flat conjugate for rcwa group"/>
    <Description>
      Some flat conjugate of the tame rcwa group <A>G</A> in the whole group
      RCWA(<M>R</M>).
      Since this is not defined uniquely, methods for this operation
      will just choose one such group. <P/>

      See also <Ref Attr="FlatConjugate"
                    Label="Flat conjugate for rcwa mapping"/>
      for rcwa mappings.
<Example>
<![CDATA[
gap> F := FlatConjugate(G);
<integral rcwa group with 2 generators, of size infinity>
gap> Display(F);

Integral rcwa group of size infinity, generated by

[

Bijective integral rcwa mapping with modulus 14, of order 7

               n mod 14                |                 n^f
---------------------------------------+--------------------------------------
   0                                   | n + 10
   1  6                                | n + 3
   2                                   | n + 9
   3  8                                | n - 3
   4  9                                | n - 2
   5                                   | n + 7
   7                                   | n + 6
  10                                   | n - 9
  11                                   | n - 8
  12                                   | n - 6
  13                                   | n - 5


Bijective integral rcwa mapping with modulus 14, of order 12

               n mod 14                |                 n^f
---------------------------------------+--------------------------------------
   0                                   | n + 10
   1 12                                | n - 6
   2                                   | n + 9
   3  8                                | n - 1
   4                                   | n + 1
   5                                   | n + 7
   6                                   | n - 2
   7                                   | n + 6
   9                                   | n + 5
  10                                   | n - 9
  11                                   | n - 8
  13                                   | n - 5

]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="FlateningConjugator" Arg="G"
          Label="Flatening conjugator for rcwa group"/>
    <Description>
      An rcwa mapping mapping <A>x</A> such that <A>G</A>&circum;<A>x</A>
      is flat. This is certainly not defined uniquely, but it holds
      that <C>G&circum;FlateningConjugator(G) = FlatConjugate(G)</C>. <P/>

      See also <Ref Attr="FlateningConjugator"
                    Label="Flatening conjugator for rcwa mapping"/>
      for rcwa mappings.
<Example>
<![CDATA[
gap> fl := FlateningConjugator(G);
<bijective integral rcwa mapping with modulus 24>
gap> G^fl = F;
true
gap> Display(fl);

Bijective integral rcwa mapping with modulus 24

               n mod 24                |                 n^f
---------------------------------------+--------------------------------------
   0 12                                | 7n/6
   1 13                                | (7n - 1)/6
   2                                   | (7n + 106)/12
   3 15                                | (7n - 9)/6
   4 16                                | (7n - 10)/6
   5 17                                | (7n - 11)/6
   6 18                                | (7n - 12)/6
   7 19                                | (7n - 13)/6
   8                                   | (7n + 76)/12
   9 21                                | (7n - 21)/6
  10 22                                | (7n - 22)/6
  11 23                                | (7n - 23)/6
  14                                   | (7n + 46)/12
  20                                   | (7n + 16)/12

]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="IsTransitive" Arg="G, Integers"/>
    <Description>
      Tries to determine whether the integral rcwa group <A>G</A> acts
      transitively on the integers.
      Depending on the particular group, this might fail or run into an
      infinite loop.
<Log>
<![CDATA[
gap> G := Group(g,h);;
gap> RCWAInfo(3);
gap> IsTransitive(G,Integers);
#I  IsTransitive: testing for finiteness and searching short orbits ...
#I  Order: the 1st power of the argument is IntegralRcwaMapping( 
[ [ 1, -9, 1 ], [ 1, 0, 1 ], [ 1, 6, 1 ], [ 1, -3, 1 ], [ 1, 0, 1 ], 
  [ 1, 6, 1 ] ] ); this mapping shifts the residue class 2 mod 
6 non-identically onto itself, hence its order is infinity.
#I  Searching for class shifts ...
#I  ... in generators
#I  ... in commutators of the generators
#I  The cyclic group generated by IntegralRcwaMapping( 
[ [ 1, -9, 1 ], [ 1, 0, 1 ], [ 1, 6, 1 ], [ 1, -3, 1 ], [ 1, 0, 1 ], 
  [ 1, 6, 1 ] ] ) acts transitively on the residue class 2 mod 6.
#I  OrbitUnion: initial set = ResidueClassUnion( Integers, 6, [ 2 ] )
#I  Image = Integers
true
gap> RCWAInfo(0);
]]>
</Log>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:PropertiesOfRCWA_Z">
<Heading>Properties of RCWA(Z)</Heading>

  <ManSection>
    <Func Name="NrConjugacyClassesOfRCWAZOfOrder" Arg="ord"/>
    <Returns>
      the number of conjugacy classes of the whole group
      RCWA(<M>\Z</M>) of elements of order <A>ord</A>.
    </Returns>
    <Description>
<Example>
gap> NrConjugacyClassesOfRCWAZOfOrder(2);
infinity
gap> NrConjugacyClassesOfRCWAZOfOrder(105);
218
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:PredefinedRcwaGroups">
<Heading>Predefined rcwa groups</Heading>

  There are methods for constructing various types of groups as integral
  rcwa groups. They are just using the ad hoc-translation provided by 
  <C>IntegralRcwaGroupByPermGroup</C>, for the matrix groups after turning to
  the image under <C>IsomorphismPermGroup</C>. So far, the provided methods
  cover all groups listed in the sections concerning basic groups and
  classical groups in the chapter describing the group libraries in the
  reference manual.

<Example>
<![CDATA[
gap> C2 := CyclicGroup(IsIntegralRcwaGroup,2);
<integral rcwa group with 1 generator>
gap> G := ExtraspecialGroup(IsIntegralRcwaGroup,27,3);
<integral rcwa group with 3 generators>
gap> IsAbelian(G);
false
gap> Exponent(G);
3
gap> S4 := SymmetricGroup(IsIntegralRcwaGroup,4);
<integral rcwa group with 2 generators>
gap> Size(S4);
24
gap> G := SylowSubgroup(S4,2);;
gap> IdGroup(G);
[ 8, 3 ]
gap> A5 := AlternatingGroup(IsIntegralRcwaGroup,5);
<integral rcwa group with 2 generators>
gap> Size(A5);
60
gap> IsSimple(A5);
true
gap> G := GL(IsIntegralRcwaGroup,2,3);
<integral rcwa group with 2 generators>
gap> Size(G);
48
]]>
</Example>

  <Alt Only="HTML">&nbsp;</Alt>

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->

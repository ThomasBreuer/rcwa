<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  rcwagrp.xml         RCWA documentation           Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$      ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:RcwaGroups">
<Heading>Residue Class-Wise Affine Groups</Heading>

This chapter describes the functionality provided by this package for
computing with residue class-wise affine groups.

<!-- #################################################################### -->

<Section Label="sec:ContructingRcwaGroups">
<Heading>Constructing residue class-wise affine groups</Heading>

<Index Key="Group"><C>Group</C></Index>
<Index Key="GroupByGenerators"><C>GroupByGenerators</C></Index>
<Index Key="GroupWithGenerators"><C>GroupWithGenerators</C></Index>

Residue class-wise affine groups can be constructed using either
<C>Group</C>, <C>GroupByGenerators</C> or <C>GroupWithGenerators</C>
as usual, cp. the &GAP; reference manual.

<Example>
<![CDATA[
gap> G := Group(ClassTransposition(0,2,1,4),ClassShift(0,5));
<rcwa group over Z with 2 generators>
gap> IsTame(G); Size(G); IsSolvable(G); IsPerfect(G);
true
infinity
false
false
]]>
</Example>

<Index Key="View" Subkey="G"><C>View</C></Index>
<Index Key="Display" Subkey="G"><C>Display</C></Index>
<Index Key="Print" Subkey="G"><C>Print</C></Index>
<Index Key="String" Subkey="G"><C>String</C></Index>

There are methods for the operations <C>View</C>, <C>Display</C>,
<C>Print</C> and <C>String</C> which are applicable to rcwa groups. <P/>
 
All rcwa groups over a ring <M>R</M> are subgroups of RCWA(<M>R</M>).
The group RCWA(<M>R</M>) itself is not finitely generated, thus cannot be
constructed in the way described above. It is handled as a special case:

<ManSection>
  <Func Name="RCWA" Arg="R" Label="R"/>
  <Returns>
    The group RCWA(<A>R</A>) of all residue class-wise affine
    permutations of the ring&nbsp;<A>R</A>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> RCWA_Z := RCWA(Integers);
RCWA(Z)
]]>
</Example>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<Example>
<![CDATA[
gap> One(RCWA_Z); Size(RCWA_Z); IsFinitelyGeneratedGroup(RCWA_Z);
IdentityMapping( Integers )
infinity
false
gap> IsSolvable(RCWA_Z) or IsPerfect(RCWA_Z);
false
gap> Centre(RCWA_Z);
Trivial rcwa group over Z
gap> IsSubgroup(RCWA_Z,G);
true
]]>
</Example>
  </Description>
</ManSection>

There is a method for the operation <C>Random</C> which
generates pseudo-random elements of RCWA(<M>\Z</M>) --
see&nbsp;<Ref Label="sec:Random"/>. <P/>

Another way of constructing an rcwa group is taking the image of an
rcwa representation:

<ManSection>
  <Attr Name="IsomorphismRcwaGroupOverZ" Arg="G" Label="G"/>
  <Attr Name="IsomorphismRcwaGroup" Arg="G" Label="G"/>
  <Returns>
    A monomorphism from the group <A>G</A> to&nbsp;RCWA(<M>\Z</M>).
  </Returns>
  <Description>
    Currently, <C>IsomorphismRcwaGroup</C> works for finite groups, for
    free products of finite groups and for free groups. The method for
    free products of finite groups uses the Table-Tennis Lemma
    (cp. e.g. Section&nbsp;II.B. in&nbsp;<Cite Key="LaHarpe00"/>), and the
    method for free groups uses an adaptation of the construction given
    on page&nbsp;27 in&nbsp;<Cite Key="LaHarpe00"/> from
    PSL(2,<M>\mathbb{C}</M>) to RCWA(<M>\mathbb{Z}</M>). <P/>

    In case <A>G</A> is a finite-degree permutation group,
    the image under a specific embedding can be obtained by
    <C>RcwaGroupByPermGroup(<A>G</A>)</C>.
    <Index Key="RcwaGroupByPermGroup" Subkey="G">
      <C>RcwaGroupByPermGroup</C>
    </Index>
    The resulting group&nbsp;<C>H</C> satisfies the relation
    <C>Action(H&circum;ClassShift(0,1),[1..LargestMovedPoint(<A>G</A>)])
    =&nbsp;G</C>.
<Example>
<![CDATA[
gap> F := FreeProduct(Group((1,2)(3,4),(1,3)(2,4)),Group((1,2,3)),
>                     SymmetricGroup(3));
<fp group on the generators [ f1, f2, f3, f4, f5 ]>
gap> phi := IsomorphismRcwaGroup(F);
[ f1, f2, f3, f4, f5 ] -> [ <bijective rcwa mapping of Z with modulus 12>,
  <bijective rcwa mapping of Z with modulus 24>,
  <bijective rcwa mapping of Z with modulus 12>,
  <bijective rcwa mapping of Z with modulus 72>,
  <bijective rcwa mapping of Z with modulus 36> ]
gap> G := Image(phi);
<wild rcwa group over Z with 5 generators>
gap> RelatorsOfFpGroup(F); # For illustrational purposes, do some checks:
[ f1^2, f1^-1*f2*f1*f2^-1, f2^2, f3^3, f4^2, f5^2, f4*f5*f4*f5*f4*f5 ]
gap> ForAll([ G.1^2, G.1^-1*G.2*G.1*G.2^-1, G.2^2, G.3^3,
>             G.4^2, G.5^2, (G.4*G.5)^3 ], IsOne);
true
gap> S := AllResidueClassesModulo(3);
[ 0(3), 1(3), 2(3) ]
gap> nonids := grp->Difference(AsList(grp),[One(grp)]);;
gap> List(S{[2,3]},Si->List(nonids(Group(G.1,G.2)),g->Si^g));
[ [ 3(12), 6(24), 0(24) ], [ 9(12), 18(24), 12(24) ] ]
gap> Union(Flat(last));
0(3)
gap> List(S{[1,3]},Si->List(nonids(Group(G.3)),g->Si^g));
[ [ 1(12), 4(12) ], [ 7(12), 10(12) ] ]
gap> Union(Flat(last));
1(3)
gap> List(S{[1,2]},Si->List(nonids(Group(G.4,G.5)),g->Si^g));
[ [ 8(24), 5(36), 17(36), 2(24), 11(36) ],
  [ 20(24), 23(36), 35(36), 14(24), 29(36) ] ]
gap> Union(Flat(last));
2(3)
]]>
</Example>

<Alt Only="LaTeX">\pagebreak[4]</Alt>

<Example>
<![CDATA[
gap> phi := IsomorphismRcwaGroup(FreeGroup(2)); F2 := Image(phi);;
[ f1, f2 ] -> [ <wild bijective rcwa mapping of Z with modulus 8>, 
  <wild bijective rcwa mapping of Z with modulus 8> ]
gap> Difference(Integers,ResidueClass(0,4))^F2.1;
1(4)
gap> Difference(Integers,ResidueClass(2,4))^F2.2;
3(4)
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:DirectProductsAndWreathProducts">
<Heading>Direct products and wreath products</Heading>

The class of groups which can faithfully be represented as rcwa groups
is closed under forming direct products, wreath products with finite
groups and wreath products with the infinite cyclic group <M>(\Z,+)</M>.
For information on how direct products and wreath products of subgroups
of RCWA(<M>\Z</M>) are embedded in RCWA(<M>\Z</M>) see
Section&nbsp;<Ref Label="sec:RestrictionAndInduction"/> below.

<ManSection>
  <Meth Name="DirectProduct" Arg="G1, G2, ..." Label="G1, G2, ..."/>
  <Returns>
    An rcwa group isomorphic to the direct product of the rcwa groups
    over&nbsp;<M>\mathbb{Z}</M> given as arguments.
  </Returns>
  <Description>
    There is certainly no unique or canonical way to embed a direct
    product of rcwa groups into RCWA(<M>\mathbb{Z}</M>). 
    This method chooses to embed the groups <A>G1</A>, <A>G2</A>,
    <A>G3</A>&nbsp;... via restrictions by <M>n \mapsto mn</M>,
    <M>n \mapsto mn+1</M>, <M>n \mapsto mn+2</M>&nbsp;..., where
    <M>m</M> denotes the number of groups given as arguments.
<Example>
<![CDATA[
gap> G := DirectProduct(Group(g,h),Group(a,b),Group(ClassReflection(0,1)));;
gap> Embedding(G,1);
[ g, h ] -> [ <bijective rcwa mapping of Z with modulus 18, of order 7>, 
  <bijective rcwa mapping of Z with modulus 18, of order 12> ]
gap> List([1..3],i->MovedPoints(Image(Embedding(G,i))));
[ 0(3), 1(3) \ [ -2, 1 ], 2(3) \ [ 2 ] ]
gap> Image(Projection(G,2)) = Group(a,b);
true
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="WreathProduct" Arg="G, P" Label="G, P"/>
  <Meth Name="WreathProduct" Arg="G, Z" Label="G, Z"/>
  <Returns>
    An rcwa group isomorphic to the wreath product of the rcwa
    group&nbsp;<A>G</A> over&nbsp;<M>\mathbb{Z}</M> with the finite
    permutation group&nbsp;<A>P</A>, resp. with the infinite cyclic
    group&nbsp;<A>Z</A>.
  </Returns>
  <Description>
    There is certainly no unique or canonical way to embed a wreath product
    of rcwa groups into RCWA(<M>\mathbb{Z}</M>). The first-mentioned method
    embeds the <C>DegreeAction(<A>P</A>)</C>th direct power of&nbsp;<A>G</A>
    using the method for <C>DirectProduct</C>, and lets the permutation
    group&nbsp;<A>P</A> act naturally on the set of residue classes modulo
    <C>DegreeAction(<A>P</A>)</C>. The second-mentioned method restricts
    the group&nbsp;<A>G</A> to the residue class&nbsp;3(4), and maps the
    generator of the infinite cyclic group <A>Z</A> to
    <C>ClassTransposition(0,2,1,2) * ClassTransposition(0,2,1,4)</C>.
<Example>
<![CDATA[
gap> G := Group(g,h);;
gap> IsTame(G); Size(G);    
true
infinity
gap> H := WreathProduct(G,AlternatingGroup(5));
<tame rcwa group over Z with 12 generators, of size infinity>
gap> Embedding(H,1);
[ g, h ] -> [ <bijective rcwa mapping of Z with modulus 30, of order 7>, 
  <bijective rcwa mapping of Z with modulus 30, of order 12> ]
gap> Embedding(H,2);
[ (1,2,3,4,5), (3,4,5) ] -> 
[ <bijective rcwa mapping of Z with modulus 5, of order 5>, 
  <bijective rcwa mapping of Z with modulus 5, of order 3> ]
gap> H := WreathProduct(G,Group(ClassShift(0,1)));
<wild rcwa group over Z with 3 generators>
gap> Support(Image(Embedding(H,1)));
3(4)
gap> Embedding(H,2);
[ ClassShift(0,1) ] -> [ <wild bijective rcwa mapping of Z with modulus 4> ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:MembershipTest">
<Heading>
  The membership test
</Heading>

<Index Key="rcwa group" Subkey="membership test">rcwa group</Index>

There is a method for the operation <C>\in</C>.
Given an rcwa group&nbsp;<C>G</C> and an rcwa mapping&nbsp;<C>g</C>, this
method tries to decide whether <C>g</C> is an element of&nbsp;<C>G</C> or
not. It can always decide this question if <C>G</C> is tame.
For wild groups this is often not the case. On Info level&nbsp;3 of
<C>InfoRCWA</C> the method gives information on reasons why <C>g</C> is
an element of&nbsp;<C>G</C> or&nbsp;not. <P/>

The direct product of two free groups of rank&nbsp;2 can faithfully be
represented as an rcwa group. According to&nbsp;<Cite Key="Mihailova58"/>
this implies that in general the membership problem for rcwa groups is
algorithmically undecidable.

<Example>
<![CDATA[
gap> G := Group(g,h);;
gap> a in G;
false
gap> g*h^2*g*h^-3*g^-1*h^7*g*h in G;
true
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:AttributesAndProperties">
<Heading>Basic attributes and properties of rcwa groups</Heading>

<Index Key="Size" Subkey="G"><C>Size</C></Index>
There is a method available for the operation <C>Size</C>. An rcwa group
is finite if and only if it is tame and its action on a suitably chosen
respected partition (see&nbsp;<Ref Attr="RespectedPartition"/>) is faithful.
Hence the problem of computing the order of an rcwa group reduces to
the problem of deciding whether it is tame, the problem of deciding whether
it acts faithfully on a respected partition and the problem of computing the
order of the finite permutation group induced on the respected partition.

<Index Key="Modulus" Subkey="G"><C>Modulus</C></Index>
<Index Key="Mod" Subkey="G"><C>Mod</C></Index>
<Index Key="ModulusOfRcwaGroup" Subkey="G"><C>ModulusOfRcwaGroup</C></Index>
<Index Key="Multiplier" Subkey="G"><C>Multiplier</C></Index>
<Index Key="Mult" Subkey="G"><C>Mult</C></Index>
<Index Key="Divisor" Subkey="G"><C>Divisor</C></Index>
<Index Key="Div" Subkey="G"><C>Div</C></Index>
<Index Key="PrimeSet" Subkey="G"><C>PrimeSet</C></Index>

Basic attributes derived from the affine partial mappings of the elements of
an rcwa group and their coefficients are <C>Modulus</C>, <C>Multiplier</C>,
<C>Divisor</C> and <C>PrimeSet</C>.
The <E>Modulus</E> of an rcwa group is the lcm of the moduli of its
elements in case such an lcm exists and 0 otherwise.
The <E>multiplier</E> resp. <E>divisor</E> of an rcwa group is the lcm
of the multipliers resp. divisors of its elements in case such an lcm exists
and <M>\infty</M> otherwise.
The <E>prime set</E> of an rcwa group is the union of the prime sets of
its elements.
There are shorthands <C>Mod</C>, <C>Mult</C> and <C>Div</C> defined for
<C>Modulus</C>, <C>Multiplier</C> resp. <C>Divisor</C>. 
Technically, the modulus of an rcwa group is stored as an attribute
<C>ModulusOfRcwaGroup</C>. <P/>

<Index Key="IsTame" Subkey="G"><C>IsTame</C></Index>
<Index Key="IsIntegral" Subkey="G"><C>IsIntegral</C></Index>
<Index Key="IsClassWiseOrderPreserving" Subkey="G">
  <C>IsClassWiseOrderPreserving</C>
</Index>

A tame rcwa group, i.e. one with modulus&nbsp;0, has the property
<C>IsTame</C>. An rcwa group is called <E>integral</E> resp.
<E>class-wise order-preserving</E> if all of its elements are so.
There are corresponding methods available for <C>IsIntegral</C>
and <C>IsClassWiseOrderPreserving</C>.

<Example>
<![CDATA[
gap> g1 := RcwaMapping((1,2),[1..2]);
<bijective rcwa mapping of Z with modulus 2, of order 2>
gap> g2 := RcwaMapping((1,2,3),[1..3]);
<bijective rcwa mapping of Z with modulus 3, of order 3>
gap> g3 := RcwaMapping((1,2,3,4,5),[1..5]);
<bijective rcwa mapping of Z with modulus 5, of order 5>
gap> G := Group(g1,g2,g3);
<rcwa group over Z with 3 generators>
gap> Modulus(G);
30
gap> [ Mult(G), Div(G) ];
[ 1, 1 ]
gap> PrimeSet(G);
[ 2, 3, 5 ]
gap> IsIntegral(G) and IsClassWiseOrderPreserving(G);
true
gap> Size(G);
265252859812191058636308480000000
gap> a := RcwaMapping([[3,0,2],[3,1,4],[3,0,2],[3,-1,4]]);; SetName(a,"a");
gap> b := ClassShift(1,4) * a;; SetName(b,"b");
gap> c := ClassShift(3,4) * a;; SetName(c,"c");
gap> H := Group(a,b,c);;
gap> Modulus(H);
0
gap> [ Mult(H), Div(H) ];
[ infinity, infinity ]
gap> Size(H);
infinity
gap> List( [ G, H, Group(Comm(a,b),Comm(a,c)) ], IsTame );
[ true, false, true ]
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:PermutationAndMatrixReps">
<Heading>
  Permutation- and matrix representations
</Heading>

<ManSection>
  <Meth Name="IsomorphismPermGroup" Arg="G" Label="G"/>
  <Returns>
    An isomorphism from the finite rcwa group&nbsp;<A>G</A> to
    a finite-degree permutation group.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> IsomorphismPermGroup(Group(g1,g2));
[ <bijective rcwa mapping of Z with modulus 2, of order 2>, 
  <bijective rcwa mapping of Z with modulus 3, of order 3> ] -> 
[ (1,6)(2,3)(4,5), (1,5,6)(2,3,4) ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="IsomorphismMatrixGroup" Arg="G" Label="G"/>
  <Returns>
    An isomorphism from the rcwa group&nbsp;<A>G</A> to a matrix group,
    provided that <A>G</A> embeds into a matrix group and that there is
    a suitable method available. Both conditions are fulfilled if
    <A>G</A> is tame.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> g := RcwaMapping([[2,2,1],[1, 4,1],[1,0,2],[2,2,1],[1,-4,1],[1,-2,1]]);;
gap> h := RcwaMapping([[2,2,1],[1,-2,1],[1,0,2],[2,2,1],[1,-1,1],[1, 1,1]]);;
gap> SetName(g,"g"); SetName(h,"h");
gap> phi := IsomorphismMatrixGroup(Group(g,h));;
gap> FieldOfMatrixGroup(Image(phi));
Rationals
gap> DegreeOfMatrixGroup(Image(phi));
14
gap> Display(GeneratorsOfGroup(Image(phi))[1]*One(GF(5)));
 . . . . . . 1 1 . . . . . .
 . . . . . . . 1 . . . . . .
 . . . . . . . . . . 3 . . .
 . . . . . . . . . . . 1 . .
 . . . . . . . . 1 3 . . . .
 . . . . . . . . . 1 . . . .
 . . . . . . . . . . . . 3 .
 . . . . . . . . . . . . . 1
 . . 1 4 . . . . . . . . . .
 . . . 1 . . . . . . . . . .
 2 2 . . . . . . . . . . . .
 . 1 . . . . . . . . . . . .
 . . . . 2 2 . . . . . . . .
 . . . . . 1 . . . . . . . .
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ElementFactorization">
<Heading>
  Factoring elements into generators
</Heading>

<ManSection>
  <Meth Name ="PreImagesRepresentative" Arg="phi, g" Label="phi, g"/>
  <Returns>
    A representative of the set of preimages of&nbsp;<A>g</A> under
    the homomorphism&nbsp;<A>phi</A> from a free group to an rcwa group
    over&nbsp;<M>\mathbb{Z}</M>.
  </Returns>
  <Description>
    This method can be used for factoring elements of rcwa groups
    over <M>\mathbb{Z}</M> into generators. It can also be used for finding
    nontrivial relations among the generators if the respective group is not
    free and the method returns a factorization which does not happen to be
    equal to one which is known a priori.
    The homomorphism <A>phi</A> must map the generators of the free
    group to the generators of the rcwa group one-by-one.
    This method is also suitable for wild groups. The implementation
    is based on <Ref Oper="RepresentativeActionPreImage"
                     Label="G, src, dest, act, F"/>.
<Example>
<![CDATA[
gap> G := Group(g,h);
<rcwa group over Z with 2 generators>
gap> phi := EpimorphismFromFreeGroup(G);
[ g, h ] -> [ g, h ]
gap> PreImagesRepresentative(phi,h*g^3*h^2*g^-1*h*g*h^-3);
h*g^3*h^2*g^-1*h*g*h^-3
gap> nu := RcwaMapping([[1,1,1]]);
Rcwa mapping of Z: n -> n + 1
gap> SetName(nu,"nu");
gap> G := Group(a,nu);
<rcwa group over Z with 2 generators>
gap> IsTame(G);
false
gap> phi := EpimorphismFromFreeGroup(G);
[ a, nu ] -> [ a, nu ]
gap> F := Source(phi);
<free group on the generators [ a, nu ]>
gap> w := Comm(F.1,Comm(F.1,F.2^2));
a^-1*nu^-2*a^-1*nu^2*a*nu^-2*a*nu^2
gap> f := w^phi;
<bijective rcwa mapping of Z with modulus 18>
gap> IsTame(f);
false
gap> pre := PreImagesRepresentative(phi,f);
a^-2*nu^-2*a^2*nu^2
gap> one := w*pre^-1; # pre <> w --> We have a nontrivial relation!
a^-1*nu^-2*a^-1*nu^2*a*nu^-2*a^-1*nu^2*a^2
gap> one^phi;
IdentityMapping( Integers )
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name ="PreImagesRepresentatives" Arg="phi, g" Label="phi, g"/>
  <Returns>
    A list of representatives of the set of preimages of&nbsp;<A>g</A>
    under the homomorphism&nbsp;<A>phi</A> from a free group to an rcwa
    group over&nbsp;<M>\mathbb{Z}</M>.
  </Returns>
  <Description>
    Quite frequently, computing several preimages is not harder than
    computing just one, i.e. often several preimages are found
    simultaneously. This operation is called by
    <Ref Meth ="PreImagesRepresentative" Label="phi, g"/>,
    which simply chooses the shortest representative.
    For a slightly more concise description see there.
<Example>
<![CDATA[
gap> G := Group(g,h);
<rcwa group over Z with 2 generators>
gap> phi := EpimorphismFromFreeGroup(G);
[ g, h ] -> [ g, h ]
gap> f := g^3*h*g^-4*h^5*g;
<bijective rcwa mapping of Z with modulus 12>
gap> pre := PreImagesRepresentatives(phi,f);
[ g^3*h*g^3*h^5*g, g^-3*h^-4*g^-3*h^-1*g*h*g, g^3*h*g^-4*h^5*g ]
gap> List(pre,Length);
[ 13, 14, 14 ]
gap> Set(List(pre,w->w^phi)) = [f];
true
gap> w := pre[1]*pre[2]^-1;
g^3*h*g^3*h^4*g^-1*h*g^3*h^4*g^3
gap> Length(w);
23
gap> w^phi; # A relation of length 23.
IdentityMapping( Integers )
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ActionOnR">
<Heading>The action of an rcwa group on the underlying ring</Heading>

<Index Key="Support" Subkey="G"><C>Support</C></Index>
<Index Key="MovedPoints" Subkey="G"><C>MovedPoints</C></Index>

The support, i.e. set of moved points, of an rcwa group can be determined
by <C>Support</C> or <C>MovedPoints</C> (these are synonyms).
Sometimes testing for transitivity on the underlying ring is feasible.
This is e.g. the case for tame groups over&nbsp;<M>\Z</M>.
Further it is often possible to determine group elements which map a
given tuple of elements of the underlying ring to a given other tuple,
if such elements exist.

<ManSection>
  <Meth Name="IsTransitive" Arg="G, Integers" Label="G, Integers"/>
  <Returns>
    <C>true</C> if the rcwa group&nbsp;<A>G</A> acts transitively
    on&nbsp;<M>\Z</M> and <C>false</C> otherwise.
  </Returns>
  <Description>
    If <A>G</A> is wild, this may fail or run into an infinite loop.
<Example>
<![CDATA[
gap> G := Group(g,h);;
gap> IsTransitive(G,Integers);
true
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="RepresentativeAction"
        Arg="G, src, dest, act" Label="G, src, dest, act"/>
  <Returns>
    An element of <A>G</A> which maps <A>src</A> to&nbsp;<A>dest</A>
    under the action given by&nbsp;<A>act</A>.
  </Returns>
  <Description>
    If an element satisfying this condition does not exist, this method
    either returns <C>fail</C> or runs into an infinite loop.
    The problem of whether <A>src</A> and <A>dest</A> lie in the same
    orbit under the action of <A>G</A> in general seems to be hard.
    The method is based on <Ref Oper="RepresentativeActionPreImage"
    Label="G, src, dest, act, F"/>, and it basically just computes an image
    under an epimorphism. As this involves multiplications of rcwa mappings,
    this can be quite expensive if the group <A>G</A> is wild, the preimage
    is a rather long word and coefficient explosion happens to occur.
<Example>
<![CDATA[
gap> G := Group(a,b);
<rcwa group over Z with 2 generators>
gap> elm := RepresentativeAction(G,[7,4,9],[4,5,13],OnTuples);
<bijective rcwa mapping of Z with modulus 12>
gap> Display(elm);

Bijective rcwa mapping of Z with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0  2  3  6  8 11                    | n
   1  7 10                             | n - 3
   4                                   | n + 1
   5  9                                | n + 4

gap> List([7,4,9],n->n^elm);
[ 4, 5, 13 ]
gap> elm := RepresentativeAction(G,[5,4,9],[13,5,4],OnTuples);
<bijective rcwa mapping of Z with modulus 9>
gap> Display(elm);

Bijective rcwa mapping of Z with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0                                    | 4n/9
  1                                    | (8n - 26)/9
  2                                    | (8n + 2)/9
  3                                    | (8n + 3)/9
  4                                    | (16n - 19)/9
  5                                    | (16n + 37)/9
  6                                    | (8n + 33)/9
  7                                    | (16n - 49)/9
  8                                    | (16n + 7)/9

gap> List([5,4,9],n->n^elm);
[ 13, 5, 4 ]
gap> RepresentativeAction(G,[7,4,9],[4,5,8],OnTuples);
<bijective rcwa mapping of Z with modulus 256>
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="RepresentativeActionPreImage"
        Arg="G, src, dest, act, F" Label="G, src, dest, act, F"/>
  <Returns>
    The result of
    <C>RepresentativeAction(<A>G</A>,<A>src</A>,<A>dest</A>,<A>act</A>)</C>
    as word in generators.
  </Returns>
  <Description>
    The argument <A>F</A> is a free group whose generators are used as
    letters of the returned word. Note that the dependency is just in the
    opposite direction than suggested above (<C>RepresentativeAction</C>
    calls <C>RepresentativeActionPreImage</C>) and that the evaluation
    of the word sometimes takes much more time than its determination.
    For this reason, <C>RepresentativeActionPreImage</C> is sometimes
    much faster than <C>RepresentativeAction</C>.
    The used algorithm is not inefficient, as the last two of the
    examples below suggest. It is based on computing balls of
    increasing radius around <A>src</A> and <A>dest</A> until they
    intersect nontrivially. It avoids multiplying rcwa mappings.
    Of course the other warnings given in the description of
    <Ref Meth="RepresentativeAction" Label="G, src, dest, act"/>
    apply to this operation as well.
<Example>
<![CDATA[
gap> F := FreeGroup("a","b");;
gap> G := Group(a,b);; phi := EpimorphismByGenerators(F,G);;
gap> RepresentativeActionPreImage(G,[5,4,9],[13,5,4],OnTuples,F);
b^-1*a^-1*b*a^-1
gap> w := RepresentativeActionPreImage(G,[4,7,9],[4,5,8],OnPoints,F);
b^2*a^2
gap> w^phi;
<bijective rcwa mapping of Z with modulus 256>
gap> last = RepresentativeAction(G,[4,7,9],[4,5,8],OnPoints);
true
gap> [4,7,9]^(w^phi);
[ 4, 5, 8 ]
gap> RepresentativeActionPreImage(G,[37,4,9],[4,51,8],OnPoints,F); last^phi;
a^-1*b^-1*a*b^4*a
<bijective rcwa mapping of Z with modulus 4608>
gap> RepresentativeActionPreImage(G,[37,4,9],[4,51,8],OnTuples,F);
b*a^6*b*a^-3*b^-3*a^-1*b*a^2
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="RepresentativeAction" Arg="RCWA_Z, P1, P2"
                                    Label="RCWA( Integers ), P1, P2"/>
  <Returns>
    An element of RCWA(<M>\Z</M>) which maps the partition&nbsp;<A>P1</A>
    to&nbsp;<A>P2</A>.
  </Returns>
  <Description>
    The arguments <A>P1</A> and <A>P2</A> must be partitions of the
    underlying ring <M>R</M> into the same number of disjoint unions of
    residue classes.
    The method recognizes the option <C>IsTame</C>. If this option
    is set, the returned mapping is tame provided that there is a tame
    mapping which satisfies the given condition.
    If the option <C>IsTame</C> is not set and the partitions <A>P1</A>
    and <A>P2</A> both consist entirely of single residue classes, then
    the returned mapping is affine on any residue class in&nbsp;<A>P1</A>.
<Example>
<![CDATA[
gap> P1 := List([[0,3],[1,3],[2,9],[5,9],[8,9]],ResidueClass);
[ 0(3), 1(3), 2(9), 5(9), 8(9) ]
gap> P2 := List([[0,2],[1,8],[5,16],[3,4],[13,16]],ResidueClass);
[ 0(2), 1(8), 5(16), 3(4), 13(16) ]
gap> elm := RepresentativeAction(RCWA(Integers),P1,P2);
<bijective rcwa mapping of Z with modulus 9>
gap> Display(elm);

Bijective rcwa mapping of Z with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0 3 6                                | 2n/3
  1 4 7                                | (8n - 5)/3
  2                                    | (16n + 13)/9
  5                                    | (4n + 7)/9
  8                                    | (16n - 11)/9

gap> P1^elm = P2;
true
gap> elm := RepresentativeAction(RCWA(Integers),P1,P2:IsTame);
<tame bijective rcwa mapping of Z with modulus 1152>
gap> P := RespectedPartition(elm);;
gap> Length(P);
313
gap> elm := RepresentativeAction(RCWA(Integers),
>             [ResidueClass(1,3),Union(ResidueClass(0,3),ResidueClass(2,3))],
>             [Union(ResidueClass(2,5),ResidueClass(4,5)),
>              Union(ResidueClass(0,5),ResidueClass(1,5),ResidueClass(3,5))]);
<bijective rcwa mapping of Z with modulus 6>
gap> [ResidueClass(1,3),Union(ResidueClass(0,3),ResidueClass(2,3))]^elm;
[ 2(5) U 4(5), Z \ 2(5) U 4(5) ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="ShortOrbits" Arg="G, S, maxlng" Label="G, S, maxlng"/>
  <Returns>
    A list of all finite orbits of the rcwa group&nbsp;<A>G</A> of maximal
    length&nbsp;<A>maxlng</A>, which intersect nontrivially with the
    set&nbsp;<A>S</A>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> A5 := RcwaGroupByPermGroup(AlternatingGroup(5));;
gap> ShortOrbits(A5,[-10..10],100);
[ [ -10, -9, -8, -7, -6 ], [ -5, -4, -3, -2, -1 ], [ 0, 1, 2, 3, 4 ], 
  [ 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14 ] ]
gap> Action(A5,last[2]);
Group([ (1,2,3,4,5), (3,4,5) ])
gap> u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;
gap> ShortOrbits(Group(u),[-30..30],100);
[ [ -13, -8, -7, -5, -4, -3, -2 ], [ -10, -6 ], [ -1 ], [ 0 ], [ 1, 2 ], 
  [ 3, 5 ], [ 24, 36, 39, 40, 44, 48, 60, 65, 67, 71, 80, 86, 93, 100, 112, 
      128, 138, 155, 167, 187, 230, 248, 312, 446, 520, 803, 867, 1445 ] ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name ="OrbitsModulo" Arg="G, m" Label="G, m"/>
  <Returns>
    A partition of <C>[0..<A>m</A>-1]</C> such that <M>i</M> and
    <M>j</M> lie in the same subset if and only if there is an element
    <M>g</M> of <A>G</A> which moves an element from the residue class
    <M>i(m)</M> to the residue class <M>j(m)</M>.
  </Returns>
  <Description>
    The argument <A>G</A> must be an rcwa group over <M>\Z</M>.
    See also <Ref Oper ="OrbitsModulo" Label="f, m"/> for rcwa mappings.
<Example>
<![CDATA[
gap> G := Group(Comm(a,b),Comm(a,c));;
gap> OrbitsModulo(G,36);
[ [ 0 ], [ 1, 11, 13, 14, 16, 17, 19, 21, 24, 29, 30, 31, 32, 33, 34, 35 ], 
  [ 2, 3, 4, 5, 6, 7, 8, 10, 12, 15, 20, 22, 23, 25, 26, 28 ], [ 9 ], [ 18 ], 
  [ 27 ] ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name ="Ball" Arg="G, p, d, act" Label="G, p, d, act"/>
  <Meth Name ="Ball" Arg="G, g, d" Label="G, g, d"/>
  <Returns>
    The ball of radius&nbsp;<A>d</A> around the point&nbsp;<A>p</A> under
    the action&nbsp;<A>act</A> of the group&nbsp;<A>G</A>, resp. the ball
    of radius&nbsp;<A>d</A> around the element&nbsp;<A>g</A> in the
    group&nbsp;<A>G</A>.
  </Returns>
  <Description>
    All balls are understood w.r.t. <C>GeneratorsOfGroup(<A>G</A>)</C>.
    As element tests can be expensive, the latter method does not check
    whether <A>g</A> is indeed an element of&nbsp;<A>G</A>.
    The methods require that point comparisons resp. element comparisons
    are cheap. They are not only applicable to rcwa groups.
<Example>
<![CDATA[
gap> G := Group(Comm(a,b),Comm(a,c));;
gap> for d in [1..4] do Print(Ball(G,1,d,OnPoints),"\n"); od;
[ -3, -2, 1 ]
[ -5, -4, -3, -2, 1 ]
[ -15, -12, -7, -6, -5, -4, -3, -2, -1, 1 ]
[ -15, -12, -7, -6, -5, -4, -3, -2, -1, 1 ]
gap> List([1..11],d->Length(Ball(G,[1,2,3],d,OnSets)));
[ 5, 17, 51, 127, 245, 324, 343, 357, 360, 360, 360 ]
gap> List([1..11],d->Length(Ball(G,[1,2,3],d,OnTuples)));
[ 5, 17, 51, 143, 325, 557, 662, 695, 713, 720, 720 ]
gap> Ball(Group((1,2),(2,3),(3,4)),(),2);
[ (), (3,4), (2,3), (2,3,4), (2,4,3), (1,2), (1,2)(3,4), (1,2,3), (1,3,2) ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ConjugacyInRCWA_Z">
<Heading>Conjugacy in RCWA(Z)</Heading>

<ManSection>
  <Meth Name="IsConjugate" Arg="RCWA_Z, f, g"
                           Label="RCWA( Integers ), f, g"/>
  <Returns>
    <C>true</C> if the bijective rcwa mappings <A>f</A> and&nbsp;<A>g</A>
    are conjugate in RCWA(<M>\Z</M>), and <C>false</C> otherwise.
  </Returns>
  <Description>
    The author does not know a general way to solve the conjugacy problem
    for elements of RCWA(<M>\Z</M>), thus the method may fail or run into
    an infinite loop.
<Example>
<![CDATA[
gap> IsConjugate(RCWA(Integers),g,h);
false
gap> IsConjugate(RCWA(Integers),g,g^a);
true
gap> IsConjugate(RCWA(Integers),a,b);
false
]]>
</Example>
  </Description>
</ManSection>

<Index Key="ShortCycles" Subkey="f, maxlng"><C>ShortCycles</C></Index>
There is an operation <C>ShortCycles(<A>f</A>,<A>maxlng</A>)</C> which
returns a list of all cycles of <A>f</A> of length at most <A>maxlng</A>
which do not correspond to cycles consisting of residue classes. The
cycles are sorted by increasing length. If for some value of <A>maxlng</A>
the lists <C>List(ShortCycles(<A>f</A>,<A>maxlng</A>),Length)</C> and
<C>List(ShortCycles(<A>g</A>,<A>maxlng</A>),Length)</C> differ, then
<A>f</A> and <A>g</A> are clearly not conjugate.

<Example>
<![CDATA[
gap> ShortCycles(a,5);
[ [ 0 ], [ 1 ], [ -1 ], [ 2, 3 ], [ -3, -2 ], [ 4, 6, 9, 7, 5 ], 
  [ -9, -7, -5, -4, -6 ] ]
]]>
</Example>

<ManSection>
  <Meth Name="RepresentativeAction" Arg="RCWA_Z, f, g"
                                    Label="RCWA( Integers ), f, g"/>
  <Returns>
    An rcwa mapping&nbsp;<C>x</C> such that
    <C><A>f</A>&circum;x = <A>g</A></C>, if such an <C>x</C>
    exists and <C>fail</C> otherwise.
  </Returns>
  <Description>
    This method may fail for the same reasons as
    <Ref Meth="IsConjugate" Label="RCWA( Integers ), f, g"/>.
<Example>
<![CDATA[
gap> elm := RepresentativeAction(RCWA(Integers),h,h^g);
<bijective rcwa mapping of Z with modulus 12>
gap> h^elm = h^g; # check ...
true
gap> Order(elm);
infinity
gap> cent := g*elm^-1;
<bijective rcwa mapping of Z with modulus 12>
gap> Comm(cent,h); # cent must lie in the centralizer of h in RCWA(Z).
IdentityMapping( Integers )
gap> Order(cent);
12
gap> cent in Group(h); # This particular element is even a power of h.
true
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Func Name="NrConjugacyClassesOfRCWAZOfOrder" Arg="ord" Label="ord"/>
  <Returns>
    The number of conjugacy classes of RCWA(<M>\Z</M>) of elements
    of order&nbsp;<A>ord</A>, as given in Corollary&nbsp;2.7.1&nbsp;(b)
    in&nbsp;<Cite Key="Kohl05"/>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> NrConjugacyClassesOfRCWAZOfOrder(2);
infinity
gap> NrConjugacyClassesOfRCWAZOfOrder(105);
218
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:RestrictionAndInduction">
<Heading>Restriction and induction</Heading>

There are monomorphisms from the group RCWA(<M>\Z</M>) into itself.
The support of the image of such a monomorphism is the image of a given
injective rcwa mapping. Therefore these monomorphisms are called
<E>restriction monomorphisms</E>. Taking images of rcwa groups under
restrictions by rcwa mappings with pairwise distinct images permits
forming their direct product and their wreath product with some finite
permutation group, regardless of whether they are tame or not
(cp. Section&nbsp;<Ref Label="sec:DirectProductsAndWreathProducts"/>).

<ManSection>
  <Oper Name ="Restriction" Arg="g, f" Label = "g, f"/>
  <Returns>
    The <E>restriction</E> of the rcwa mapping <A>g</A> by
    the injective rcwa mapping&nbsp;<A>f</A>.
  </Returns>
  <Description>
    By definition, the restriction <M>g_f</M> of the rcwa mapping
    <A>g</A> by the injective rcwa mapping&nbsp;<A>f</A> is the
    uniquely determined rcwa mapping which satisfies
    <M>f \cdot g_f = g \cdot f</M> and fixes the complement of
    the image of <A>f</A> pointwisely.
    If <A>f</A> is bijective, the restriction of <A>g</A> by <A>f</A>
    is just the conjugate of <A>g</A> under&nbsp;<A>f</A>.
    See also <Ref Oper="Restriction" Label="G, f"/> for rcwa groups.
<Example>
<![CDATA[
gap> Comm(Restriction(a,RcwaMapping([[2,0,1]])),
>         Restriction(u,RcwaMapping([[2,1,1]])));
IdentityMapping( Integers )
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name ="Restriction" Arg="G, f" Label="G, f"/>
  <Returns>
    The <E>restriction</E> of the rcwa group <A>G</A> by
    the injective rcwa mapping&nbsp;<A>f</A>.
  </Returns>
  <Description>
    By definition, the restriction of the rcwa group&nbsp;<A>G</A>
    by the injective rcwa mapping&nbsp;<A>f</A> consists of the
    restrictions of the elements of&nbsp;<A>G</A> by&nbsp;<A>f</A>.
    The restriction of&nbsp;<A>G</A> by&nbsp;<A>f</A> acts on the
    image of&nbsp;<A>f</A> and fixes its complement pointwisely.
    See also <Ref Oper="Restriction" Label="g, f"/> for rcwa mappings.
<Example>
<![CDATA[
gap> G := Restriction(Group(a,b),RcwaMapping([[5,3,1]]));
<rcwa group over Z with 2 generators>
gap> MovedPoints(G);
3(5) \ [ -2, 3 ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name ="Induction" Arg="g, f" Label = "g, f"/>
  <Oper Name ="Induction" Arg="G, f" Label = "G, f"/>
  <Returns>
    The <E>induction</E> of the rcwa mapping <A>g</A> resp. the rcwa
    group <A>G</A> by the injective rcwa mapping&nbsp;<A>f</A>.
  </Returns>
  <Description>
    By definition, induction is the right inverse of restriction.
    This means that it is
    <C>Induction(Restriction(<A>g</A>,<A>f</A>),<A>f</A>) = <A>g</A></C>
    resp.
    <C>Induction(Restriction(<A>G</A>,<A>f</A>),<A>f</A>) = <A>G</A></C>.
    The mapping&nbsp;<A>g</A> resp. the group&nbsp;<A>G</A> must not move
    points outside the image of&nbsp;<A>f</A>.
<Example>
<![CDATA[
gap> Induction(G,RcwaMapping([[5,3,1]])) = Group(a,b);
true
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:Random">
<Heading>Getting pseudo-random elements of RCWA(Z)</Heading>

<Index Key="Random" Subkey="RCWA(Z)"><C>Random</C></Index>
There is a method for the operation <C>Random</C> for RCWA(<M>\Z</M>).
This method is designed to be suitable for generating interesting
examples. No particular distribution is guaranteed -- in fact, the
author has no idea what a <Q>good</Q> random distribution on
RCWA(<M>\Z</M>) should be.

<Log>
<![CDATA[
gap> elm := Random(RCWA(Integers));
<bijective rcwa mapping of Z with modulus 60>
gap> Display(elm);

Bijective rcwa mapping of Z with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0  2  4  6  8 10                    | 3n + 2
   1  5  9                             | -n + 2
   3  7                                | (n - 7)/2
  11                                   | (-n + 20)/3

]]>
</Log>

The elements which are returned by this method are obtained by
multiplying class shifts (see <Ref Func="ClassShift" Label="r, m"/>),
class reflections (see <Ref Func="ClassReflection" Label="r, m"/>) and
class transpositions (see <Ref Func="ClassTransposition"
                          Label="r1, m1, r2, m2"/>).
These factors can be retrieved by factoring:

<Log>
<![CDATA[
gap> Factorization(elm);
[ ClassTransposition(0,2,3,4), ClassTransposition(3,4,4,6),
  ClassShift(0,2)^-1, ClassReflection(3,4), ClassReflection(1,4) ]
]]>
</Log>

An auxiliary function which is used in this context for choosing the
class transpositions is <C>ClassPairs(<A>m</A>)</C>.
<Index Key="ClassPairs" Subkey="m"><C>ClassPairs</C></Index>
This function returns a list of all pairs of disjoint residue classes
<M>r_1(m_1)</M>, <M>r_2(m_2)</M>, where <M>m_1, m_2 \leq m</M>.

</Section>

<!-- #################################################################### -->

<Section Label="sec:MethodsForTameGroups">
<Heading>Special attributes for tame rcwa groups</Heading>

There is a couple of attributes which a priori make only sense for tame
rcwa groups. In the sequel, these attributes are described in detail. <P/>

With their help, various structural information about a given tame rcwa
group can be obtained. For example there are methods for <C>IsSolvable</C>
and <C>IsPerfect</C> available for tame rcwa groups, while testing wild
groups for solvability or perfectness is currently not always feasible.
It is often also possible to compute the derived subgroup of a tame
rcwa group. 

<ManSection>
  <Attr Name ="RespectedPartition" Arg="G" Label="G"/>
  <Attr Name ="RespectedPartition" Arg="sigma" Label="sigma"/>
  <Returns>
    A <E>respected partition</E> of <A>G</A> resp. <A>sigma</A>.
  </Returns>
  <Description>
    A <E>respected partition</E> of&nbsp;<A>G</A> resp.&nbsp;<A>sigma</A>
    is a partition of the underlying ring&nbsp;<M>R</M> into a finite
    number of residue classes on which&nbsp;<A>G</A> resp. the cyclic
    group generated by&nbsp;<A>sigma</A> acts in a natural way as
    a permutation group, and on whose elements all elements of&nbsp;<A>G</A>
    resp. all powers of&nbsp;<A>sigma</A> are affine. In the author's thesis
    it is shown that such a partition exists if and only if <A>G</A> resp.
    <A>sigma</A> is tame (see Theorem&nbsp;2.5.8). <P/>

    <Index Key="RespectedPartitionShort" Subkey="G">
      <C>RespectedPartitionShort</C>
    </Index>
    <Index Key="RespectedPartitionShort" Subkey="sigma">
      <C>RespectedPartitionShort</C>
    </Index>
    <Index Key="RespectedPartitionLong" Subkey="G">
      <C>RespectedPartitionLong</C>
    </Index>
    <Index Key="RespectedPartitionLong" Subkey="sigma">
      <C>RespectedPartitionLong</C>
    </Index>
    Related attributes are <C>RespectedPartitionShort</C> and
    <C>RespectedPartitionLong</C>. They are used to denote respected
    partitions consisting of residue classes <M>r(m)</M> where <M>m</M>
    divides the modulus of&nbsp;<A>G</A> resp. <A>sigma</A>, resp. where
    the modulus of <A>G</A> resp. <A>sigma</A> divides&nbsp;<M>m</M>. <P/>

    The permutation induced by <A>sigma</A> on a respected
    partition&nbsp;<C>P</C> can be computed efficiently using
    <C>PermutationOpNC(<A>sigma</A>,P,OnPoints)</C>.
    <Index Key="PermutationOpNC" Subkey="sigma, P, OnPoints">
      <C>PermutationOpNC</C>
    </Index>
<Example>
<![CDATA[
gap> G := Group(g,h);; Size(G);
infinity
gap> P := RespectedPartition(G);
[ 0(6), 1(6), 3(6), 4(6), 5(6), 2(12), 8(12) ]
gap> Permutation(g,P);
(1,6,2,5,3,7,4)
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="ActionOnRespectedPartition" Arg="G" Label="G"/>
  <Returns>
    The action of the tame rcwa group&nbsp;<A>G</A> on
    <C>RespectedPartition(<A>G</A>)</C>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> H := ActionOnRespectedPartition(G);
Group([ (1,6,2,5,3,7,4), (1,6,2,5)(3,7,4) ])
gap> H = Action(G,P);
true
gap> StructureDescription(H);
"S7"
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="KernelOfActionOnRespectedPartition" Arg="G" Label="G"/>
  <Attr Name="RankOfKernelOfActionOnRespectedPartition" Arg="G" Label="G"/>
  <Returns>
    The kernel of the action of the tame rcwa group&nbsp;<A>G</A> on
    <C>RespectedPartition(<A>G</A>)</C>, resp. the rank of the largest
    free abelian subgroup of this kernel.
  </Returns>
  <Description>
    The method for <C>KernelOfActionOnRespectedPartition</C> uses
    the package <Package>Polycyclic</Package>&nbsp;<Cite Key="Polycyclic"/>.
<Example>
<![CDATA[
gap> K := KernelOfActionOnRespectedPartition(G);
<rcwa group over Z with 6 generators>
gap> RankOfKernelOfActionOnRespectedPartition(G);
6
gap> Index(G,K);
5040
gap> IsomorphismPcpGroup(K);
[ <bijective rcwa mapping of Z with modulus 12>,
  <bijective rcwa mapping of Z with modulus 12>,
  <bijective rcwa mapping of Z with modulus 12>,
  <bijective rcwa mapping of Z with modulus 12>,
  <bijective rcwa mapping of Z with modulus 12>,
  <bijective rcwa mapping of Z with modulus 12> ] ->
[ g2*g14^-1, g4*g14^-1, g6*g14^-1, g8*g14^-1, g10*g14^-1, g12*g14^-1 ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name ="IntegralConjugate" Arg="G" Label="G"/>
  <Attr Name ="IntegralConjugate" Arg="f" Label="f"/>
  <Returns>
    Some integral conjugate of the tame rcwa group&nbsp;<A>G</A> resp.
    of the tame bijective rcwa mapping&nbsp;<A>f</A> in the group
    RCWA(<M>\mathbb{Z}</M>).
  </Returns>
  <Description>
    Such conjugates exist, see&nbsp;<Cite Key="Kohl05"/>,
    Theorem&nbsp;2.5.14. In general there are infinitely many of them.
<Alt Only="LaTeX">\pagebreak[4]</Alt>
<Example>
<![CDATA[
gap> Display(IntegralConjugate(g));

Bijective rcwa mapping of Z with modulus 7, of order 7

                n mod 7                |                 n^f
---------------------------------------+--------------------------------------
  0                                    | n + 5
  1                                    | n + 3
  2                                    | n + 4
  3 6                                  | n - 3
  4                                    | n - 2
  5                                    | n - 4

gap> RespectedPartition(IntegralConjugate(G));
[ 0(7), 1(7), 2(7), 3(7), 4(7), 5(7), 6(7) ]
gap> Action(IntegralConjugate(G),last);
Group([ (1,6,2,5,3,7,4), (1,6,2,5)(3,7,4) ])
gap> last = ActionOnRespectedPartition(G);
true
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name ="IntegralizingConjugator" Arg="G" Label="G"/>
  <Attr Name ="IntegralizingConjugator" Arg="f" Label="f"/>
  <Returns>
    An rcwa mapping mapping&nbsp;<A>x</A> such that
    <A>G</A>&circum;<A>x</A> resp. <A>f</A>&circum;<A>x</A> is integral. 
  </Returns>
  <Description>
    While there are usually infinitely many such rcwa mappings,
    it is taken care that the returned ones always satisfy the relations
    <C><A>G</A>&circum;IntegralizingConjugator(<A>G</A>) =
    IntegralConjugate(<A>G</A>)</C> resp.
    <C><A>f</A>&circum;IntegralizingConjugator(<A>f</A>) =
    IntegralConjugate(<A>f</A>)</C>.
<Example>
<![CDATA[
gap> Display(IntegralizingConjugator(g));

Bijective rcwa mapping of Z with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0  6                                | 7n/6
   1  7                                | (7n - 1)/6
   2                                   | (7n + 46)/12
   3  9                                | (7n - 9)/6
   4 10                                | (7n - 10)/6
   5 11                                | (7n - 11)/6
   8                                   | (7n + 16)/12

]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:UtilityFunctions">
<Heading>Some general utility functions</Heading>

<Index Key="GeneratorsAndInverses" Subkey="G">
  <C>GeneratorsAndInverses</C>
</Index>
<Index Key="EpimorphismByGenerators" Subkey="G, H">
  <C>EpimorphismByGenerators</C>
</Index>
<Index Key="AllProducts" Subkey="l, k">
  <C>AllProducts</C>
</Index>

&RCWA; introduces a few small utility functions which can be used for groups
in general: The function <C>GeneratorsAndInverses(<A>G</A>)</C> returns
a list of generators of <A>G</A> and their inverses,
<C>EpimorphismByGenerators(<A>G</A>,<A>H</A>)</C> is a shorthand for
<C>GroupHomomorphismByImages(<A>G</A>,<A>H</A>, GeneratorsOfGroup(<A>G</A>),
GeneratorsOfGroup(<A>H</A>))</C> (there is also an <C>NC</C> version of this)
and the function <C>AllProducts(<A>l</A>,<A>k</A>)</C> returns the list of
all products of <A>k</A> entries of the list&nbsp;<A>l</A>.

</Section>

<!-- #################################################################### -->

<Section Label="sec:CategoriesOfRcwaGroups">
<Heading>The categories of rcwa groups</Heading>

<ManSection>
  <Filt Name="IsRcwaGroup" Arg="G" Label="G"/>
  <Filt Name="IsRcwaGroupOverZ" Arg="G" Label="G"/>
  <Filt Name="IsRcwaGroupOverZ_pi" Arg="G" Label="G"/>
  <Filt Name="IsRcwaGroupOverGFqx" Arg="G" Label="G"/>
  <Returns>
    <C>true</C> if <A>G</A> is an rcwa group resp.
    an rcwa group over the ring of integers resp.
    an rcwa group over a semilocalization of the ring of integers resp.
    an rcwa group over a polynomial ring in one variable over a finite field,
    and <C>false</C> otherwise.
  </Returns>
  <Description>

    <Index Key="IsRcwaGroupOverZOrZ_pi" Subkey="G">
      <C>IsRcwaGroupOverZOrZ&uscore;pi</C>
    </Index>

    Often the same methods can be used for rcwa groups over the ring of
    integers and over its semilocalizations. For this reason there is
    a category <C>IsRcwaGroupOverZOrZ&uscore;pi</C> which is the union of
    <C>IsRcwaGroupOverZ</C> and <C>IsRcwaGroupOverZ&uscore;pi</C>.

    <Index Key="IsNaturalRCWA&uscore;Z" Subkey="G">
      <C>IsNaturalRCWA&uscore;Z</C>
    </Index>
    <Index Key="IsNaturalRCWA&uscore;Z&uscore;pi" Subkey="G">
      <C>IsNaturalRCWA&uscore;Z&uscore;pi</C>
    </Index>
    <Index Key="IsNaturalRCWA&uscore;GFqx" Subkey="G">
      <C>IsNaturalRCWA&uscore;GFqx</C>
    </Index>

    To allow distinguishing the entire group RCWA(<M>R</M>) from others
    by means of the method selection, it has the characteristic property
    <C>IsNaturalRCWA&uscore;Z</C> resp. one of the properties
    <C>IsNaturalRCWA&uscore;Z&uscore;pi</C> or
    <C>IsNaturalRCWA&uscore;GFqx</C>, depending on whether <M>R</M>
    is the ring of integers, one of its semilocalizations or a univariate
    polynomial ring over a finite field.

  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->

<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  rcwagrp.xml         RCWA documentation           Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$      ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:RcwaGroups">
<Heading>Residue Class-Wise Affine Groups</Heading>

This chapter describes the functionality available for computing with
rcwa groups. <P/>

<!-- #################################################################### -->

<Section Label="sec:ContructingRcwaGroups">
<Heading>Constructing rcwa groups</Heading>

Rcwa groups can be constructed using either <C>Group</C>,
<C>GroupByGenerators</C> or <C>GroupWithGenerators</C>, as usual
(see the reference manual).
Note that currently except of the whole groups <C>RCWA( <A>R</A> )</C>
only finitely generated rcwa groups are supported.

<Example>
<![CDATA[
gap> g := RcwaMapping([[1,0,1],[1,1,1],[3,6,1],
>                      [1,0,3],[1,1,1],[3,6,1],
>                      [1,0,1],[1,1,1],[3,-21,1]]);;
gap> h := RcwaMapping([[1,0,1],[1,1,1],[3,6,1],
>                      [1,0,3],[1,1,1],[3,-21,1],
>                      [1,0,1],[1,1,1],[3,6,1]]);;
gap> Order(g);
9
gap> Order(h);
9
gap> G := Group(g,h);
<rcwa group over Z with 2 generators>
gap> Size(G);
infinity
]]>
</Example>

Another possible way to get an rcwa group is by <Q>translating</Q> a
permutation group, or by taking the image of an rcwa representation.

<ManSection>
  <Func Name="IntegralRcwaGroupByPermGroup" Arg="G"/>
  <Func Name="RcwaGroupByPermGroup" Arg="G"/>
  <Returns>
    An integral rcwa group isomorphic to the (finite) permutation
    group&nbsp;<A>G</A>, which acts on the range
    <C>[1..LargestMovedPoint(</C><A>G</A><C>)]</C> as <A>G</A> does.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> H := RcwaGroupByPermGroup(Group((1,2),(3,4),(5,6),(7,8),
>                                    (1,3)(2,4),(1,3,5,7)(2,4,6,8)));
<rcwa group over Z with 6 generators>
gap> Size(H);
384
gap> IsSolvable(H);
true
gap> List(DerivedSeries(H),Size);
[ 384, 96, 32, 2, 1 ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="IsomorphismIntegralRcwaGroup" Arg="G"/>
  <Attr Name="IsomorphismRcwaGroup" Arg="G"/>
  <Returns>
    A faithful integral rcwa representation of the group&nbsp;<A>G</A>,
    thus a monomorphism from <A>G</A> to&nbsp;RCWA(<M>\Z</M>).
  </Returns>
  <Description>
    Currently this is only supported for finite groups.
<Example>
<![CDATA[
gap> G := GL(2,5);
GL(2,5)
gap> IsomorphismRcwaGroup(G);
CompositionMapping( 
[ (2,3,5,8)(4,7,12,18)(6,10,17,22)(9,15,21,24)(13,14,19,23), 
  (1,2,4)(3,6,11)(5,9,16)(7,13,12)(8,14,20)(10,18,17)(15,22,21)(19,24,23) 
 ] -> [ <rcwa mapping of Z with modulus 24>, <rcwa mapping of Z with modulus 
    24> ], <action isomorphism> )
]]>
</Example>
  </Description>
</ManSection>

The whole group RCWA(<M>R</M>) of all bijective rcwa mappings of the ring
<M>R</M> is not finitely generated, thus cannot be constructed in one of
the ways described above, but has to be handled as a special case:

<ManSection>
  <Func Name="RCWA" Arg="R"/>
  <Returns>
    The group RCWA(<A>R</A>) of all bijective rcwa mappings
    of the ring&nbsp;<A>R</A>.
  </Returns>
  <Description>
    This group is (at least in general) not finitely generated,
    hence no generators are stored.
<Example>
<![CDATA[
gap> RCWA_Z := RCWA(Integers);
RCWA(Z)
gap> Size(RCWA_Z);
infinity
gap> IsFinitelyGeneratedGroup(RCWA_Z);
false
gap> One(RCWA_Z);
IdentityMapping( Integers )
gap> IsSubgroup(RCWA_Z, Group(RcwaMapping([[-1,0,1]]),
>                             RcwaMapping((1,2,3),[1..4]),
>                             RcwaMapping(2,[[0,1],[1,0],[2,3],[3,2]])));
true
]]>
</Example>
  </Description>
</ManSection>

Once having constructed an rcwa group we can easily take a look at it:

<ManSection>
  <Meth Name="Display" Arg="G"/>
  <Returns> Nothing. </Returns>
  <Description>
    Displays the rcwa group&nbsp;<A>G</A> in a human-readable form.
<Example>
<![CDATA[
gap> a := RcwaMapping([[3,0,2],[3, 1,4],[3,0,2],[3,-1,4]]);; SetName(a,"a");
gap> b := RcwaMapping([[3,0,2],[3,13,4],[3,0,2],[3,-1,4]]);; SetName(b,"b");
gap> c := RcwaMapping([[3,0,2],[3, 1,4],[3,0,2],[3,11,4]]);; SetName(c,"c");
gap> H := Group(a,b);
<rcwa group over Z with 2 generators>
gap> Display(H);

Rcwa group over Z, generated by

[

Bijective rcwa mapping of Z with modulus 4

                n mod 4                |                 n^a
---------------------------------------+--------------------------------------
  0 2                                  | 3n/2
  1                                    | (3n + 1)/4
  3                                    | (3n - 1)/4


Bijective rcwa mapping of Z with modulus 4

                n mod 4                |                 n^b
---------------------------------------+--------------------------------------
  0 2                                  | 3n/2
  1                                    | (3n + 13)/4
  3                                    | (3n - 1)/4

]

]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:AttributesAndProperties">
<Heading>Attributes and properties of rcwa groups</Heading>

<ManSection>
  <Meth Name="Modulus" Arg="G" Label = "Modulus of an rcwa group"/>
  <Meth Name="Mod"     Arg="G"/>
  <Returns> The modulus of the rcwa group&nbsp;<A>G</A>. </Returns>
  <Description>
    For the definition see Chapter&nbsp;<Ref Label="ch:Introduction"/>.

    This can be probabilistic, increase the Info level of <C>InfoRCWA</C>
    (see <Ref Label="sec:TheInfoClass"/>) to get information about the
    methods used in your particular case. In any case if the returned
    modulus is not equal to zero the result is certain.

    See also <Ref Meth="Modulus" Label="Modulus of an rcwa mapping"/>
    for rcwa mappings, and <Ref Prop="IsTame" Label="Tame rcwa group"/>.
<Example>
<![CDATA[
gap> g1 := RcwaMapping((1,2),[1..2]);
<rcwa mapping of Z with modulus 2>
gap> g2 := RcwaMapping((1,2,3),[1..3]);
<rcwa mapping of Z with modulus 3>
gap> g3 := RcwaMapping((1,2,3,4,5),[1..5]);
<rcwa mapping of Z with modulus 5>
gap> G := Group(g1,g2,g3);
<rcwa group over Z with 3 generators>
gap> Modulus(G);
30
gap> Modulus(Group(a,b));
0
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Prop Name="IsTame" Arg="G" Label="Tame rcwa group"/>
  <Returns>
    <C>true</C> if the rcwa group&nbsp;<A>G</A> is tame and <C>false</C>
    otherwise.
  </Returns>
  <Description>
    For the definition when an rcwa group is called <E>tame</E>
    see Chapter&nbsp;<Ref Label="ch:Introduction"/>.

    Methods for determining whether an rcwa group is tame can be
    probabilistic -- increase the Info level of <C>InfoRCWA</C>
    (see <Ref Label="sec:TheInfoClass"/>) to get information about
    the methods used in your particular case. A positive result
    (return value is <C>true</C>) is correct in any case.

    See also <Ref Prop="IsTame" Label="Tame rcwa mapping"/>
    for rcwa mappings.
<Example>
<![CDATA[
gap> IsTame(G);
true
gap> IsTame(Group(a,b));
false
gap> IsTame(Group(Comm(a,b),Comm(a,c)));
true
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="PrimeSet" Arg="G" Label="Prime set of an rcwa group"/>
  <Returns> The prime set of the rcwa group&nbsp;<A>G</A>. </Returns>
  <Description>
    For the definition see Chapter&nbsp;<Ref Label="ch:Introduction"/>.
    See also&nbsp;<Ref Oper="PrimeSet"
                       Label="Prime set of an rcwa mapping"/>
    for rcwa mappings.
<Example>
<![CDATA[
gap> PrimeSet(G);
[ 2, 3, 5 ]
gap> PrimeSet(H);
[ 2, 3 ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Prop Name="IsIntegral" Arg="G" Label="Integral group"/>
  <Returns>
    <C>true</C> if the rcwa group&nbsp;<A>G</A> is integral and
    <C>false</C> otherwise.
  </Returns>
  <Description>
    For the definition see Chapter&nbsp;<Ref Label="ch:Introduction"/>.
    See also&nbsp;<Ref Prop="IsIntegral" Label="Integral mapping"/>
    for rcwa mappings.
  </Description>
</ManSection>

<ManSection>
  <Prop Name ="IsClassWiseOrderPreserving" Arg="G"
        Label="Class-wise order-preserving rcwa group"/>
  <Returns>
    <C>true</C> if the rcwa group&nbsp;<A>G</A> is class-wise
    order-preserving and <C>false</C> otherwise.
  </Returns>
  <Description>
    Of course the term <E>class-wise order-preserving</E> is defined only
    for rcwa groups over ordered rings, e.g. over&nbsp;<M>\Z</M>.
    See also <Ref Prop ="IsClassWiseOrderPreserving"
                  Label="Class-wise order-preserving rcwa mapping"/>
    for rcwa mappings.
<Example>
<![CDATA[
gap> IsClassWiseOrderPreserving(Group(a,b));
true
gap> IsClassWiseOrderPreserving(G);
true
gap> t := RcwaMapping([[-1,0,1]]);;
gap> IsClassWiseOrderPreserving(Group(t,g,h));
false
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:MembershipOrderMatPerm">
<Heading>
  Membership testing, order computation,
  matrix- / permutation representations
</Heading>

<Index Key="rcwa group" Subkey="element testing"></Index>
<ManSection>
  <Meth Name="\in" Arg="g, G"/>
  <Returns>
    <C>true</C> if the rcwa mapping&nbsp;<A>g</A> is an element of the
    rcwa group&nbsp;<A>G</A> and <C>false</C> if not.
  </Returns>
  <Description>
    Tries to figure out whether <A>g</A> is an element of <A>G</A> or not.
    This will be successful if <A>G</A> is tame. For wild groups only a
    number of easy cases are covered. On <C>InfoLevel(InfoRCWA) = 3</C>
    the method will give information about reasons why <A>g</A> is an
    element of <A>G</A> or not.
<Example>
<![CDATA[
gap> u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;
gap> u in H;
false
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="Size" Arg="G"/>
  <Returns> The order of the rcwa group&nbsp;<A>G</A>. </Returns>
  <Description>
    In rare cases this can be probabilistic, increase the Info level of
    <C>InfoRCWA</C> ( see <Ref Label="sec:TheInfoClass"/> ) to get
    information about the methods used in the particular case.
<Example>
<![CDATA[
gap> Size(G);
265252859812191058636308480000000
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="IsomorphismPermGroup" Arg="G"/>
  <Returns>
    An isomorphism from the finite rcwa group&nbsp;<A>G</A> to some
    permutation group.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> H := Group(g1,g2);
<rcwa group over Z with 2 generators>
gap> phi := IsomorphismPermGroup(H);
[ <bijective rcwa mapping of Z with modulus 2, of order 2>, 
  <bijective rcwa mapping of Z with modulus 3, of order 3> ] -> 
[ (1,6)(2,3)(4,5), (1,5,6)(2,3,4) ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="IsomorphismMatrixGroup" Arg="G"/>
  <Returns>
    An isomorphism from the rcwa group&nbsp;<A>G</A> to some matrix group.
  </Returns>
  <Description>
    The group <A>G</A> must be tame.
    The implemented algorithm uses the classification of groups having
    faithful tame <M>R</M>-rcwa representations.
<Example>
<![CDATA[
gap> g := RcwaMapping([[2,2,1],[1, 4,1],[1,0,2],[2,2,1],[1,-4,1],[1,-2,1]]);;
gap> h := RcwaMapping([[2,2,1],[1,-2,1],[1,0,2],[2,2,1],[1,-1,1],[1, 1,1]]);;
gap> SetName(g,"g"); SetName(h,"h");
gap> G := Group(g,h);
<rcwa group over Z with 2 generators>
gap> phi := IsomorphismMatrixGroup(G);;
gap> FieldOfMatrixGroup(Image(phi));
Rationals
gap> DegreeOfMatrixGroup(Image(phi));
28
gap> List(GeneratorsOfGroup(Image(phi)),Order);
[ 7, 12 ]
gap> Display(GeneratorsOfGroup(Image(phi))[1]*One(GF(5)));
 . . . . . . 1 1 . . . . . . . . . . . . . . . . . . . .
 . . . . . . . 1 . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . 3 . . . . . . .
 . . . . . . . . . . . . . . . . . . . . . 1 . . . . . .
 . . . . . . . . 1 3 . . . . . . . . . . . . . . . . . .
 . . . . . . . . . 1 . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . . . 3 . . . . .
 . . . . . . . . . . . . . . . . . . . . . . . 1 . . . .
 . . 1 4 . . . . . . . . . . . . . . . . . . . . . . . .
 . . . 1 . . . . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . . . 1 1 . . . . . . . . . .
 . . . . . . . . . . . . . . . . . 1 . . . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . . . . . 3 . . .
 . . . . . . . . . . . . . . . . . . . . . . . . . 1 . .
 . . . . . . . . . . . . . . . . . . 1 3 . . . . . . . .
 . . . . . . . . . . . . . . . . . . . 1 . . . . . . . .
 . . . . . . . . . . . . . . . . . . . . . . . . . . 3 .
 . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
 . . . . . . . . . . . . 1 4 . . . . . . . . . . . . . .
 . . . . . . . . . . . . . 1 . . . . . . . . . . . . . .
 2 2 . . . . . . . . . . . . . . . . . . . . . . . . . .
 . 1 . . . . . . . . . . . . . . . . . . . . . . . . . .
 . . . . 2 2 . . . . . . . . . . . . . . . . . . . . . .
 . . . . . 1 . . . . . . . . . . . . . . . . . . . . . .
 . . . . . . . . . . 2 2 . . . . . . . . . . . . . . . .
 . . . . . . . . . . . 1 . . . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . 2 2 . . . . . . . . . . . .
 . . . . . . . . . . . . . . . 1 . . . . . . . . . . . .
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ElementFactorization">
<Heading>
  Factoring elements into generators
</Heading>

<ManSection>
  <Meth Name ="PreImagesRepresentative" Arg="phi, g"
        Label="PreImagesRepresentative (element factorization)"/>
  <Returns>
    A representative of the set of preimages of&nbsp;<A>g</A> under
    the homomorphism&nbsp;<A>phi</A> from a free group to an rcwa group
    over&nbsp;<M>\mathbb{Z}</M>.
  </Returns>
  <Description>
    This method can be used for factoring elements of rcwa groups
    over <M>\mathbb{Z}</M> into generators and for finding non-trivial
    relations among the generators if the respective group is not free
    and the method returns a factorization which does not happen to be
    equal to one which is known a priori.
    The homomorphism <A>phi</A> must map the generators of the free
    group to the generators of the rcwa group one-by-one.
    This method is also suitable for wild groups. The implementation
    is based on <Ref Oper="RepresentativeActionPreImage"/>.
<Example>
<![CDATA[
gap> G := Group(g,h);
<rcwa group over Z with 2 generators>
gap> phi := EpimorphismFromFreeGroup(G);
[ g, h ] -> [ g, h ]
gap> PreImagesRepresentative(phi,h*g^3*h^2*g^-1*h*g*h^-3);
h*g^3*h^2*g^-1*h*g*h^-3
gap> nu := RcwaMapping([[1,1,1]]);
Rcwa mapping of Z: n -> n + 1
gap> SetName(nu,"nu");
gap> G := Group(a,nu);
<rcwa group over Z with 2 generators>
gap> IsTame(G);
false
gap> phi := EpimorphismFromFreeGroup(G);
[ a, nu ] -> [ a, nu ]
gap> F := Source(phi);
<free group on the generators [ a, nu ]>
gap> w := Comm(F.1,Comm(F.1,F.2^2));
a^-1*nu^-2*a^-1*nu^2*a*nu^-2*a*nu^2
gap> f := w^phi;
<bijective rcwa mapping of Z with modulus 18>
gap> IsTame(f);
false
gap> pre := PreImagesRepresentative(phi,f);
a^-2*nu^-2*a^2*nu^2
gap> one := w*pre^-1; # pre <> w --> We have a non-trivial relation!
a^-1*nu^-2*a^-1*nu^2*a*nu^-2*a^-1*nu^2*a^2
gap> one^phi;
IdentityMapping( Integers )
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name ="PreImagesRepresentatives" Arg="phi, g"/>
  <Returns>
    A list of representatives of the set of preimages of&nbsp;<A>g</A>
    under the homomorphism&nbsp;<A>phi</A> from a free group to an rcwa
    group over&nbsp;<M>\mathbb{Z}</M>.
  </Returns>
  <Description>
    Quite frequently, computing several preimages is not harder than
    computing just one, i.e. often several preimages are found
    simultaneously. This operation is called by
    <Ref Meth ="PreImagesRepresentative"
         Label="PreImagesRepresentative (element factorization)"/>,
    which simply chooses the shortest representative -- for a slightly
    more concise description see there.
<Example>
<![CDATA[
gap> G := Group(g,h);
<rcwa group over Z with 2 generators>
gap> phi := EpimorphismFromFreeGroup(G);
[ g, h ] -> [ g, h ]
gap> f := g^3*h*g^-4*h^5*g;
<bijective rcwa mapping of Z with modulus 12>
gap> RCWAInfo(2);
gap> pre := PreImagesRepresentatives(phi,f);
#I  Orbit lengths after extension step 1: [ 4, 5 ]
#I  |Candidates| = 1
#I  Orbit lengths after extension step 1: [ 5, 5 ]
#I  Orbit lengths after extension step 2: [ 17, 15 ]
#I  Orbit lengths after extension step 3: [ 52, 39 ]
#I  |Candidates| = 1
#I  Orbit lengths after extension step 1: [ 5, 5 ]
#I  Orbit lengths after extension step 2: [ 17, 15 ]
#I  Orbit lengths after extension step 3: [ 53, 43 ]
#I  Orbit lengths after extension step 4: [ 158, 119 ]
#I  |Candidates| = 1
#I  Orbit lengths after extension step 1: [ 5, 5 ]
#I  Orbit lengths after extension step 2: [ 17, 17 ]
#I  Orbit lengths after extension step 3: [ 53, 53 ]
#I  Orbit lengths after extension step 4: [ 159, 158 ]
#I  Orbit lengths after extension step 5: [ 472, 462 ]
#I  Orbit lengths after extension step 6: [ 1356, 1309 ]
#I  Orbit lengths after extension step 7: [ 3822, 3643 ]
#I  |Candidates| = 11
[ g^3*h*g^3*h^5*g, g^-3*h^-4*g^-3*h^-1*g*h*g, g^3*h*g^-4*h^5*g ]
gap> RCWAInfo(0);
gap> List(pre,Length);
[ 13, 14, 14 ]
gap> Set(List(pre,w->w^phi)) = [f];
true
gap> w := pre[1]*pre[2]^-1;
g^3*h*g^3*h^4*g^-1*h*g^3*h^4*g^3
gap> Length(w);
23
gap> w^phi; # A relation of length 23.
IdentityMapping( Integers )
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ActionOnR">
<Heading>The action of an rcwa group on the underlying ring R</Heading>

In some cases -- in particular in the case that the group in question is
tame -- we can test for transitivity on the underlying ring. We can also
determine group elements which map a given tuple of elements of the
underlying ring to a given other tuple, in case such elements exist.

<ManSection>
  <Meth Name="MovedPoints" Arg="G"/>
  <Returns>
    The set of moved points (support) of the rcwa group&nbsp;<A>G</A>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> ResidueClassUnionViewingFormat("short");
gap> MovedPoints(Group(Comm(a,b),Comm(a,c)));
1(3) U 2(3) U 3(9) U 6(9)
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="IsTransitive" Arg="G, Integers"/>
  <Returns>
    <C>true</C> if the rcwa group&nbsp;<A>G</A> acts transitive
    on&nbsp;<M>\Z</M> and <C>false</C> otherwise.
  </Returns>
  <Description>
    Depending on the particular group this might fail or run into an
    infinite loop, but for tame groups things should work.
<Log>
<![CDATA[
gap> G := Group(g,h);;
gap> RCWAInfo(3);
gap> IsTransitive(G,Integers);
#I  IsTransitive: testing for finiteness and searching short orbits ...
#I  IsTame: balancedness criterion.
#I  IsTame:`dead end' criterion.
#I  IsTame: loop criterion.
#I  IsTame:`finite order or integral power' criterion.
#I  IsTame: balancedness criterion.
#I  IsTame:`dead end' criterion.
#I  IsTame: loop criterion.
#I  IsTame:`finite order or integral power' criterion.
#I  IsTame: balancedness criterion.
#I  IsTame:`dead end' criterion.
#I  IsTame: loop criterion.
#I  IsTame:`finite order or integral power' criterion.
#I  Order: the 2nd power of the argument is RcwaMapping(
[ [ 1, -3, 1 ], [ 1, -3, 1 ], [ 1, 12, 1 ], [ 2, 2, 1 ], [ 1, -4, 1 ],
  [ 1, 6, 1 ], [ 1, -3, 1 ], [ 1, -3, 1 ], [ 1, -6, 2 ], [ 2, 2, 1 ],
  [ 1, -4, 1 ], [ 1, 6, 1 ] ] );
There is a `class shift' on the residue class 2(12).
#I  IsTame: balancedness criterion.
#I  IsTame:`dead end' criterion.
#I  IsTame: loop criterion.
#I  IsTame:`finite order or integral power' criterion.
#I  IsTame: balancedness criterion.
#I  IsTame:`dead end' criterion.
#I  IsTame: loop criterion.
#I  IsTame:`finite order or integral power' criterion.
#I  IsTame: balancedness criterion.
#I  IsTame:`dead end' criterion.
#I  IsTame: loop criterion.
#I  IsTame:`finite order or integral power' criterion.
#I  Order: the 4th power of the argument is RcwaMapping(
[ [ 1, 12, 1 ], [ 1, 12, 1 ], [ 1, -6, 2 ], [ 2, -10, 1 ], [ 1, -7, 1 ],
  [ 2, -8, 1 ], [ 1, 12, 1 ], [ 1, 12, 1 ], [ 1, -10, 2 ], [ 2, -10, 1 ],
  [ 1, -7, 1 ], [ 2, -8, 1 ] ] );
There is a `class shift' on the residue class 0(12).
#I  Trying probabilistic random walk, initial m = 12
#I  checking modulus ...
#I  Size: use action on respected class partition.
#I  KernelOfActionOnClassPartition: gen. #1, lng = 1
#I  KernelOfActionOnClassPartition: gen. #2, lng = 2
#I  KernelOfActionOnClassPartition: gen. #4, lng = 3
#I  KernelOfActionOnClassPartition: gen. #5, lng = 4
#I  KernelOfActionOnClassPartition: gen. #7, lng = 5
#I  KernelOfActionOnClassPartition: gen. #8, lng = 6
#I  KernelOfActionOnClassPartition: gen. #10, lng = 7
#I  KernelOfActionOnClassPartition: gen. #12, lng = 8
#I  KernelOfActionOnClassPartition: gen. #13, lng = 9
#I  KernelOfActionOnClassPartition: gen. #14, lng = 10
#I  Searching for class shifts ...
#I  ... in generators
#I  ... in commutators of the generators
#I  The cyclic group generated by RcwaMapping(
[ [ 1, -9, 1 ], [ 1, 0, 1 ], [ 1, 6, 1 ], [ 1, -3, 1 ], [ 1, 0, 1 ],
  [ 1, 6, 1 ] ] ) acts transitively on the residue class 2(6).
#I  OrbitUnion: initial set = ResidueClassUnion( Integers, 6, [ 2 ] )
#I  Image = Integers
true
gap> RCWAInfo(0);
]]>
</Log>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="RepresentativeAction" Arg="G, src, dest, act"/>
  <Returns>
    An element of <A>G</A> that maps <A>src</A> to&nbsp;<A>dest</A>
    under the action given by&nbsp;<A>act</A>.
  </Returns>
  <Description>
    If an element satisfying this condition does not exist, this method
    either returns <C>fail</C> or runs into an infinite loop.
    The problem of whether <A>src</A> and <A>dest</A> lie in the same
    orbit under the action of <A>G</A> in general is likely to be
    computationally undecidable. The given method is based on
    <Ref Oper="RepresentativeActionPreImage"/>, and it basically just
    computes an image under an homomorphism. As this involves
    multiplications of rcwa mappings, this can be quite expensive if
    the group <A>G</A> is wild, the preimage is a rather long word and
    coefficient explosion occurs.
<Example>
<![CDATA[
gap> G := Group(a,b);
<rcwa group over Z with 2 generators>
gap> g := RepresentativeAction(G,[7,4,9],[4,5,13],OnTuples);
<bijective rcwa mapping of Z with modulus 12>
gap> Display(g);

Bijective rcwa mapping of Z with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0  2  3  6  8 11                    | n
   1  7 10                             | n - 3
   4                                   | n + 1
   5  9                                | n + 4

gap> List([7,4,9],n->n^g);
[ 4, 5, 13 ]
gap> g := RepresentativeAction(G,[5,4,9],[13,5,4],OnTuples);
<bijective rcwa mapping of Z with modulus 9>
gap> Display(g);

Bijective rcwa mapping of Z with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0                                    | 4n/9
  1                                    | (8n - 26)/9
  2                                    | (8n + 2)/9
  3                                    | (8n + 3)/9
  4                                    | (16n - 19)/9
  5                                    | (16n + 37)/9
  6                                    | (8n + 33)/9
  7                                    | (16n - 49)/9
  8                                    | (16n + 7)/9

gap> List([5,4,9],n->n^g);
[ 13, 5, 4 ]
gap> g := RepresentativeAction(G,[7,4,9],[4,5,8],OnTuples);
<bijective rcwa mapping of Z with modulus 256>
gap> List([7,4,9],n->n^g);
[ 4, 5, 8 ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="RepresentativeActionPreImage" Arg="G, src, dest, act, F"/>
  <Returns>
    The result of <C>RepresentativeAction( <A>G</A>, <A>src</A>,
    <A>dest</A>, <A>act</A> )</C> as a word in the generators.
  </Returns>
  <Description>
    The argument <A>F</A> is a free group to be used to express the
    resulting word. Note that the dependency is just the other way round
    than suggested above (<C>RepresentativeAction</C> calls
    <C>RepresentativeActionPreImage</C>) and that the evaluation of the
    word sometimes takes much more time than its determination (the latter
    however depends very much on the particular case and is hard to
    predict). This causes <C>RepresentativeActionPreImage</C> sometimes to
    be much faster than <C>RepresentativeAction</C>.
    The employed algorithm is not inefficient, as the last two of the
    examples below suggest -- it is based on separate progressive
    computations of the orbits of <A>src</A> and <A>dest</A> until they
    intersect non-trivially. It avoids multiplying rcwa mappings.
    Of course the other warnings given in the description of
    <Ref Meth="RepresentativeAction"/> apply to this operation, too.
<Example>
<![CDATA[
gap> F := FreeGroup("a","b");;
gap> w := RepresentativeActionPreImage(G,[7,4,9],[4,5,13],OnPoints,F);
b^-1*a*b*a^-1
gap> w := RepresentativeActionPreImage(G,[5,4,9],[13,5,4],OnTuples,F);
b^-1*a^-1*b*a^-1
gap> w := RepresentativeActionPreImage(G,[7,4,9],[4,5,8],OnPoints,F);
b^2*a^2
gap> phi := GroupHomomorphismByImages(F,G,[F.1,F.2],[a,b]);
[ a, b ] -> [ a, b ]
gap> w^phi;
<bijective rcwa mapping of Z with modulus 256>
gap> w^phi = RepresentativeAction(G,[7,4,9],[4,5,8],OnPoints);
true
gap> List([7,4,9],n->n^(w^phi));
[ 4, 5, 8 ]
gap> w := RepresentativeActionPreImage(G,[37,4,9],[4,51,8],OnPoints,F);
a^-1*b^-1*a*b^4*a
gap> w^phi;
<bijective rcwa mapping of Z with modulus 4608>
gap> w := RepresentativeActionPreImage(G,[37,4,9],[4,51,8],OnTuples,F);
b*a^6*b*a^-3*b^-3*a^-1*b*a^2
gap> w := RepresentativeActionPreImage(G,[17,14,9],[4,51,8],OnPoints,F);
a^-1*b^-1*a^3*b^2*a*b*a*b^-1*a^2
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="RepresentativeAction" Arg="G, P1, P2"/>
  <Returns>
    An element of <A>G</A> which maps the partition&nbsp;<A>P1</A>
    to&nbsp;<A>P2</A>.
  </Returns>
  <Description>
    The arguments <A>P1</A> and <A>P2</A> must be partitions of the
    underlying ring <M>R</M> into the same number of disjoint
    residue classes.
    This method covers the case <M>R = \mathbb{Z}</M> and
    <C><A>G</A> = RCWA( Integers )</C>.
    It recognizes the option <C>IsTame</C> -- if this option is set,
    the returned mapping is tame provided that there is a tame
    mapping satisfying the required condition.
<Example>
<![CDATA[
gap> rc := function(r,m) return ResidueClass(DefaultRing(m),m,r); end;;
gap> P1 := [rc(0,3),rc(1,3),rc(2,9),rc(5,9),rc(8,9)];
[ 0(3), 1(3), 2(9), 5(9), 8(9) ]
gap> P2 := [rc(0,2),rc(1,8),rc(5,16),rc(3,4),rc(13,16)];
[ 0(2), 1(8), 5(16), 3(4), 13(16) ]
gap> elm := RepresentativeAction(RCWA(Integers),P1,P2);
<rcwa mapping of Z with modulus 9>
gap> Display(elm);

Rcwa mapping of Z with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0 3 6                                | 2n/3
  1 4 7                                | (8n - 5)/3
  2                                    | (16n + 13)/9
  5                                    | (4n + 7)/9
  8                                    | (16n - 11)/9

gap> P1^elm = P2;
true
gap> elm := RepresentativeAction(RCWA(Integers),P1,P2:IsTame);
<tame rcwa mapping of Z with modulus 1152>
gap> P := RespectedClassPartition(elm);;
gap> Length(P);
313
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="ShortOrbits" Arg="G, S, maxlng"/>
  <Returns>
    A list of all finite orbits of the rcwa group&nbsp;<A>G</A> of maximal
    length&nbsp;<A>maxlng</A>, which intersect non-trivially with the
    set&nbsp;<A>S</A>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> A5 := IntegralRcwaGroupByPermGroup(AlternatingGroup(5));;
gap> ShortOrbits(A5,[-10..10],100);
[ [ -14, -13, -12, -11, -10 ], [ -9, -8, -7, -6, -5 ], [ -4, -3, -2, -1, 0 ], 
  [ 1, 2, 3, 4, 5 ], [ 6, 7, 8, 9, 10 ] ]
gap> Action(A5,last[2]);
Group([ (1,2,3,4,5), (3,4,5) ])
gap> ab := Comm(a,b);; ac := Comm(a,c);;
gap> G := Group(ab,ac);;
gap> orb := ShortOrbits(G,[-20..20],100);
[ [ -51, -48, -42, -39, -25, -23, -22, -20, -19, -17 ], [ -18 ], 
  [ -33, -30, -24, -21, -16, -14, -13, -11, -10, -8 ], 
  [ -15, -12, -7, -6, -5, -4, -3, -2, -1, 1 ], [ -9 ], [ 0 ], 
  [ 2, 3, 4, 5, 6, 7, 8, 10, 12, 15 ], [ 9 ], 
  [ 11, 13, 14, 16, 17, 19, 21, 24, 30, 33 ], [ 18 ], 
  [ 20, 22, 23, 25, 26, 28, 39, 42, 48, 51 ] ]
gap> Action(G,orb[1]);
Group([ (2,6,8,10,4,7), (1,5,7,9,3,6) ])
gap> ShortOrbits(Group(u),[-30..30],100);
[ [ -13, -8, -7, -5, -4, -3, -2 ], [ -10, -6 ], [ -1 ], [ 0 ], [ 1, 2 ], 
  [ 3, 5 ], [ 24, 36, 39, 40, 44, 48, 60, 65, 67, 71, 80, 86, 93, 100, 112, 
      128, 138, 155, 167, 187, 230, 248, 312, 446, 520, 803, 867, 1445 ] ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name ="OrbitsModulo" Arg="G, m"
        Label="OrbitsModulo for rcwa group"/>
  <Returns>
    `The set of orbits on the set of residue classes (mod&nbsp;<A>m</A>)
    under the action of&nbsp;<A>G</A>'.
  </Returns>
  <Description>
    This method computes a partition of <C>AllResidues(R,<A>m</A>)</C>
    such that <M>i</M> and <M>j</M> lie in the same subset if and only if
    there is an element <M>g</M> in <A>G</A> such that <M>M_{i,j} \neq 0</M>,
    where <M>M</M> is the transition matrix of&nbsp;<M>g</M>
    for modulus&nbsp;<A>m</A> (see <Ref Func="TransitionMatrix"/>)
    and <C>R</C> is the ring the group <A>G</A> acts on. <P/>

    See also <Ref Oper ="OrbitsModulo"
                  Label="OrbitsModulo for rcwa mapping"/>
    for rcwa mappings.
<Example>
<![CDATA[
gap> OrbitsModulo(G,72);
[ [ 0 ], [ 1, 29, 31, 32, 34, 35, 37, 57, 60, 65, 66, 67, 68, 69, 70, 71 ], 
  [ 2, 3, 4, 5, 6, 7, 8, 10, 12, 15, 38, 40, 41, 43, 44, 46 ], [ 9 ], 
  [ 11, 13, 14, 16, 17, 19, 21, 24, 30, 33, 47, 49, 50, 52, 53, 55 ], [ 18 ], 
  [ 20, 22, 23, 25, 26, 28, 39, 42, 48, 51, 56, 58, 59, 61, 62, 64 ], [ 27 ], 
  [ 36 ], [ 45 ], [ 54 ], [ 63 ] ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:MethodsForTameGroups">
<Heading>Special features for tame rcwa groups</Heading>

<ManSection>
  <Attr Name ="RespectedClassPartition" Arg="sigma"
        Label="Respected class partition of rcwa mapping"/>
  <Returns>
    A <E>respected partition</E> of <A>sigma</A>, i.e. a partition of the
    base ring&nbsp;<M>R</M> into a finite number of residue classes on
    which the bijective mapping&nbsp;<A>sigma</A> acts as a permutation,
    and on those elements&nbsp;<A>sigma</A> is affine.
  </Returns>
  <Description>
    Such a partition exists if and only if <A>sigma</A>&nbsp;is tame.
    See also <Ref Attr="RespectedClassPartition"
                  Label="Respected class partition of rcwa group"/>
    for rcwa groups.
<Example>
<![CDATA[
gap> g := RcwaMapping([[2,2,1],[1, 4,1],[1,0,2],[2,2,1],[1,-4,1],[1,-2,1]]);;
gap> rcp := RespectedClassPartition(g);
[ 0(12), 1(12), 3(12), 4(12), 5(12), 6(12), 7(12), 9(12), 10(12), 11(12), 
  2(24), 8(24), 14(24), 20(24) ]
gap> Permutation(g,rcp);
(1,11,2,5,3,12,4)(6,13,7,10,8,14,9)
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name ="RespectedClassPartition" Arg="G"
        Label="Respected class partition of rcwa group"/>
  <Returns>
    A <E>respected partition</E> of <A>G</A>, i.e. a partition of the
    base ring&nbsp;<M>R</M> into a finite number of residue classes on
    which the group&nbsp;<A>G</A> acts as a permutation group, and on
    those elements all elements of&nbsp;<A>G</A> are affine.
  </Returns>
  <Description>
    The partition is non-trivial provided that the modulus of&nbsp;<A>G</A>
    is not equal to&nbsp;1. Such a partition exists if and only
    if&nbsp;<A>G</A> is tame.
    See also <Ref Attr ="RespectedClassPartition"
                  Label="Respected class partition of rcwa mapping"/>
    for rcwa mappings.
<Example>
<![CDATA[
gap> g := RcwaMapping([[2,2,1],[1, 4,1],[1,0,2],[2,2,1],[1,-4,1],[1,-2,1]]);;
gap> h := RcwaMapping([[2,2,1],[1,-2,1],[1,0,2],[2,2,1],[1,-1,1],[1, 1,1]]);;
gap> SetName(g,"g");; SetName(h,"h");;
gap> G := Group(g,h);;
gap> Size(G);
infinity
gap> rcp := RespectedClassPartition(G);
[ 0(12), 1(12), 3(12), 4(12), 5(12), 6(12), 7(12), 9(12), 10(12), 11(12), 
  2(24), 8(24), 14(24), 20(24) ]
gap> Display(G);

Tame rcwa group over Z of size infinity, generated by

[

Bijective rcwa mapping of Z with modulus 6, of order 7

                n mod 6                |                 n^g
---------------------------------------+--------------------------------------
  0 3                                  | 2n + 2
  1                                    | n + 4
  2                                    | n/2
  4                                    | n - 4
  5                                    | n - 2


Bijective rcwa mapping of Z with modulus 6, of order 12

                n mod 6                |                 n^h
---------------------------------------+--------------------------------------
  0 3                                  | 2n + 2
  1                                    | n - 2
  2                                    | n/2
  4                                    | n - 1
  5                                    | n + 1

]

]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="ActionOnClassPartition" Arg="G"/>
  <Returns>
    The action of the tame rcwa group&nbsp;<A>G</A> on
    <C>RespectedClassPartition(<A>G</A>)</C>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> H := ActionOnClassPartition(G);
Group([ (1,11,2,5,3,12,4)(6,13,7,10,8,14,9), (1,11,2,10)(3,12,4)(5,6,13,7)(8,
    14,9) ])
gap> H = Action(G,rcp);
true
gap> Size(H);
322560
gap> D := DerivedSubgroup(H);;
gap> Size(D);
161280
gap> IsPerfect(D);
true
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="RankOfKernelOfActionOnClassPartition" Arg="G"/>
  <Returns>
    The rank of the largest free abelian subgroup of the kernel of the
    action of the tame rcwa group&nbsp;<A>G</A> on the set of residue
    classes <C>RespectedClassPartition(<A>G</A>)</C>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> RankOfKernelOfActionOnClassPartition(G);
6
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="KernelOfActionOnClassPartition" Arg="G"/>
  <Returns>
    The kernel of the action of the tame rcwa group&nbsp;<A>G</A> on
    <C>RespectedClassPartition(<A>G</A>)</C>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> K := KernelOfActionOnClassPartition(G);
<rcwa group over Z with 6 generators>
gap> Modulus(K);
12
gap> IsAbelian(K);
true
gap> List(GeneratorsOfGroup(K),k->Factorization(G,k));
[ h^-3*g^2*h^-1*g^-1*h*g*h, g^3*h^2*g^-1*h^-1*g*h*g^2, 
  g^-1*h^-2*g^2*h^-1*g^-1*h*g^2, g^-3*h^-1*g*h*g^-2*h^2*g^2, 
  h^-3*g^3*h^-2*g^-1*h*g^2, g^2*h^-1*g^-1*h*g*h^-2 ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="KernelOfActionOnClassPartitionHNFMat" Arg="G"/>
  <Returns>
    A matrix of vectors in Hermite Normal Form spanning the lattice
    corresponding to the kernel of the action of the tame rcwa
    group&nbsp;<A>G</A> on <C>RespectedClassPartition(<A>G</A>)</C>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> L := KernelOfActionOnClassPartitionHNFMat(G);
[ [ 12, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, -24, 0, -24 ], 
  [ 0, 12, 0, 0, 0, 0, 12, 0, 0, 0, 0, -24, 0, -24 ], 
  [ 0, 0, 12, 0, 0, 0, 0, 12, 0, 0, 0, -24, 0, -24 ], 
  [ 0, 0, 0, 12, 0, 0, 0, 0, 12, 0, 0, -24, 0, -24 ], 
  [ 0, 0, 0, 0, 12, 0, 0, 0, 0, 12, 0, -24, 0, -24 ], 
  [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, -24, 24, -24 ] ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="IsSolvable" Arg="G"/>
  <Returns>
    <C>true</C> if the rcwa group&nbsp;<A>G</A> is solvable, and
    <C>false</C> otherwise.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> IsSolvable(G);
false
gap> Size(G);
infinity
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="IsPerfect" Arg="G"/>
  <Returns>
    <C>true</C> if the rcwa group&nbsp;<A>G</A> is perfect, and
    <C>false</C> otherwise.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> IsPerfect(G);
false
gap> D := DerivedSubgroup(G);
<tame rcwa group over Z with 7 generators, of size infinity>
gap> IsPerfect(D);
true
gap> Size(D);
infinity
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ConjugacyInRCWA_R">
<Heading>Conjugacy in RCWA(R)</Heading>

<ManSection>
  <Meth Name="IsConjugate" Arg="G, f, g"/>
  <Returns>
    <C>true</C> if the bijective rcwa mappings <A>f</A> and&nbsp;<A>g</A>
    are conjugate in the rcwa group&nbsp;<A>G</A>, and <C>false</C>
    otherwise.
  </Returns>
  <Description>
    Currently there are methods only for very few cases, e.g. for
    determining conjugacy of tame mappings in the whole group
    <C>RCWA(Integers)</C> and for handling other <Q>easy</Q> cases. <P/>

    This may fail or run into an infinite loop.
<Example>
<![CDATA[
gap> IsConjugate(RCWA(Integers),g,g^a);
true
gap> IsConjugate(RCWA(Integers),a,b);
false
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Meth Name="RepresentativeAction" Arg="G, f, g"/>
  <Returns>
    An rcwa mapping&nbsp;<C>x</C> such that
    <C><A>f</A>&circum;x = <A>g</A></C>, if such an <C>x</C>
    exists and <C>fail</C> otherwise.
  </Returns>
  <Description>
    This method covers the case that <C><A>G</A> = RCWA(Integers)</C>
    and <A>f</A> and&nbsp;<A>g</A> are tame rcwa mappings of&nbsp;<M>\Z</M>.
<Example>
<![CDATA[
gap> elm := RepresentativeAction(RCWA(Integers),h,h^g);
<bijective rcwa mapping of Z with modulus 24>
gap> h^elm = h^g; # check ...
true
gap> Order(elm);
10
gap> cent := g*elm^-1;
<bijective rcwa mapping of Z with modulus 24>
gap> Comm(cent,h); # cent must lie in the centralizer of h in RCWA(Z)
IdentityMapping( Integers )
gap> Order(cent);
12
gap> Display(cent);

Bijective rcwa mapping of Z with modulus 24, of order 12

               n mod 24                |                 n^f
---------------------------------------+--------------------------------------
   0  4 10 12 16 22                    | n - 1
   1 13                                | 2n
   2                                   | (n - 2)/2
   3  9 15 21                          | 2n + 2
   5  6  7 14 17 18 19                 | n
   8 20                                | n/2
  11 23                                | n + 2

]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name ="IntegralConjugate" Arg="f"
        Label="Integral conjugate of rcwa mapping"/>
  <Returns>
    Some integral representative of the conjugacy class of the tame
    bijective rcwa mapping&nbsp;<A>f</A> in the whole group RCWA(<M>R</M>).
  </Returns>
  <Description>
    Such a representative exists if the ring&nbsp;<M>R</M> has residue
    class rings of any finite cardinality.
    Since the result is not defined uniquely, methods for this
    operation will just choose one such mapping.
    See also <Ref Attr ="IntegralConjugate"
                  Label="Integral conjugate of rcwa group"/>
    for rcwa groups.
<Example>
<![CDATA[
gap> g_int := IntegralConjugate(g);;
gap> Display(g_int);

Bijective rcwa mapping of Z with modulus 14, of order 7

               n mod 14                |                 n^f
---------------------------------------+--------------------------------------
   0                                   | n + 10
   1  6                                | n + 3
   2                                   | n + 9
   3  8                                | n - 3
   4  9                                | n - 2
   5                                   | n + 7
   7                                   | n + 6
  10                                   | n - 9
  11                                   | n - 8
  12                                   | n - 6
  13                                   | n - 5

]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name ="IntegralConjugate" Arg="G"
        Label="Integral conjugate of rcwa group"/>
  <Returns>
    Some integral conjugate of the tame rcwa group&nbsp;<A>G</A>
    in the whole group RCWA(<M>R</M>).
  </Returns>
  <Description>
    Since this is not defined uniquely, methods
    for this operation will just choose one such group.
    See also <Ref Attr ="IntegralConjugate"
                  Label="Integral conjugate of rcwa mapping"/>
    for rcwa mappings.
<Example>
<![CDATA[
gap> F := IntegralConjugate(G);
<rcwa group over Z with 2 generators, of size infinity>
gap> Display(F);

Rcwa group over Z of size infinity, generated by

[

Bijective rcwa mapping of Z with modulus 14, of order 7

               n mod 14                |                 n^f
---------------------------------------+--------------------------------------
   0                                   | n + 10
   1  6                                | n + 3
   2                                   | n + 9
   3  8                                | n - 3
   4  9                                | n - 2
   5                                   | n + 7
   7                                   | n + 6
  10                                   | n - 9
  11                                   | n - 8
  12                                   | n - 6
  13                                   | n - 5


Bijective rcwa mapping of Z with modulus 14, of order 12

               n mod 14                |                 n^f
---------------------------------------+--------------------------------------
   0                                   | n + 10
   1 12                                | n - 6
   2                                   | n + 9
   3  8                                | n - 1
   4                                   | n + 1
   5                                   | n + 7
   6                                   | n - 2
   7                                   | n + 6
   9                                   | n + 5
  10                                   | n - 9
  11                                   | n - 8
  13                                   | n - 5

]

]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name ="IntegralizingConjugator" Arg="f"
        Label="Integralizing conjugator of rcwa mapping"/>
  <Returns>
    An rcwa mapping mapping&nbsp;<A>x</A> such that
    <A>f</A>&circum;<A>x</A> is integral. 
  </Returns>
  <Description>
    This is of course not defined uniquely, but it holds that
    <C><A>f</A>&circum;IntegralizingConjugator(<A>f</A>) =
    IntegralConjugate(<A>f</A>)</C>.
    See also <Ref Attr ="IntegralizingConjugator"
                  Label="Integralizing conjugator of rcwa group"/>
    for rcwa groups.
<Example>
<![CDATA[
gap> g_to_int := IntegralizingConjugator(g);;
gap> Display(g_to_int);

Bijective rcwa mapping of Z with modulus 24

               n mod 24                |                 n^f
---------------------------------------+--------------------------------------
   0 12                                | 7n/6
   1 13                                | (7n - 1)/6
   2                                   | (7n + 106)/12
   3 15                                | (7n - 9)/6
   4 16                                | (7n - 10)/6
   5 17                                | (7n - 11)/6
   6 18                                | (7n - 12)/6
   7 19                                | (7n - 13)/6
   8                                   | (7n + 76)/12
   9 21                                | (7n - 21)/6
  10 22                                | (7n - 22)/6
  11 23                                | (7n - 23)/6
  14                                   | (7n + 46)/12
  20                                   | (7n + 16)/12

gap> g^g_to_int = g_int;
true
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Attr Name ="IntegralizingConjugator" Arg="G"
        Label="Integralizing conjugator of rcwa group"/>
  <Returns>
    An rcwa mapping mapping&nbsp;<A>x</A> such that
    <A>G</A>&circum;<A>x</A> is integral.
  </Returns>
  <Description>
    This is of course not defined uniquely, but it holds
    that <C><A>G</A>&circum;IntegralizingConjugator(<A>G</A>) =
            IntegralConjugate(<A>G</A>)</C>.
    See also <Ref Attr ="IntegralizingConjugator"
                  Label="Integralizing conjugator of rcwa mapping"/>
    for rcwa mappings.
<Example>
<![CDATA[
gap> fl := IntegralizingConjugator(G);
<bijective rcwa mapping of Z with modulus 24>
gap> G^fl = F;
true
gap> Display(fl);

Bijective rcwa mapping of Z with modulus 24

               n mod 24                |                 n^f
---------------------------------------+--------------------------------------
   0 12                                | 7n/6
   1 13                                | (7n - 1)/6
   2                                   | (7n + 106)/12
   3 15                                | (7n - 9)/6
   4 16                                | (7n - 10)/6
   5 17                                | (7n - 11)/6
   6 18                                | (7n - 12)/6
   7 19                                | (7n - 13)/6
   8                                   | (7n + 76)/12
   9 21                                | (7n - 21)/6
  10 22                                | (7n - 22)/6
  11 23                                | (7n - 23)/6
  14                                   | (7n + 46)/12
  20                                   | (7n + 16)/12

]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="ShortCycles" Arg="f, maxlng"/>
  <Returns>
    All <Q>single</Q> finite cycles of the rcwa mapping&nbsp;<A>f</A>
    of length at most <A>maxlng</A>.
  </Returns>
  <Description>
    By <Q>single</Q> finite cycles we denote finite cycles not belonging
    to an infinite series (i.e. there is no constant <M>m</M> such that
    adding any multiple of <M>m</M> to the elements of the cycle always
    yields a new cycle). <P/>

    Since &GAP;-permutations cannot move negative integers, rationals
    or even polynomials, the cycles are returned as lists, for example
    the list <C>[-3,1,2,-2]</C> denotes the cycle <C>(-3,1,2,-2)</C>.
    Mappings having different sets of finite cycle lengths are obviously
    not conjugate in RCWA(<M>R</M>).
<Example>
<![CDATA[
gap> ShortCycles(a,2);
[ [ 0 ], [ 1 ], [ -1 ], [ 2, 3 ], [ -3, -2 ] ]
gap> ShortCycles(a,5);
[ [ 0 ], [ 1 ], [ -1 ], [ 2, 3 ], [ -3, -2 ], [ 4, 6, 9, 7, 5 ], 
  [ -9, -7, -5, -4, -6 ] ]
gap> ShortCycles(u,2);
[ [ 0 ], [ -1 ], [ 1, 2 ], [ 3, 5 ], [ -10, -6 ] ]
gap> ShortCycles(Comm(a,b),10);
[  ]
gap> ShortCycles(a*b,2);
[ [ 0 ], [ 2 ], [ 3 ], [ -26 ], [ 7 ], [ -3 ], [ -1 ] ]
gap> v := RcwaMapping([[-1,2,1],[1,-1,1],[1,-1,1]]);;
gap> w := RcwaMapping([[-1,3,1],[1,-1,1],[1,-1,1],[1,-1,1]]);;
gap> Order(v);
6
gap> Order(w);
8
gap> ShortCycles(v,10);
[ [ 0, 2, 1 ] ]
gap> ShortCycles(w,10);
[ [ 0, 3, 2, 1 ] ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Func Name="NrConjugacyClassesOfRCWAZOfOrder" Arg="ord"/>
  <Returns>
    The number of conjugacy classes of RCWA(<M>\Z</M>) of elements
    of order&nbsp;<A>ord</A>.
  </Returns>
  <Description>
<Example>
<![CDATA[
gap> NrConjugacyClassesOfRCWAZOfOrder(2);
infinity
gap> NrConjugacyClassesOfRCWAZOfOrder(105);
218
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:RestrictionMonomorphisms">
<Heading>Images under restriction monomorphisms</Heading>

<ManSection>
  <Oper Name ="Restriction" Arg="g, f"
        Label="Restriction of an rcwa mapping"/>
  <Returns> The <E>restriction</E> of <A>g</A> by&nbsp;<A>f</A>. </Returns>
  <Description>
    By definition, the restriction <M>g_f</M> of <A>g</A> by <A>f</A>
    is the uniquely-determined rcwa mapping satisfying
    <M>f \cdot g_f = g \cdot f</M> and fixing the complement of
    the image of <A>f</A>. The mapping <A>f</A> has to be injective and
    its multiplier must not be zero. If <A>f</A> is bijective the
    returned mapping is just the conjugate of <A>g</A> by <A>f</A>. <P/>

    See also <Ref Oper="Restriction" Label="Restriction of an rcwa group"/>
    for rcwa groups.
<Example>
<![CDATA[
gap> Comm(Restriction(a,RcwaMapping([[2,0,1]])),
>         Restriction(u,RcwaMapping([[2,1,1]])));
IdentityMapping( Integers )
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Oper Name ="Restriction" Arg="G, f"
        Label="Restriction of an rcwa group"/>
  <Returns> The restriction of <A>G</A> by&nbsp;<A>f</A>. </Returns>
  <Description>
    The mapping <A>f</A> has to be injective.
    The returned group acts on the image of <A>f</A> and fixes its
    complement pointwise. If <A>f</A> is bijective the returned
    group is just the conjugate of <A>G</A> by <A>f</A>. <P/>
    The elements of the restricted group are just the restrictions
    of the elements of <A>G</A> by <A>f</A>. For a definition see
    <Ref Oper="Restriction" Label="Restriction of an rcwa mapping"/>
    for rcwa mappings.
<Example>
<![CDATA[
gap> G := Restriction(Group(a,b),RcwaMapping([[5,3,1]]));
<rcwa group over Z with 2 generators>
gap> MovedPoints(G);
3(5)
]]>
</Example>
  </Description>
</ManSection>

Restriction monomorphisms allow us to form direct products of any
rcwa groups (regardless of whether they are tame or not):

<ManSection>
  <Oper Name ="DirectProduct" Arg="G1, G2, ..."/>
  <Returns>
    The direct product of the rcwa groups over&nbsp;<M>\Z</M>
    given as arguments.
  </Returns>
  <Description>
    As there is no unique or canonical way to embed a direct product
    of rcwa groups into RCWA(<M>R</M>), this method may choose any
    such embedding.
<Example>
<![CDATA[
gap> G := DirectProduct(Group(g,h),Group(a,b),Group(u));
<rcwa group over Z with 5 generators>
gap> List(GeneratorsOfGroup(G),Order);
[ 7, 12, infinity, infinity, infinity ]
gap> Embedding(G,1);
[ g, h ] -> [ <bijective rcwa mapping of Z with modulus 18, of order 7>, 
  <bijective rcwa mapping of Z with modulus 18, of order 12> ]
gap> Projection(G,2);
[ <bijective rcwa mapping of Z with modulus 18, of order 7>, 
  <bijective rcwa mapping of Z with modulus 18, of order 12>, 
  <wild bijective rcwa mapping of Z with modulus 12>, 
  <wild bijective rcwa mapping of Z with modulus 12>, 
  <bijective rcwa mapping of Z with modulus 15, of order infinity> ] -> 
[ IdentityMapping( Integers ), IdentityMapping( Integers ), a, b, 
  IdentityMapping( Integers ) ]
gap> List([1..3],i->MovedPoints(Image(Embedding(G,i))));
[ 0(3), 1(3), 2(3) \ [ -1, 2 ] ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:CategoriesOfRcwaGroups">
<Heading>The categories of rcwa groups</Heading>

<ManSection>
  <Filt Name="IsRcwaGroup" Arg="G"/>
  <Returns>
    <C>true</C> if <A>G</A> is an rcwa group and
    <C>false</C> otherwise.
  </Returns>
  <Description>
    The category of all rcwa groups.
  </Description>
</ManSection>

<ManSection>
  <Filt Name="IsIntegralRcwaGroup" Arg="G"/>
  <Returns>
    <C>true</C> if <A>G</A> is an rcwa group over the ring of integers
    and <C>false</C> otherwise.
  </Returns>
  <Description>
    The category of all rcwa groups over the ring of integers.
  </Description>
</ManSection>

<ManSection>
  <Fam Name="IntegralRcwaGroupsFamily"/>
  <Description>
    The family of all rcwa groups over the ring of integers.
  </Description>
</ManSection>

<ManSection>
  <Var Name="TrivialIntegralRcwaGroup"/>
  <Description>
    The trivial rcwa group over the ring of integers.
  </Description>
</ManSection>

<ManSection>
  <Filt Name="IsSemilocalIntegralRcwaGroup" Arg="G"/>
  <Returns>
    <C>true</C> if <A>G</A> is an rcwa group over a semilocalization
    of the ring of integers and <C>false</C> otherwise.
  </Returns>
  <Description>
    The category of all rcwa groups over semilocalizations of the
    ring of integers.
  </Description>
</ManSection>

<ManSection>
  <Filt Name="IsModularRcwaGroup" Arg="G"/>
  <Returns>
    <C>true</C> if <A>G</A> is an rcwa group over a polynomial ring in
    one variable over a finite field and <C>false</C> otherwise.
  </Returns>
  <Description>
    The category of all rcwa groups over polynomial rings in one variable
    over some finite field.
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->
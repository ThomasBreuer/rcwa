<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  algs.xml           RCWA documentation            Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$         ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:algorithms">
<Heading>The Algorithms Implemented in RCWA</Heading>

This chapter lists brief descriptions of many of the algorithms and methods
implemented in this package. These descriptions are kept very informal and
short, and some of them provide only rudimentary information. They are listed
in alphabetical order. The word <Q>trivial</Q> as a description means that
essentially nothing is done except of storing or recalling one or several
values, and <Q>straightforward</Q> means that no sophisticated algorithm
is used. Longer and better descriptions of many of the algorithms and methods
can be found in&nbsp;<Cite Key="Kohl07a"/>.

<List>

  <Mark>
    <C>ActionOnRespectedPartition(<A>G</A>)</C>
  </Mark>
  <Item>
    <Q>Straightforward</Q> after having computed a respected partition
    by <C>RespectedPartition</C>. One only needs to know how to compute
    images of residue classes under affine mappings.
  </Item>

  <Mark>
    <C>Ball(<A>G</A>,<A>g</A>,<A>r</A>)</C>
  </Mark>
  <Item>
    <Q>Straightforward</Q>.
  </Item>

  <Mark>
    <C>Ball(<A>G</A>,<A>p</A>,<A>r</A>,<A>act</A>)</C>
  </Mark>
  <Item>
    <Q>Straightforward</Q>.
  </Item>

  <Mark>
    <C>ClassReflection(<A>r</A>,<A>m</A>)</C>
  </Mark>
  <Item>
    <Q>Trivial</Q>.
  </Item>

  <Mark>
    <C>ClassShift(<A>r</A>,<A>m</A>)</C>
  </Mark>
  <Item>
    <Q>Trivial</Q>.
  </Item>

  <Mark>
    <C>ClassTransposition(<A>r1</A>,<A>m1</A>,<A>r2</A>,<A>m2</A>)</C>
  </Mark>
  <Item>
    <Q>Trivial</Q>.
  </Item>

  <Mark>
    <C>ClassWiseOrderPreservingOn(<A>f</A>)</C>, etc.
  </Mark>
  <Item>
    Forms the union of the residue classes modulo the modulus
    of&nbsp;<A>f</A> in whose corresponding coefficient triple
    the first entry is positive, zero or negative, respectively.
  </Item>

  <Mark>
    <C>Coefficients(<A>f</A>)</C>
  </Mark>
  <Item>
    <Q>Trivial</Q>.
  </Item>

  <Mark>
    <C>CommonRightInverse(<A>l</A>,<A>r</A>)</C>
  </Mark>
  <Item>
    (See <C>RightInverse</C>.)
  </Item>

  <Mark>
    <C>DecreasingOn(<A>f</A>)</C>
  </Mark>
  <Item>
    Forms the union of the residue classes which are determined by the
    coefficients as indicated.
  </Item>

  <Mark>
    <C>Determinant(<A>g</A>)</C>
  </Mark>
  <Item>
    Evaluation of the given expression.
    For the mathematical meaning (epimorphism!), see Theorem&nbsp;2.11.9
    in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>DirectProduct(<A>G1</A>,<A>G2</A>, ... )</C>
  </Mark>
  <Item>
    Restricts the groups <A>G1</A>, <A>G2</A>, ...
    to disjoint residue classes. See <C>Restriction</C>
    and Corollary&nbsp;2.3.3 in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>Display(<A>f</A>)</C>
  </Mark>
  <Item>
    <Q>Trivial</Q>.
  </Item>

  <Mark>
    <C>Divisor(<A>f</A>)</C>
  </Mark>
  <Item>
    Lcm of coefficients, as indicated.
  </Item>

  <Mark>
    <C>FactorizationIntoCSCRCT(<A>g</A>)</C>
  </Mark>
  <Item>
    This uses a rather sophisticated method which will likely
    some time be published elsewhere. At the moment termination is not
    guaranteed, but in case of termination the result is certain.
    The strategy is roughly first to make the mapping class-wise
    order-preserving and balanced, and then to remove all prime factors
    from multiplier and divisor one after the other in decreasing order
    by dividing by appropriate class transpositions.
    The remaining integral mapping can be factored almost similarly
    easily as a permutation of a finite set can be factored into
    transpositions.
  </Item>

  <Mark>
    <C>FactorizationOnConnectedComponents(<A>f</A>,<A>m</A>)</C>
  </Mark>
  <Item>
    Calls <Package>GRAPE</Package> to get the connected components of the
    transition graph, and then computes a partition of the suitably
    <Q>blown up</Q> coefficient list corresponding to the connected
    components.
  </Item>

  <Mark>
    <C>FixedPointsOfAffinePartialMappings(<A>f</A>)</C>
  </Mark>
  <Item>
    <Q>Straightforward</Q>.
  </Item>

  <Mark>
    <C>GuessedDivergence(<A>f</A>)</C>
  </Mark>
  <Item>
    Numerical computation of the limit of some series, which seems to
    converge <Q>often</Q>. Caution!!!
  </Item>

  <Mark>
    <C>Image(<A>f</A>)</C>, <C>Image(<A>f</A>,<A>S</A>)</C>
  </Mark>
  <Item>
    <Q>Straightforward</Q> if one can compute images of residue classes
    under affine mappings and unite and intersect residue classes
    (Chinese Remainder Theorem).
    See Lemma&nbsp;1.2.1 in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>ImageDensity(<A>f</A>)</C>
  </Mark>
  <Item>
    Evaluation of the given expression.
  </Item>

  <Mark>
    <C><A>g</A> in <A>G</A></C> (membership test)
  </Mark>
  <Item>
    Test whether the mapping <A>g</A> or its inverse is in the list of
    generators of&nbsp;<A>G</A>. If it is, return <C>true</C>.
    Test whether its prime set is a subset of the prime set of&nbsp;<A>G</A>.
    If not, return <C>false</C>. Test whether the multiplier or the divisor
    of&nbsp;<A>g</A> has a prime factor which does not divide the multiplier
    of&nbsp;<A>G</A>. If yes, return <C>false</C>. Test if <A>G</A> is
    class-wise order-preserving, and <A>g</A> is not. If so, return
    <C>false</C>. Test if the sign of <A>g</A> is&nbsp;-1 and all generators
    of&nbsp;<A>G</A> have sign&nbsp;1. If yes, return <C>false</C>.
    Test if <A>G</A> is class-wise order-preserving, all generators
    of&nbsp;<A>G</A> have determinant&nbsp;0 and <A>g</A> has
    determinant&nbsp;<M>\neq 0</M>. If yes, return <C>false</C>.
    Test whether the support of&nbsp;<A>g</A> is a subset of the support
    of&nbsp;<A>G</A>. If not, return <C>false</C>.
    Test whether <A>G</A> fixes the nonnegative integers setwise,
    but&nbsp;<A>g</A> does not. If yes, return <C>false</C>. <P/>

    If <A>G</A> is tame, proceed as follows:
    Test whether the modulus of <A>g</A> divides the modulus of <A>G</A>.
    If not, return <C>false</C>. Test whether <A>G</A> is finite and <A>g</A>
    has infinite order. If so, return <C>false</C>. Test whether <A>g</A>
    is tame. If not, return <C>false</C>.
    Compute a respected partition <C>P</C> of <A>G</A> and the
    finite permutation group <C>H</C> induced by <A>G</A> on it
    (see <C>RespectedPartition</C>).
    Check whether <A>g</A> permutes <C>P</C>. If not, return <C>false</C>.
    Let <C>h</C> be the permutation induced by <A>g</A> on <C>P</C>.
    Check whether <C>h</C> lies in <C>H</C>. If not, return <C>false</C>.
    Compute an element <C>g1</C> of <A>G</A> which acts on&nbsp;<C>P</C>
    like&nbsp;<A>g</A>. For this purpose, factor <A>h</A> into generators
    of&nbsp;<C>H</C> using <C>PreImagesRepresentative</C>, and compute the
    corresponding product of generators of&nbsp;<A>G</A>.
    Let <C>k := g/g1</C>. The mapping <C>k</C> is always integral.
    Compute the kernel&nbsp;<C>K</C> of the action of <A>G</A>
    on&nbsp;<C>P</C> using <C>KernelOfActionOnRespectedPartition</C>. Check
    whether <C>k</C> lies in&nbsp;<C>K</C>. This is done using the package
    <Package>Polycyclic</Package>&nbsp;<Cite Key="Polycyclic"/>, and uses an
    isomorphism from a supergroup of &nbsp;<C>K</C> which is isomorphic
    to the <C>|P|</C>-fold direct product of the infinite dihedral group
    and which always contains&nbsp;<C>k</C> to a polycyclically presented
    group. If&nbsp;<C>k</C> lies in&nbsp;<C>K</C>, return <C>true</C>,
    otherwise return <C>false</C>. <P/>

    If <A>G</A> is not tame, proceed as follows:
    Look for finite orbits of&nbsp;<A>G</A>. If some are found, test whether
    <A>g</A> acts on them, and whether the induced permutations lie in
    the permutation groups induced by&nbsp;<A>G</A>. If for one of the
    examined orbits one of the latter two questions has a negative answer,
    then return <C>false</C>.
    Look for a positive integer&nbsp;<M>m</M> such that <A>g</A> does
    not leave a partition of&nbsp;<M>\Z</M> into unions of residue
    classes (mod&nbsp;<M>m</M>) invariant which is fixed by&nbsp;<A>G</A>.
    If successful, return <C>false</C>. If not, try to factor <A>g</A> into
    generators of&nbsp;<A>G</A> using <C>PreImagesRepresentative</C>.
    If successful, return <C>true</C>. If <A>g</A> is in <A>G</A>, this
    terminates after a finite number of steps. Both runtime and memory
    requirements are exponential in the word length. If <A>g</A> is not
    in <A>G</A> at this stage, the method runs into an infinite loop.
  </Item>

  <Mark>
    <C>IncreasingOn(<A>f</A>)</C>
  </Mark>
  <Item>
    Forms the union of the residue classes which are determined by the
    coefficients as indicated.
  </Item>

  <Mark>
    <C>Induction(<A>g</A>,<A>f</A>)</C>
  </Mark>
  <Item>
    Computes <C>f * g * RightInverse(<A>f</A>)</C>.
  </Item>

  <Mark>
    <C>Induction(<A>G</A>,<A>f</A>)</C>
  </Mark>
  <Item>
    Gets a set of generators by applying <C>Induction(<A>g</A>,<A>f</A>)</C>
    to the generators <A>g</A> of&nbsp;<A>G</A>.
  </Item>

  <Mark>
    <C>InjectiveAsMappingFrom(<A>f</A>)</C>
  </Mark>
  <Item>
    The function starts with the entire source of <A>f</A> as <Q>preimage</Q>
    <C>pre</C> and the empty set as <Q>image</Q>&nbsp;<C>im</C>.
    It loops over the residue classes (mod&nbsp;<C>Mod(<A>f</A>)</C>).
    For any such residue class <C>cl</C> the following is done: Firstly,
    the image of <C>cl</C> under&nbsp;<A>f</A> is added to&nbsp;<C>im</C>.
    Secondly, the intersection of the preimage of the intersection of the
    image of <C>cl</C> under <A>f</A> and <C>im</C> under <A>f</A> and
    <C>cl</C> is subtracted from&nbsp;<C>pre</C>. 
  </Item>

  <Mark>
    <C>IntegralConjugate(<A>f</A>)</C>, 
    <C>IntegralConjugate(<A>G</A>)</C>
  </Mark>
  <Item>
    Uses the algorithm described in the proof of Theorem&nbsp;2.5.14
    in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>IntegralizingConjugator(<A>f</A>)</C>, 
    <C>IntegralizingConjugator(<A>G</A>)</C>
  </Mark>
  <Item>
    Uses the algorithm described in the proof of Theorem&nbsp;2.5.14
    in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>Inverse(<A>f</A>)</C>
  </Mark>
  <Item>
    Essentially inversion of affine mappings.
    See Lemma&nbsp;1.3.1, Part&nbsp;(b) in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>IsClassWiseOrderPreserving(<A>f</A>)</C>
  </Mark>
  <Item>
    Tests whether the first entry of all coefficient triples is positive.
  </Item>

  <Mark>
    <C>IsConjugate(RCWA(Integers),<A>f</A>,<A>g</A>)</C>
  </Mark>
  <Item>
    Test whether <A>f</A> and <A>g</A> have the same order, and whether
    either both or none of them is tame. If not, return <C>false</C>. <P/>

    If the mappings are wild, use <C>ShortCycles</C> to search for finite
    cycles not belonging to an infinite series, until their numbers for a
    particular length differ. This may run into an infinite loop.
    If it terminates, return <C>false</C>. <P/>

    If the mappings are tame, use the method described in the proof of
    Theorem&nbsp;2.5.14 in&nbsp;<Cite Key="Kohl05"/> to construct
    integral conjugates of <A>f</A> and <A>g</A>. Then essentially use
    the algorithm described in the proof of Theorem&nbsp;2.6.7
    in&nbsp;<Cite Key="Kohl05"/> to compute <Q>standard representatives</Q>
    of the conjugacy classes which the integral conjugates of <A>f</A>
    and <A>g</A> belong to. Finally compare these standard representatives,
    and return <C>true</C> if they are equal and <C>false</C> if not.
  </Item>

  <Mark>
    <C>IsInjective(<A>f</A>)</C>
  </Mark>
  <Item>
    See <C>Image</C>.
  </Item>

  <Mark>
    <C>IsIntegral(<A>f</A>)</C>
  </Mark>
  <Item>
    <Q>Trivial</Q>.
  </Item>

  <Mark>
    <C>IsomorphismMatrixGroup(<A>G</A>)</C>
  </Mark>
  <Item>
    Uses the algorithm described in the proof of Theorem&nbsp;2.6.3
    in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>IsomorphismPermGroup(<A>G</A>)</C>
  </Mark>
  <Item>
    If the group <A>G</A> is infinite, there is no isomorphism to
    a finite permutation group, thus return <C>fail</C>.
    Otherwise use <C>ActionOnRespectedPartition</C>.
  </Item>

  <Mark>
    <C>IsomorphismRcwaGroup(<A>G</A>)</C>
  </Mark>
  <Item>
    The method for finite groups uses <C>RcwaMapping</C>, Part&nbsp;(d). <P/>

    The method for free products of finite groups uses the Table-Tennis
    Lemma (which is also known as <E>Ping-Pong Lemma</E>,
    cp. e.g. Section&nbsp;II.B. in&nbsp;<Cite Key="LaHarpe00"/>).
    It uses regular permutation representations of the factors
    <M>G_r</M> (<M>r = 0, \dots ,m-1</M>) of the free product on residue
    classes modulo <M>n_r := |G_r|</M>.
    The basic idea is that since point stabilizers in regular permutation
    groups are trivial, all non-identity elements map any of the permuted
    residue classes into their complements.
    To get into a situation where the Table-Tennis Lemma is applicable,
    the method computes conjugates of the images of the mentioned permutation
    representations under bijective rcwa mappings <M>\sigma_r</M> which
    satisfy <M>0(n_r)^{\sigma_r} = \Z \setminus r(m)</M>. <P/>

    The method for free groups uses an adaptation of the construction
    given on page&nbsp;27 in&nbsp;<Cite Key="LaHarpe00"/> from
    PSL(2,<M>\mathbb{C}</M>) to RCWA(<M>\Z</M>).
    As an equivalent for the closed discs used there, the method takes
    the residue classes modulo two times the rank of the free group.
  </Item>

  <Mark>
    <C>IsSurjective(<A>f</A>)</C>
  </Mark>
  <Item>
    See <C>Image</C>.
  </Item>

  <Mark>
    <C>IsTame(<A>G</A>)</C>
  </Mark>
  <Item>
    Checks whether the modulus of the group is non-zero.
  </Item>

  <Mark>
    <C>IsTame(<A>f</A>)</C>
  </Mark>
  <Item>
    Application of the criteria given in Corollary&nbsp;2.5.10
    and&nbsp;2.5.12 and Theorem&nbsp;A.8 and&nbsp;A.11
    in&nbsp;<Cite Key="Kohl05"/>, as well as of the criteria given
    in&nbsp;<Cite Key="Kohl07b"/>.

    The criterion <Q>surjective, but not injective means wild</Q>
    (Theorem&nbsp;A.8 in&nbsp;<Cite Key="Kohl05"/>) is the subject
    of&nbsp;<Cite Key="Kohl06a"/>.

    The package <Package>GRAPE</Package> is needed for the application
    of the criterion which says that an rcwa permutation is wild if
    a transition graph has a weakly-connected component which is not
    strongly-connected (cp. Theorem&nbsp;A.11 in&nbsp;<Cite Key="Kohl05"/>).
  </Item>

  <Mark>
    <C>IsTransitive(<A>G</A>,Integers)</C>
  </Mark>
  <Item>
    Look for finite orbits, using <C>ShortOrbits</C> on a couple of
    intervals. If a finite orbit is found, return <C>false</C>.
    Test if <A>G</A> is finite. If yes, return <C>false</C>. <P/>

    Search for an element <C>g</C> and a residue class <M>r(m)</M>
    such that the restriction of <C>g</C> to <M>r(m)</M> is given
    by <M>n \mapsto n + m</M>. Then the cyclic group generated by <C>g</C>
    acts transitively on <M>r(m)</M>. The element <C>g</C> is searched
    among the generators of <A>G</A>, its powers, its commutators,
    powers of its commutators and products of few different generators.
    The search for such an element may run into an infinite loop,
    as there is no guarantee that the group has a suitable element. <P/>

    If suitable <C>g</C> and <M>r(m)</M> are found, proceed as follows: <P/>

    Put <M>S := r(m)</M>. Put <M>S := S \cup S^g</M> for all generators
    <M>g</M> of <A>G</A>, and repeat this until <M>S</M> remains constant.
    This may run into an infinite loop. <P/>

    If it terminates: If <M>S = \Z</M>, return <C>true</C>,
    otherwise return <C>false</C>.
  </Item>

  <Mark>
    <C>KernelOfActionOnRespectedPartition(<A>G</A>)</C>
  </Mark>
  <Item>
    First determine the abelian invariants of the kernel&nbsp;<C>K</C>.
    For this, compute sufficiently many quotients of orders of
    permutation groups induced by&nbsp;<A>G</A> on refinements of
    the stored respected partition&nbsp;<C>P</C> by the order of the
    permutation group induced by&nbsp;<A>G</A> on&nbsp;<C>P</C> itself.
    Then use a random walk through the group <A>G</A>.
    Compute powers of elements encountered along the way which
    fix&nbsp;<C>P</C>.
    Translate these kernel elements into elements of a polycyclically
    presented group isomorphic to the <C>|P|</C>-fold direct product of
    the infinite dihedral group (<C>K</C> certainly embeds into this group).
    Use <Package>Polycyclic</Package>&nbsp;<Cite Key="Polycyclic"/>
    to collect independent <Q>nice</Q> generators of&nbsp;<C>K</C>.
    Proceed until the permutation groups induced by&nbsp;<C>K</C> on the
    refined respected partitions all equal the initially stored quotients.
  </Item>

  <Mark>
    <C>LargestSourcesOfAffineMappings(<A>f</A>)</C>
  </Mark>
  <Item>
    Forms unions of residue classes modulo the modulus of the mapping,
    whose corresponding coefficient triples are equal.
  </Item>

  <Mark>
    <C>LaTeXObj(<A>f</A>)</C>
  </Mark>
  <Item>
    Collects residue classes those corresponding coefficient triples
    are equal.
  </Item>

  <Mark>
    <C>LikelyContractionCentre(<A>f</A>,<A>maxn</A>,<A>bound</A>)</C>
  </Mark>
  <Item>
    Computes trajectories with starting values from a given interval, until
    a cycle is reached. Aborts if the trajectory exceeds the prescribed
    bound. Form the union of the detected cycles.
  </Item>

  <Mark>
    <C>LocalizedRcwaMapping(<A>f</A>,<A>p</A>)</C>
  </Mark>
  <Item>
    <Q>Trivial</Q>.
  </Item>

  <Mark>
    <C>mKnot(<A>m</A>)</C>
  </Mark>
  <Item>
    <Q>Straightforward</Q>, following the definition given in
    <Cite Key="Keller99"/>.
  </Item>

  <Mark>
    <C>Modulus(<A>G</A>)</C>
  </Mark>
  <Item>
    Searches for a wild element in the group.
    If unsuccessful, tries to construct a respected partition
    (see <C>RespectedPartition</C>).
  </Item>

  <Mark>
    <C>Modulus(<A>f</A>)</C>
  </Mark>
  <Item>
    <Q>Trivial</Q>.
  </Item>

  <Mark>
    <C>MovedPoints(<A>G</A>)</C>
  </Mark>
  <Item>
    Needs only forming unions of residue classes and determining
    fixed points of affine mappings.
  </Item>

  <Mark>
    <C>Multiplier(<A>f</A>)</C>
  </Mark>
  <Item>
    Lcm of coefficients, as indicated.
  </Item>

  <Mark>
    <C>Multpk(<A>f</A>,<A>p</A>,<A>k</A>)</C>
  </Mark>
  <Item>
    Forms the union of the residue classes modulo the modulus of the
    mapping, which are determined by the given divisibility criteria
    for the coefficients of the corresponding affine mapping.
  </Item>

  <Mark>
    <C>NrConjugacyClassesOfRCWAZOfOrder(<A>ord</A>)</C>
  </Mark>
  <Item>
    The class numbers are taken from Corollary&nbsp;2.7.1
    in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>OrbitsModulo(<A>f</A>,<A>m</A>)</C>
  </Mark>
  <Item>
    Uses <Package>GRAPE</Package> to compute the connected
    components of the transition graph.
  </Item>

  <Mark>
    <C>OrbitsModulo(<A>G</A>,<A>m</A>)</C>
  </Mark>
  <Item>
    <Q>Straightforward</Q>.
  </Item>

  <Mark>
    <C>Order(<A>f</A>)</C>
  </Mark>
  <Item>
    Test for <C>IsTame</C>.
    If the mapping is not tame, then return <C>infinity</C>.
    Otherwise use Corollary&nbsp;2.5.10 in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>PreImage(<A>f</A>,<A>S</A>)</C>
  </Mark>
  <Item>
    See <C>Image</C>.
  </Item>

  <Mark>
    <C>PreImagesRepresentative(<A>phi</A>,<A>g</A>)</C>,
    <C>PreImagesRepresentatives(<A>phi</A>,<A>g</A>)</C>
  </Mark>
  <Item>
    As indicated in the documentation of these methods.
    The underlying idea to successively compute two balls around&nbsp;1
    and&nbsp;<A>g</A> until they intersect non-trivially is standard
    in computational group theory. For rcwa groups it would mean wasting
    both memory and runtime to actually compute group elements.
    Thus only images of tuples of points are computed and stored.
  </Item>

  <Mark>
    <C>PrimeSet(<A>f</A>)</C>,
    <C>PrimeSet(<A>G</A>)</C>
  </Mark>
  <Item>
    <Q>Straightforward</Q>.
  </Item>

  <Mark>
    <C>PrimeSwitch(<A>p</A>)</C>
  </Mark>
  <Item>
    Multiplication of rcwa mappings as indicated.
  </Item>

  <Mark>
    <C>Print(<A>f</A>)</C>
  </Mark>
  <Item>
    <Q>Trivial</Q>.
  </Item>

  <Mark>
    <C><A>f</A>*<A>g</A></C>
  </Mark>
  <Item>
    Essentially composition of affine mappings.
    See Lemma&nbsp;1.3.1, Part&nbsp;(a) in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>Random(RCWA(Integers))</C>
  </Mark>
  <Item>
    Computes a product of <Q>randomly</Q> chosen class shifts,
    class reflections and class transpositions. This seems to
    be suitable for generating reasonably good examples.
  </Item>

  <Mark>
    <C>RankOfKernelOfActionOnRespectedPartition(<A>G</A>)</C>
  </Mark>
  <Item>
    This performs basically the first part of the computations done by
    <C>KernelOfActionOnRespectedPartition</C>.
  </Item>

  <Mark>
    <C>RCWA(<A>R</A>)</C>
  </Mark>
  <Item>
    Attributes are set according to Theorem&nbsp;2.1.1,
    Theorem&nbsp;2.1.2, Corollary&nbsp;2.1.6 and Theorem&nbsp;2.12.8
    in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>RcwaGroupByPermGroup(<A>G</A>)</C>
  </Mark>
  <Item>
    Uses <C>RcwaMapping</C>, Part&nbsp;(d).
  </Item>

  <Mark>
    <C>RcwaMapping</C>
  </Mark>
  <Item>
    (a)-(c): <Q>trivial</Q>,
    (d): <C>n&circum;perm - n</C> for determining the coefficients,
    (e): <Q>affine mappings by values at two given points</Q>,
    (f) and (g): <Q>trivial</Q>,
    (h) and (i): correspond to Lemma&nbsp;2.1.4 in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>RepresentativeAction(<A>G</A>,<A>src</A>,<A>dest</A>,<A>act</A>)</C>,
    <C>RepresentativeActionPreImage</C>
  </Mark>
  <Item>
    As indicated in the documentation of these methods.
    The underlying idea to successively compute two balls around
    <A>src</A> and <A>dest</A> until they intersect non-trivially
    is standard in computational group theory. Words standing for
    products of generators of <A>G</A> are stored for any image
    of <A>src</A> or <A>dest</A>.    
  </Item>

  <Mark>
    <C>RepresentativeAction(RCWA(Integers),<A>P1</A>,<A>P2</A>)</C>
  </Mark>
  <Item>
    Arbitrary mapping: see Lemma&nbsp;2.1.4 in&nbsp;<Cite Key="Kohl05"/>.
    Tame mapping: see proof of Theorem&nbsp;2.8.9
    in&nbsp;<Cite Key="Kohl05"/>. The former is almost trivial, while the
    latter is a bit complicated and takes usually also much more time.
  </Item>

  <Mark>
    <C>RepresentativeAction(RCWA(Integers),<A>f</A>,<A>g</A>)</C>
  </Mark>
  <Item>
    The algorithm used by <C>IsConjugate</C> constructs actually also
    an element <C>x</C> such that <C><A>f</A>&circum;x = <A>g</A></C>.
  </Item>

  <Mark>
    <C>RespectedPartition(<A>f</A>)</C>,
    <C>RespectedPartition(<A>G</A>)</C>
  </Mark>
  <Item>
    Uses the algorithm described in the proof of Theorem&nbsp;2.5.8
    in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>Restriction(<A>g</A>,<A>f</A>)</C>
  </Mark>
  <Item>
    Computes the action of <C>RightInverse(<A>f</A>) * g * f</C> on the
    image of&nbsp;<A>f</A>.
  </Item>

  <Mark>
    <C>Restriction(<A>G</A>,<A>f</A>)</C>
  </Mark>
  <Item>
    Gets a set of generators by applying
    <C>Restriction(<A>g</A>,<A>f</A>)</C>
    to the generators <A>g</A> of&nbsp;<A>G</A>.
  </Item>

  <Mark>
    <C>RightInverse(<A>f</A>)</C>
  </Mark>
  <Item>
    <Q>Straightforward</Q> if one knows how to compute images of residue
    classes under affine mappings, and how to compute inverses of
    affine mappings.
  </Item>

  <Mark>
    <C>Root(<A>f</A>,<A>k</A>)</C>
  </Mark>
  <Item>
    If <A>f</A> is bijective, class-wise order-preserving and has
    finite order: <P/>

    Find a conjugate of <A>f</A> which is a product of class transpositions.
    Slice cycles <M>\prod_{i=2}^l \tau_{r_1(m_1),r_i(m_i)}</M>
    of&nbsp;<A>f</A> a respected partition <M>\mathcal{P}</M> into cycles
    <M>\prod_{i=1}^l \prod_{j=0}^{k-1} \tau_{r_1(km_1),r_i+jm_i(km_i)}</M>
    of the <A>k</A>-fold
    length on the refined partition which one gets from <M>\mathcal{P}</M>
    by decomposing any <M>r_i(m_i) \in \mathcal{P}</M> into residue classes
    (mod&nbsp;<M>km_i</M>). Finally conjugate the resulting permutation
    back. <P/>

    Other cases seem to be more difficult and are currently not covered.
  </Item>

  <Mark>
    <C>SemilocalizedRcwaMapping(<A>f</A>,<A>pi</A>)</C>
  </Mark>
  <Item>
    <Q>Trivial</Q>.
  </Item>

  <Mark>
    <C>ShortCycles(<A>f</A>,<A>maxlng</A>)</C>
  </Mark>
  <Item>
    Looks for fixed points of affine partial mappings of powers
    of&nbsp;<A>f</A>.
  </Item>

  <Mark>
    <C>ShortOrbits(<A>G</A>,<A>S</A>,<A>maxlng</A>)</C>
  </Mark>
  <Item>
    <Q>Straightforward</Q>.
  </Item>

  <Mark>
    <C>Sign(<A>g</A>)</C>
  </Mark>
  <Item>
    Evaluation of the given expression.
    For the mathematical meaning (epimorphism!), see Theorem&nbsp;2.12.8
    in&nbsp;<Cite Key="Kohl05"/>.
  </Item>

  <Mark>
    <C>Size(<A>G</A>)</C>
  </Mark>
  <Item>
    Test whether one of the generators of the group&nbsp;<A>G</A> has
    infinite order. If so, return <C>infinity</C>.
    Test whether the group <A>G</A> is tame. If not, return <C>infinity</C>.
    Test whether <C>RankOfKernelOfActionOnRespectedPartition(<A>G</A>)</C>
    is nonzero. If so, return <C>infinity</C>.
    Otherwise if <A>G</A> is class-wise order-preserving, return the size
    of the permutation group induced on the stored respected partition.
    If <A>G</A> is not class-wise order-preserving, return the size
    of the permutation group induced on the refinement of the stored
    respected partition which is obtained by splitting each residue class
    into three residue classes with equal moduli.
  </Item>

  <Mark>
    <C>StructureDescription(<A>G</A>)</C>
  </Mark>
  <Item>
    (Not described here.)
  </Item>

  <Mark>
    <C><A>f</A>+<A>g</A></C>
  </Mark>
  <Item>
    Pointwise addition of affine mappings.
  </Item>

  <Mark>
    <C>Trajectory(<A>f</A>,<A>n</A>,...)</C>
  </Mark>
  <Item>
    Iterated application of an rcwa mapping.
    In the methods computing <Q>accumulated coefficients</Q>,
    additionally composition of affine mappings.
  </Item>

  <Mark>
    <C>TransitionGraph(<A>f</A>,<A>m</A>)</C>
  </Mark>
  <Item>
    <Q>Straightforward</Q> -- just check a sufficiently long interval.
  </Item>

  <Mark>
    <C>TransitionMatrix(<A>f</A>,<A>m</A>)</C>
  </Mark>
  <Item>
    Evaluation of the given expression.
  </Item>

  <Mark>
    <C>ViewObj(<A>f</A>)</C>
  </Mark>
  <Item>
    <Q>Trivial</Q>.
  </Item>

  <Mark>
    <C>WreathProduct(<A>G</A>,<A>P</A>)</C>
  </Mark>
  <Item>
    Uses <C>DirectProduct</C> to embed the <C>DegreeAction(<A>P</A>)</C>th
    direct power of&nbsp;<A>G</A>, and <C>RcwaMapping</C>, Part&nbsp;(d)
    to embed the finite permutation group&nbsp;<A>P</A>.
  </Item>

  <Mark>
    <C>WreathProduct(<A>G</A>,<A>Z</A>)</C>
  </Mark>
  <Item>
    Restricts <A>G</A> to the residue class&nbsp;3(4), and encodes the
    generator of&nbsp;<A>Z</A> as <M>\tau_{0(2),1(2)} \cdot
    \tau_{0(2),1(4)}</M>. It is used that the images of&nbsp;3(4) under
    powers of this mapping are pairwise disjoint residue classes.
  </Item>

</List>

</Chapter>

<!-- #################################################################### -->

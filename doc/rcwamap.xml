<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  rcwamap.xml          RCWA documentation          Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$      ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:RcwaMappings">
<Heading>Residue Class-Wise Affine Mappings</Heading>

This chapter describes the functionality available for computing with
rcwa mappings. <P/>

<!-- #################################################################### -->

<Section Label="sec:ConstructingRcwaMappings">
<Heading>Constructing rcwa mappings</Heading>

  In order to define an rcwa mapping we need to know about the following:
  <List>

    <Mark>Underlying Ring</Mark>
    <Item>
      The underlying ring <M>R</M> is stored as the <C>UnderlyingRing</C> of
      the family the rcwa mapping object belongs to, and as the value of the
      attribute <C>Source</C>.
    </Item>

    <Mark>Modulus</Mark>
    <Item>
      The modulus is stored as a component <A>modulus</A> in any rcwa mapping
      object.
    </Item>

    <Mark>Coefficients</Mark>
    <Item>
      The list of coefficients is stored as a component <A>coeffs</A>
      in any rcwa mapping object. The component <A>coeffs</A> is a list of
      <M>|R</M>/<A>modulus</A><M>R|</M> lists of three elements of <A>R</A>,
      each, giving the coefficients <M>a_r</M>, <M>b_r</M> and <M>c_r</M>
      (cp. the definition of an rcwa mapping in the Preface
      (<Ref Label="ch:preface"/>)) for <M>r</M> running through a set of
      representatives for the residue classes (mod <A>modulus</A>).
      The ordering of these triples is defined by the ordering of the
      residues <M>r</M> mod <A>modulus</A> in the return value of
      <C>AllResidues( <A>R</A>, <A>modulus</A> )</C>
      (see <Ref Func="AllResidues"/>).
    </Item>

  </List>
  
  <ManSection>
    <Func Name="AllResidues" Arg="R, m"/>
    <Returns>
      a sorted list of all residues modulo <A>m</A> in the ring <A>R</A>.
    </Returns>
    <Description>
      The list returned by this function defines the ordering in which the
      coefficients of an rcwa mapping are stored,
      cp. <Ref Meth="RcwaMapping"/>. 
      Thus if <A>f</A> is an rcwa mapping of <A>R</A> with modulus <A>m</A>
      and coefficients list <A>c</A>, then <A>f</A> maps an element <A>n</A>
      of <A>R</A> satisfying <A>n</A> mod <A>m</A> = <A>r</A> to
      <C>(c[Position(res,r)][1]*n + c[Position(res,r)][2]) /
          c[Position(res,r)][3]</C>,
      where <C>res = AllResidues( <A>R</A>, <A>m</A> )</C> denotes the list
      of residues returned by this function. <P/>

      Remark: This function is part of the &ResClasses; package, but is
      documented here since in &ResClasses; it is used for internal
      purposes only.
<Example>
<![CDATA[
gap> AllResidues(Integers,6);
[ 0 .. 5 ]
gap> AllResidues(Z_pi([3,5,7]),700);
[ 0 .. 174 ]
gap> x := Indeterminate(GF(2),1);; SetName(x,"x");;
gap> R := PolynomialRing(GF(2),1); e := One(R);; z := Zero(R);;
GF(2)[x]
gap> AllResidues(R,x^4+x^2);
[ 0*Z(2), Z(2)^0, x, x+Z(2)^0, x^2, x^2+Z(2)^0, x^2+x, x^2+x+Z(2)^0, x^3, 
  x^3+Z(2)^0, x^3+x, x^3+x+Z(2)^0, x^3+x^2, x^3+x^2+Z(2)^0, x^3+x^2+x, 
  x^3+x^2+x+Z(2)^0 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="RcwaMapping" Arg="R, modulus, coeffs"/>
    <Meth Name="RcwaMapping" Arg="R, coeffs"/>
    <Meth Name="RcwaMapping" Arg="coeffs"/>
    <Meth Name="RcwaMapping" Arg="perm, range"/>
    <Meth Name="RcwaMapping" Arg="modulus, values"/>
    <Meth Name="RcwaMapping" Arg="pi, coeffs"/>
    <Meth Name="RcwaMapping" Arg="q, modulus, coeffs"/>
    <Meth Name="RcwaMapping" Arg="cycles"/>
    <Description>
      Construction of an rcwa mapping.<P/>

      In all cases the arguments <A>R</A> (the underlying ring),
      <A>modulus</A> and <A>coeffs</A>, as far as they occur, have the
      meaning described above. In case one or several of these arguments
      are omitted or replaced by other arguments, they are either derived
      from the latter or default values are taken. The meaning of the other
      arguments is given in the detailed description of the particular
      methods given in the sequel.

      The above methods return the rcwa mapping
      <List>
        <Mark>(a)</Mark>
        <Item>
          of <A>R</A> with modulus <A>modulus</A> and coefficients
          <A>coeffs</A>, resp.
        </Item>
        <Mark>(b)</Mark>
        <Item>
          of <A>R</A> = <M>\mathbb{Z}</M> or <A>R</A> =
          <M>\mathbb{Z}_{(\pi)}</M> with modulus <C>Length(<A>coeffs</A>)</C>
          and coefficients <A>coeffs</A>, resp.
        </Item>
        <Mark>(c)</Mark>
        <Item>
          of <A>R</A> = <M>\mathbb{Z}</M> with modulus
          <C>Length(<A>coeffs</A>)</C> and coefficients <A>coeffs</A>, resp.
        </Item>
        <Mark>(d)</Mark>
        <Item>
          of <A>R</A> = <M>\mathbb{Z}</M>,
          acting on the translates of <A>range</A> by integral multiples
          of the length of <A>range</A> as the translates of the action of
          the finite permutation <A>perm</A> on <A>range</A> to the
          respective intervals, where moved points of <A>perm</A> outside
          <A>range</A> are ignored (<A>range</A> must entirely consist out
          of positive integers less than <M>2^{28}</M>, since &GAP;
          permutations can only move these), resp.
        </Item>
        <Mark>(e)</Mark>
        <Item>
          of <A>R</A> = <M>\mathbb{Z}</M> with modulus <A>modulus</A> and
          values prescribed by the list <A>val</A>, which consists of
          2<M>\cdot</M><A>modulus</A> pairs giving preimage and image for
          2 points per residue class (mod <A>modulus</A>), resp.
        </Item>
        <Mark>(f)</Mark>
        <Item>
          of <M>\Z_{(\pi)}</M> with modulus <C>Length(<A>coeffs</A>)</C>
          and coefficients <A>coeffs</A> (the set of primes <M>\pi</M> 
          denoting the underlying ring is given as argument <A>pi</A>), resp.
        </Item>
        <Mark>(g)</Mark>
        <Item>
          of GF( <A>q</A> )[ <A>x</A> ] with modulus
          <A>modulus</A> and coefficients <A>coeffs</A>, resp.
        </Item>
        <Mark>(h)</Mark>
        <Item>
          an arbitrary rcwa mapping with <Q>residue class cycles</Q> as given
          by <A>cycles</A>. The latter is a list of lists of disjoint residue
          classes which the mapping should permute cyclically, each.
        </Item>
      </List>
      The methods for the operation <C>RcwaMapping</C> perform a number of
      argument checks, which can be skipped by using <C>RcwaMappingNC</C>
      instead.
<Example>
<![CDATA[
gap> f := RcwaMapping([[1,1,1],[1,-1,1],[1,1,1],[1,-1,1]]);
<rcwa mapping of Z with modulus 2>
gap> f = RcwaMapping((2,3),[2..3]);
true
gap> g := RcwaMapping((1,2,3)(8,9),[4..20]);
<rcwa mapping of Z with modulus 17>
gap> Action(Group(g),[4..20]);
Group([ (5,6) ])
gap> T := RcwaMapping([[1,0,2],[3,1,2]]); # The Collatz mapping.
<rcwa mapping of Z with modulus 2>
gap> T = RcwaMapping(2,[[1,2],[2,1],[3,5],[4,2]]);
true
gap> t := RcwaMapping(1,[[-1,1],[1,-1]]); # The involution n -> -n.
Rcwa mapping of Z: n -> -n
gap> d := RcwaMapping([2],[[1/3,0,1]]);
Rcwa mapping of Z_( 2 ): n -> 1/3 n
gap> RcwaMapping([2,3],ShallowCopy(Coefficients(T)));
<rcwa mapping of Z_( 2, 3 ) with modulus 2>
gap> u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);
<rcwa mapping of Z with modulus 5>
gap> r := RcwaMapping( R, x^2 + e,
>                      [ [ x^2 + x + e, z      , x^2 + e ],
>                        [ x^2 + x + e, x      , x^2 + e ],
>                        [ x^2 + x + e, x^2    , x^2 + e ],
>                        [ x^2 + x + e, x^2 + x, x^2 + e ] ] );
<rcwa mapping of GF(2)[x] with modulus x^2+Z(2)^0>
gap> rc := function(r,m) return ResidueClass(DefaultRing(m),m,r); end;;
gap> f1 := RcwaMapping([[rc(1,6),rc(0, 8)],[rc(5,6),rc(4, 8)]]);;
gap> f2 := RcwaMapping([[rc(1,6),rc(0, 4)],[rc(5,6),rc(2, 4)]]);;
gap> f3 := RcwaMapping([[rc(2,6),rc(1,12)],[rc(4,6),rc(7,12)]]);;
gap> List([f1,f2,f3],Order);
[ 2, 2, 2 ]
gap> f := f1*f2*f3;
<bijective rcwa mapping of Z with modulus 12>
gap> Order(f);
infinity
gap> [Multiplier(f),Divisor(f)];
[ 3, 2 ]
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:PrintAndDisplayMappings">
<Heading>Displaying and printing rcwa mappings</Heading>

  In most cases an rcwa mapping is not determined uniquely by the output of
  the <C>ViewObj</C> method -- in these cases the output is enclosed in
  brackets. In any case you can get <Q>all</Q> information about an rcwa
  mapping by <C>Display</C>'ing it:

  <ManSection>
    <Meth Name="Display" Arg="f"/>
    <Description>
      Displays the rcwa mapping <A>f</A> in a nice human-readable form.
<Example>
<![CDATA[
gap> SetName(u,"u");
gap> Display(u);

Rcwa mapping of Z with modulus 5

                n mod 5                |                 n^u
---------------------------------------+--------------------------------------
  0                                    | 3n/5
  1                                    | (9n + 1)/5
  2                                    | (3n - 1)/5
  3                                    | (9n - 2)/5
  4                                    | (9n + 4)/5

gap> SetName(r,"r");
gap> Display(r);

Rcwa mapping of GF(2)[x] with modulus x^2+Z(2)^0

     P mod x^2+Z(2)^0     |                        P^r
--------------------------+---------------------------------------------------
 0*Z(2)                   | (x^2+x+Z(2)^0)*P/(x^2+Z(2)^0)
 Z(2)^0                   | ((x^2+x+Z(2)^0)*P + x)/(x^2+Z(2)^0)
 x                        | ((x^2+x+Z(2)^0)*P + x^2)/(x^2+Z(2)^0)
 x+Z(2)^0                 | ((x^2+x+Z(2)^0)*P + x^2+x)/(x^2+Z(2)^0)

]]>
</Example>
    </Description>
  </ManSection>

  When viewing or displaying rcwa mappings, the respective methods try to
  avoid printing redundant information in some cases -- e.g. if for some
  rcwa mapping a finite order is given, this automatically implies that the
  mapping is tame, and if an rcwa mapping is denoted as bijective and wild
  this implies an infinite order.

  <ManSection>
    <Meth Name="Print" Arg="f"/>
    <Description>
      Prints the rcwa mapping <A>f</A> in &GAP;-readable format.
<Example>
<![CDATA[
gap> Print(T,"\n");
RcwaMapping( [ [ 1, 0, 2 ], [ 3, 1, 2 ] ] )
gap> Print(d,"\n");
RcwaMapping( [ 2 ], [ [ 1/3, 0, 1 ] ] )
gap> Print(r,"\n");
RcwaMapping( 2, x^2+Z(2)^0, [ [ x^2+x+Z(2)^0, 0*Z(2), x^2+Z(2)^0 ], 
  [ x^2+x+Z(2)^0, x, x^2+Z(2)^0 ], [ x^2+x+Z(2)^0, x^2, x^2+Z(2)^0 ], 
  [ x^2+x+Z(2)^0, x^2+x, x^2+Z(2)^0 ] ] )
]]>
</Example>
    </Description>
  </ManSection>

  The string printed by this method may be obtained with

  <ManSection>
    <Meth Name="String" Arg="f"/>
    <Returns>
      a &GAP;-readable string representation of the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> String(d);
"RcwaMapping( [ 2 ], [ [ 1/3, 0, 1 ] ] )"
]]>
</Example>
    </Description>
  </ManSection>

  The following method makes it unnecessary to typeset rcwa mappings of
  <M>\mathbb{Z}</M> in &LaTeX; manually:

  <ManSection>
    <Meth Name="LaTeXObj" Arg="f"/>
    <Returns>
      a &LaTeX; representation of the integral rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      An indentation by <A>Indentation</A> characters can be specified by
      setting this option value accordingly.
      This only applies to rcwa mappings with modulus larger than 1.
<Example>
<![CDATA[
gap> Print(LaTeXObj(u^-1));
n \ \longmapsto \
\begin{cases}
  \frac{5n}{3}     & \text{if} \ n \equiv 0 \ (3), \\
  \frac{5n + 1}{3} & \text{if} \ n \equiv 1 \ (3), \\
  \frac{5n - 1}{9} & \text{if} \ n \equiv 2 \ (9), \\
  \frac{5n + 2}{9} & \text{if} \ n \equiv 5 \ (9), \\
  \frac{5n - 4}{9} & \text{if} \ n \equiv 8 \ (9).
\end{cases}
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ExtractComponents">
<Heading>Extracting the components of rcwa mappings</Heading>

  <ManSection>
    <Oper Name="Modulus" Arg="f" Label="Modulus of an rcwa mapping"/>
    <Returns>the modulus of the rcwa mapping <A>f</A>.</Returns>
    <Description>
      See also <Ref Meth="Modulus" Label="Modulus of an rcwa group"/> for
      rcwa groups, and <Ref Prop="IsTame" Label="Tame rcwa mapping"/>.
<Example>
<![CDATA[
gap> Modulus(u);
5
gap> Modulus(r);
x^2+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="Coefficients" Arg="f"/>
    <Returns>
      the list of coefficients of the rcwa mapping <A>f</A> as described
      above.
   .</Returns>
    <Description>
<Example>
<![CDATA[
gap> Coefficients(T);
[ [ 1, 0, 2 ], [ 3, 1, 2 ] ]
gap> Coefficients(r);
[ [ x^2+x+Z(2)^0, 0*Z(2), x^2+Z(2)^0 ], [ x^2+x+Z(2)^0, x, x^2+Z(2)^0 ], 
  [ x^2+x+Z(2)^0, x^2, x^2+Z(2)^0 ], [ x^2+x+Z(2)^0, x^2+x, x^2+Z(2)^0 ] ]
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="internal representation"></Index>
  It is always taken care that the entries of the stored coefficient triples
  of an rcwa mapping are coprime, that the third entry of any coefficient
  triple equals its standard conjugate and that the number of stored
  coefficient triples equals the number of residue classes modulo the
  modulus of the mapping. Given this, an rcwa mapping determines its internal
  representation uniquely -- thus testing rcwa mappings for equality is
  computationally very cheap:

  <Index Key="rcwa mapping" Subkey="equality"></Index>
  <ManSection>
    <Meth Name="\=" Arg="f, g"/>
    <Description>
      Tests whether the rcwa mappings <A>f</A> and <A>g</A> are equal.
      Since rcwa mappings are stored in a normalized form, this requires
      only comparing their moduli and coefficient lists.
<Example>
<![CDATA[
gap> RcwaMapping([[1,1,1],[2,-2,2],[3,3,3],[4,-4,4]])
>  = RcwaMapping([[1,1,1],[1,-1,1]]);
true
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:MultDiv">
<Heading>Multiplier, divisor, prime set and determinant</Heading>

  <ManSection>
    <Attr Name="Multiplier" Arg="f" Label="Multiplier of an rcwa mapping"/>
    <Description>
      The multiplier of the rcwa mapping <A>f</A>. <P/>

      For the definition see Chapter <Ref Label="ch:Introduction"/>.
<Example>
<![CDATA[
gap> Multiplier(g);
1
gap> Multiplier(u);
9
gap> Multiplier(T);
3
gap> Multiplier(d);
1
gap> Multiplier(r);
x^2+x+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="Divisor" Arg="f" Label="Divisor of an rcwa mapping"/>
    <Description>
      The divisor of the rcwa mapping <A>f</A>. <P/>

      For the definition see Chapter <Ref Label="ch:Introduction"/>.
<Example>
<![CDATA[
gap> Divisor(g);
1
gap> Divisor(u);
5
gap> Divisor(T);
2
gap> Divisor(d);
1
gap> Divisor(r);
x^2+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="PrimeSet" Arg="f" Label="Prime set of an rcwa mapping"/>
    <Returns>the prime set of the rcwa mapping <A>f</A>.</Returns>
    <Description>
      For the definition see Chapter <Ref Label="ch:Introduction"/>.

      See also <Ref Oper="PrimeSet" Label="Prime set of an rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> PrimeSet(T);
[ 2, 3 ]
gap> PrimeSet(u);
[ 3, 5 ]
gap> PrimeSet(T^u);
[ 2, 3 ]
gap> PrimeSet(T^(u^-1));
[ 2, 3, 5 ]
gap> PrimeSet(r);
[ x+Z(2)^0, x^2+x+Z(2)^0 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsIntegral" Arg="f" Label="Integral mapping"/>
    <Description>
      Indicates whether the rcwa mapping <A>f</A> is integral or not.

      For the definition see Chapter <Ref Label="ch:Introduction"/>.

      See also <Ref Prop="IsIntegral" Label="Integral group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> IsIntegral(g);
true
gap> IsIntegral(u);
false
gap> IsIntegral(t);
true
gap> IsIntegral(RcwaMapping([[2,0,1]]));
true
gap> IsIntegral(RcwaMapping([[2,0,1],[3,5,1]]));
true
gap> IsIntegral(RcwaMapping([[1,0,2],[3,5,1]]));
false
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsClassWiseOrderPreserving" Arg="f"
          Label="Class-wise order-preserving rcwa mapping"/>
    <Description>
      Indicates whether the rcwa mapping <A>f</A> is
      class-wise order-preserving or not. Of course this term is
      defined only if the underlying ring is ordered. <P/>

      See also <Ref Prop="IsClassWiseOrderPreserving"
      Label="Class-wise order-preserving rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> IsClassWiseOrderPreserving(g);
true
gap> IsClassWiseOrderPreserving(u);
true
gap> IsClassWiseOrderPreserving(T);
true
gap> IsClassWiseOrderPreserving(t);
false
gap> IsClassWiseOrderPreserving(d);
true
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="SetOnWhichMappingIsOrderReversing" Arg="f"/>
    <Attr Name="SetOnWhichMappingIsConstant" Arg="f"/>
    <Attr Name="SetOnWhichMappingIsOrderPreserving" Arg="f"/>
    <Returns>
      The union of the residue classes (mod <C>Modulus(<A>f</A>)</C>) on
      which the rcwa mapping <A>f</A> is class-wise order-reversing,
      class-wise constant resp. class-wise order-preserving.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> SetOnWhichMappingIsOrderPreserving(T);
Integers
gap> SetOnWhichMappingIsOrderPreserving(u);
Integers
gap> SetOnWhichMappingIsOrderReversing(t);
Integers
gap> SetOnWhichMappingIsOrderPreserving(t);
[  ]
gap> SetOnWhichMappingIsConstant(RcwaMapping([[2,0,1],[0,4,1]]));
1(2)
gap> SetOnWhichMappingIsOrderPreserving(RcwaMapping(Z_pi(2),[[2,0,1],[0,4,1]]));
0(2)
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="Determinant" Arg="f"/>
    <Returns> the determinant of the rcwa mapping <A>f</A>. </Returns>
    <Description>
      The determinant induces an epimorphism from the group of all class-wise
      order-preserving rcwa mappings of <M>\Z</M> onto the additive group
      <M>(\Z,+)</M>.

      For the definition see Chapter <Ref Label="ch:Introduction"/>.
<Example>
<![CDATA[
gap> nu := RcwaMapping([[1,1,1]]);;
gap> a  := RcwaMapping([[3,0,2],[3, 1,4],[3,0,2],[3,-1,4]]);;
gap> b  := RcwaMapping([[3,0,2],[3,13,4],[3,0,2],[3,-1,4]]);;
gap> Determinant(nu);
1
gap> Determinant(a);
0
gap> Determinant(b);
1
gap> Determinant(a^2*b^-1);
-1
gap> Determinant(nu^7*a^2*nu^-1*b^-1*a^-3);
5
gap> Determinant(b^-5*nu^7*a^2*nu^-1*b^-1*a^-3);
0
gap> Determinant(u);
0
gap> Determinant(b^-5*nu^7*a^2*nu^-1*b^-1*a^-3*u);
0
gap> Determinant(u^2*b^-3);
-3
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ImagesAndPreimages">
<Heading>Images and preimages under rcwa mappings</Heading>

  <Index Key="rcwa mapping" Subkey="evaluation"></Index>
  <ManSection>
    <Meth Name="ImageElm" Arg="f, x"/>
    <Meth Name="\^" Arg="f, x"/>
    <Returns>
      the image of the ring element <A>x</A> under the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> 15^T;
23
gap> 7^d;
7/3
gap> p := (x^3+x^2+x+One(R))^r;
x^3+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="image"></Index>
  <ManSection>
    <Meth Name="ImagesSet" Arg="f, S"/>
    <Meth Name="Image" Arg="f, S"/>
    <Meth Name="Image" Arg="f"/>
    <Meth Name="\^" Arg="f, S"/>
    <Returns>
      in the first two forms the image of the set <A>S</A> under the
      rcwa mapping <A>f</A>, and in the third form the image of the
      rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      In particular, <A>S</A> can be a union of residue classes;
      thus, rcwa mappings resp. rcwa groups can act on sets of residue class
      unions as well as on sets of single ring elements.
<Example>
<![CDATA[
gap> ResidueClassUnionViewingFormat("short");
gap> A := ResidueClass(Integers,3,2);
2(3)
gap> Image(T,A);
1(3) U 8(9)
gap> k := RcwaMapping([[-4,-8,1]]);;
gap> Image(k);
0(4)
gap> A^u;
1(9) U 3(9) U 14(27) U 20(27) U 26(27)
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="\^" Arg="f, P"/>
    <Returns>
      the image of the partition <A>P</A> of <C>Source( <A>f</A> )</C>
      under the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      The argument <A>P</A> must be a partition of the source of the
      rcwa mapping <A>f</A> into disjoint residue classes.
<Example>
<![CDATA[
gap> P := [rc(0,2),rc(1,4),rc(3,4)];
[ 0(2), 1(4), 3(4) ]
gap> P^T;
[ Integers, 2(6), 5(6) ]
gap> P^f;
[ 0(6) U 1(6) U 5(6), 2(12) U 4(12) U 9(12), 3(12) U 8(12) U 10(12) ]
gap> last^(f^-1);
[ 0(2), 1(4), 3(4) ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="PreImageElm" Arg="f, x"/>
    <Returns>
      the preimage of the ring element <A>x</A> under the bijective
      rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> PreImageElm(u,8);
4
gap> PreImageElm(d,37/17);
111/17
gap> PreImageElm(r,p);
x^3+x^2+x+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="PreImagesElm" Arg="f, x"/>
    <Returns>
      the set of preimages of the ring element <A>x</A> under the
      rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> PreImagesElm(T,8);
[ 5, 16 ]
gap> PreImagesElm(ZeroIntegralRcwaMapping,0);
Integers
gap> ZeroOne := RcwaMapping([[0,0,1],[0,1,1]]);;
gap> PreImagesElm(ZeroOne,1);
1(2)
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name ="PreImagesRepresentative" Arg="f, x"
          Label="PreImagesRepresentative for rcwa mapping"/>
    <Returns>
      a representative of the set of preimages of <A>x</A> under <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> PreImagesRepresentative(ZeroOne,1);
1
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="PreImagesSet" Arg="f, S"/>
    <Meth Name="PreImage" Arg="f, S"/>
    <Returns>
      the preimage of the set <A>S</A> under the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      In particular, <A>S</A> can be a union of residue classes.
<Example>
<![CDATA[
gap> PreImage(T,A);
1(2) U 4(6)
gap> M := [1];; l := [1];;
gap> while Length(M) < 10000 do M := PreImage(T,M); Add(l,Length(M)); od;
gap> l;
[ 1, 1, 2, 2, 4, 5, 8, 10, 14, 18, 26, 36, 50, 67, 89, 117, 157, 208, 277, 
  367, 488, 649, 869, 1154, 1534, 2039, 2721, 3629, 4843, 6458, 8608, 11472 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="MovedPoints" Arg="f"/>
    <Returns>
      the set of moved points (support) of the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> MovedPoints(u);
Z \ [ -1, 0 ]
gap> MovedPoints(r);
GF(2)[x] \ [ 0*Z(2), Z(2)^0, x, x+Z(2)^0 ]
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:InjectivitySurjectivityBijectivity">
<Heading>Testing for injectivity, surjectivity and bijectivity</Heading>

  <ManSection>
    <Meth Name="IsInjective" Arg="f"/>
    <Description>
      Checks whether the rcwa mapping <A>f</A> is injective.
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="IsSurjective" Arg="f"/>
    <Description>
      Checks whether the rcwa mapping <A>f</A> is surjective.
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="IsBijective" Arg="f"/>
    <Description>
      Checks whether the rcwa mapping <A>f</A> is bijective.
    </Description>
  </ManSection>

<Example>
<![CDATA[
gap> IsInjective(T);
false
gap> IsSurjective(T);
true
gap> IsBijective(u);
true
gap> a_2 := RcwaMapping([2],[[3,0,2],[3,1,4],[3,0,2],[3,-1,4]]);
<rcwa mapping of Z_( 2 ) with modulus 4>
gap> a_23 := RcwaMapping([2,3],[[3,0,2],[3,1,4],[3,0,2],[3,-1,4]]);
<rcwa mapping of Z_( 2, 3 ) with modulus 4>
gap> IsInjective(a_2);
false
gap> IsSurjective(a_2);
true
gap> IsBijective(a_23);
true
gap> IsBijective(r);
true
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:Arithmetic">
<Heading>Arithmetical operations and neutral elements</Heading>

  <Index Key="rcwa mapping" Subkey="sum"></Index>
  <Index Key="rcwa mapping" Subkey="difference"></Index>
  <ManSection>
    <Meth Name="\+" Arg = "f, g"/>
    <Meth Name="\-" Arg = "f, g"/>
    <Returns>
      the (pointwise) sum resp. difference of the rcwa mappings <A>f</A>
      and <A>g</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> a := RcwaMapping([[3,0,2],[3, 1,4],[3,0,2],[3,-1,4]]);;
gap> b := RcwaMapping([[3,0,2],[3,13,4],[3,0,2],[3,-1,4]]);;
gap> Display(a + b);

Rcwa mapping of Z with modulus 4

                n mod 4                |                 n^f
---------------------------------------+--------------------------------------
  0 2                                  | 3n
  1                                    | (3n + 7)/2
  3                                    | (3n - 1)/2

gap> Display(a - b);

Rcwa mapping of Z with modulus 4

                n mod 4                |                 n^f
---------------------------------------+--------------------------------------
  0 2 3                                | 0
  1                                    | -3

gap> d+d+d;
IdentityMapping( Z_( 2 ) )
gap> e := One(r);;
gap> e+e;
ZeroMapping( GF(2)[x], GF(2)[x] )
gap> p^(r+e) = p^r + p;
true
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="product"></Index>
  <ManSection>
    <Meth Name="\*" Arg="f, g"/>
    <Returns>
      the product (composition) of the rcwa mappings <A>f</A> and
      <A>g</A>. The mapping <A>f</A> is applied first.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> Display(a*b);

Rcwa mapping of Z with modulus 16

               n mod 16                |                 n^f
---------------------------------------+--------------------------------------
   0  4  8 12                          | 9n/4
   1                                   | (9n + 55)/16
   2 10                                | (9n - 2)/8
   3 11                                | (9n - 3)/8
   5 13                                | (9n + 3)/8
   6 14                                | (9n + 26)/8
   7                                   | (9n + 49)/16
   9                                   | (9n - 1)/16
  15                                   | (9n - 7)/16

gap> s := RcwaMapping(2,x,[[One(R),Zero(R),One(R)],[x,Zero(R),One(R)]]);
<rcwa mapping of GF(2)[x] with modulus x>
gap> s^2=s; # a non-trivial idempotent
true
gap> IsInjective(s) or IsSurjective(s); # certainly not a group element ...
false
gap> Display(s*r-r*s);

Rcwa mapping of GF(2)[x] with modulus x^3+x

       P mod x^3+x        |                        P^f
--------------------------+---------------------------------------------------
 0*Z(2)                   | 
 Z(2)^0                   | 
 x                        | 
 x^2                      | 
 x^2+Z(2)^0               | 
 x^2+x                    | 0*Z(2)
 x+Z(2)^0                 | 
 x^2+x+Z(2)^0             | x

]]>
</Example>
    </Description>
  </ManSection>

  Multiplying rcwa mappings of the integers and (finite) permutations is
  forbidden, since &GAP;-permutations can only move positive integers
  less than <M>2^{28}</M>; more precisely, one would encounter problems like
  the following:

<Log>
<![CDATA[
gap> (1,2)^RcwaMapping([[-1,0,1]]);
(-2,-1)
gap> (1,2)^RcwaMapping([[1,2^28,1]]);
(268435457,268435458)
]]>
</Log>

  <ManSection>
    <Meth Name="Inverse" Arg="f"/>
    <Returns>
      the inverse mapping <C><A>f</A>&circum;-1</C> of the bijective
      rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> Display(Inverse(u));

Bijective rcwa mapping of Z with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0 3 6                                | 5n/3
  1 4 7                                | (5n + 1)/3
  2                                    | (5n - 1)/9
  5                                    | (5n + 2)/9
  8                                    | (5n - 4)/9

gap> Display(r^-1);

Bijective rcwa mapping of GF(2)[x] with modulus x^2+x+Z(2)^0

    P mod x^2+x+Z(2)^0    |                        P^f
--------------------------+---------------------------------------------------
 0*Z(2)                   | (x^2+Z(2)^0)*P/(x^2+x+Z(2)^0)
 Z(2)^0                   | ((x^2+Z(2)^0)*P + x)/(x^2+x+Z(2)^0)
 x                        | ((x^2+Z(2)^0)*P + x^2)/(x^2+x+Z(2)^0)
 x+Z(2)^0                 | ((x^2+Z(2)^0)*P + x^2+x)/(x^2+x+Z(2)^0)

]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="conjugate"></Index>
  <ManSection>
    <Meth Name="\^" Arg="f, g"/>
    <Returns>
      the conjugate <M>f^g = g^{-1}fg</M> of <A>f</A> under <A>g</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> T^u;
<surjective rcwa mapping of Z with modulus 18>
gap> Display(s^r);

Rcwa mapping of GF(2)[x] with modulus x^3+x^2+x

     P mod x^3+x^2+x      |                        P^f
--------------------------+---------------------------------------------------
 0*Z(2)                   | 
 x                        | 
 x^2                      | 
 x^2+x                    | P
 Z(2)^0                   | 
 x^2+x+Z(2)^0             | x*P
 x+Z(2)^0                 | 
 x^2+Z(2)^0               | x*P + x

]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="zero"></Index>
  <ManSection>
    <Var Name="ZeroIntegralRcwaMapping"/>
    <Meth Name="Zero" Arg="f"/>
    <Description>
      The zero integral rcwa mapping, resp. the zero mapping in the
      family of rcwa mappings <A>f</A> belongs to.
<Example>
<![CDATA[
gap> Zero(a);
ZeroMapping( Integers, Integers )
gap> Zero(r);
ZeroMapping( GF(2)[x], GF(2)[x] )
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="identity"></Index>
  <ManSection>
    <Var Name="IdentityIntegralRcwaMapping"/>
    <Meth Name="One" Arg="f"/>
    <Description>
      The identity integral rcwa mapping, resp. the identity mapping in the
      family of rcwa mappings <A>f</A> belongs to.
<Example>
<![CDATA[
gap> One(a);
IdentityMapping( Integers )
gap> One(d);
IdentityMapping( Z_( 2 ) )
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="no ring under add. and mult.">
    no ring under add. and mult.
  </Index>
  Caution: The set of rcwa mappings over a ring does not form a ring under
  addition and multiplication -- only the left distibutive law is satisfied
  ( <M>a \cdot (b + c) = a \cdot b + a \cdot c</M>, but not necessarily
  <M>(a + b) \cdot c = a \cdot c + b \cdot c</M> ), and the zero mapping
  multiplicatively is only a right zero element ( <M>a \cdot 0 = 0</M> for
  all <M>a</M>, but <M>0 \cdot a = 0</M> if and only if <M>0^a = 0</M> ).

</Section>

<!-- #################################################################### -->

<Section Label="sec:OrderOfRcwaMapping">
<Heading>Computing the order of an rcwa mapping</Heading>

  <ManSection>
    <Meth Name="Order" Arg="f"/>
    <Returns>
      the multiplicative order of the bijective rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      One of the sufficient criteria for <A>f</A> having infinite order
      which are used by this package relies on a currently unproven
      hypothesis. You can get information about the used methods on some
      Info level of <C>InfoRCWA</C>.
<Example>
<![CDATA[
gap> Order(Comm(a,b));
6
gap> Order(u);
infinity
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsTame" Arg="f" Label="Tame rcwa mapping"/>
    <Description>
      Indicates whether or not the rcwa mapping <A>f</A> is tame. For a
      definition see Chapter <Ref Label="ch:Introduction"/>.
      <P/>

      See also <Ref Prop="IsTame" Label="Tame rcwa group"/> for rcwa groups.
<Example>
<![CDATA[
gap> IsTame(T);
false
gap> IsTame(a) or IsTame(b);
false
gap> IsTame(Comm(a,b));
true
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:TransMatGraphTrajectories">
<Heading>Transition matrices, transition graphs and trajectories</Heading>

  <ManSection>
    <Func Name="TransitionMatrix" Arg="f, m"/>
    <Returns>
      the transition matrix of the Markov chain associated to
      the rcwa mapping <A>f</A> and the states <M>r</M>(<A>m</A>) <M>\in</M>
      <M>R</M>/<A>m</A><M>R</M>.
    </Returns>
    <Description>
      <Index Key="rcwa mapping" Subkey="transition matrix"></Index>
      The assignment of the residue classes (mod <A>m</A>) to the rows and
      columns of the matrix is given by the ordering of the residues
      in the return value of <C>AllResidues(<A>m</A>)</C>
      (see <Ref Func="AllResidues"/>).
      The sums of the rows of a transition matrix are always equal to 1.
<Example>
<![CDATA[
gap> M := TransitionMatrix(a,7);;
gap> Display(M);
[ [  1/2,    0,  1/4,    0,    0,  1/4,    0 ],
  [    0,  1/4,    0,    0,  1/4,  1/2,    0 ],
  [  1/4,    0,    0,  3/4,    0,    0,    0 ],
  [    0,  1/2,  1/4,    0,    0,    0,  1/4 ],
  [    0,  1/4,    0,    0,    0,  1/4,  1/2 ],
  [  1/4,    0,    0,    0,  3/4,    0,    0 ],
  [    0,    0,  1/2,  1/4,    0,    0,  1/4 ] ]
gap> DeterminantMat(M);
-81/4096
gap> M := TransitionMatrix(T,19);;
gap> Display(M*One(GF(7)));
 4 . . . . . . . . . 4 . . . . . . . .
 . . 4 . . . . . . . 4 . . . . . . . .
 . 4 . . . . . . . . . . . 4 . . . . .
 . . . . . 4 . . . . . 4 . . . . . . .
 . . 4 . . . . . . . . . . . . . 4 . .
 . . . . . . . . 4 . . . 4 . . . . . .
 4 . . 4 . . . . . . . . . . . . . . .
 . . . . . . . . . . . 4 . 4 . . . . .
 . . . 4 4 . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . 1 . . . .
 . . . . . 4 4 . . . . . . . . . . . .
 . . . . . . . . . . . . . . . 4 . 4 .
 . . . . . . 4 . . 4 . . . . . . . . .
 . 4 . . . . . . . . . . . . . . 4 . .
 . . . . . . . 4 . . . . 4 . . . . . .
 . . . . 4 . . . . . . . . . . . . 4 .
 . . . . . . . . 4 . . . . . . 4 . . .
 . . . . . . . 4 . . . . . . . . . . 4
 . . . . . . . . . 4 . . . . . . . . 4
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="TransitionGraph" Arg="f, m"/>
    <Returns>
      the transition graph for modulus <A>m</A> of the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      <Index Key="rcwa mapping" Subkey="transition graph"></Index>
      We define the <E>transition graph</E> <M>\Gamma_{f,m}</M>
      of <M>f</M> for modulus <M>m</M> as follows:
      <Enum>
        <Item>
          The vertices are the residue classes (mod <M>m</M>).
        </Item>
        <Item>
          There is an edge from <M>r_1(m)</M> to <M>r_2(m)</M> if and only if
          there is some <M>n_1 \in r_1(m)</M> such that
          <M>n_1^f \in r_2(m)</M>.
        </Item>
      </Enum>
      The assignment of the residue classes (mod <M>m</M>) to the vertices
      of the graph is given by the ordering of the residues in the return
      value of <C>AllResidues(<A>m</A>)</C> (see <Ref Func="AllResidues"/>).
      <P/>

      The result is returned as a <Package>GRAPE</Package>-graph.
<Example>
<![CDATA[
gap> TransitionGraph(a,Modulus(a));
rec( isGraph := true, order := 4, group := Group(()), 
  schreierVector := [ -1, -2, -3, -4 ], 
  adjacencies := [ [ 1, 3 ], [ 1, 2, 3, 4 ], [ 2, 4 ], [ 1, 2, 3, 4 ] ], 
  representatives := [ 1, 2, 3, 4 ], names := [ 1, 2, 3, 4 ] )
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="OrbitsModulo" Arg="f, m"
          Label="OrbitsModulo for rcwa mapping"/>
    <Returns>
      the partition of <C>AllResidues(<A>m</A>)</C> corresponding to
      the weakly-connected components of the transition graph for modulus
      <A>m</A> of the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      See also <Ref Meth="OrbitsModulo" Label="OrbitsModulo for rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> OrbitsModulo(Comm(a,b),9);
[ [ 0 ], [ 1, 4, 5, 6, 7 ], [ 2 ], [ 3 ], [ 8 ] ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name ="FactorizationOnConnectedComponents" Arg = "f, m"/>
    <Returns>
      the set of restrictions of the rcwa mapping <A>f</A> to the
      weakly-connected components of its transition graph
      <M>\Gamma_{f,m}</M>.
    </Returns>
    <Description>
      These mappings have pairwisely disjoint supports, hence any two
      of them commute, and their product equals <A>f</A>.
<Example>
<![CDATA[
gap> sigma := RcwaMapping([[1, 0,1],[1, 1,1],[2,2,1],[3,-3,2],
>                          [1, 0,1],[1,-2,3],[3,6,2],[1,-2,1],
>                          [1, 0,1],[1, 1,1],[1,1,1],[1,-2,1],
>                          [2, 0,1],[1, 1,1],[1,1,1],[3,-3,2],
>                          [1, 0,1],[1, 1,1],[3,6,2],[1,-2,1],
>                          [1, 0,1],[1, 1,1],[1,1,1],[2,-4,1],
>                          [1,-3,3],[1, 1,1],[1,1,1],[3,-3,2],
>                          [1, 0,1],[2, 2,1],[3,6,2],[1,-2,1],
>                          [1, 0,1],[1, 1,1],[1,1,1],[1,-2,1]]);
<rcwa mapping of Z with modulus 36>
gap> fact := FactorizationOnConnectedComponents(sigma,36);
[ <rcwa mapping of Z with modulus 36>, <rcwa mapping of Z with modulus 36>, 
  <rcwa mapping of Z with modulus 36> ]
gap> List(fact,MovedPoints);
[ 33(36) U 34(36) U 35(36), 9(36) U 10(36) U 11(36), 
  <union of 23 residue classes (mod 36)> \ [ -6, 3 ] ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="Trajectory" Arg="f, n, val, cond"/>
    <Description>
      This function computes the trajectory of <A>n</A> under the
      rcwa mapping <A>f</A>. The parameter <A>val</A> can either specify the
      length of the sequence to be computed or be a <Q>stopping set</Q>
      such that the computation stops when some iterate
      <C><A>n</A>&circum;(<A>f</A>&circum;k) in <A>val</A></C> is reached,
      depending on whether <C><A>cond</A> = "length"</C> or
      <C><A>cond</A> = "stop"</C>.
<Example>
<![CDATA[
gap> Trajectory(a,8,100,"length");
[ 8, 12, 18, 27, 20, 30, 45, 34, 51, 38, 57, 43, 32, 48, 72, 108, 162, 243, 
  182, 273, 205, 154, 231, 173, 130, 195, 146, 219, 164, 246, 369, 277, 208, 
  312, 468, 702, 1053, 790, 1185, 889, 667, 500, 750, 1125, 844, 1266, 1899, 
  1424, 2136, 3204, 4806, 7209, 5407, 4055, 3041, 2281, 1711, 1283, 962, 
  1443, 1082, 1623, 1217, 913, 685, 514, 771, 578, 867, 650, 975, 731, 548, 
  822, 1233, 925, 694, 1041, 781, 586, 879, 659, 494, 741, 556, 834, 1251, 
  938, 1407, 1055, 791, 593, 445, 334, 501, 376, 564, 846, 1269, 952 ]
gap> Trajectory(T,27,[1],"stop");
[ 27, 41, 62, 31, 47, 71, 107, 161, 242, 121, 182, 91, 137, 206, 103, 155, 
  233, 350, 175, 263, 395, 593, 890, 445, 668, 334, 167, 251, 377, 566, 283, 
  425, 638, 319, 479, 719, 1079, 1619, 2429, 3644, 1822, 911, 1367, 2051, 
  3077, 4616, 2308, 1154, 577, 866, 433, 650, 325, 488, 244, 122, 61, 92, 46, 
  23, 35, 53, 80, 40, 20, 10, 5, 8, 4, 2, 1 ]
gap> Trajectory(T,ResidueClass(Integers,3,0),Integers,"stop");
[ 0(3), 0(3) U 5(9), 0(3) U 5(9) U 7(9) U 8(27), 
  <union of 20 residue classes (mod 27)>, <union of 73 residue classes (mod 
    81)>, <union of 79 residue classes (mod 81)>, Integers ]
gap> Length(Trajectory(RcwaMapping([[1,0,2],[5,-1,2]]),19,[1],"stop"));
307
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="TrajectoryModulo" Arg="f, n, m, lng"/>
    <Func Name="TrajectoryModulo" Arg="f, n, lng"/>
    <Returns>
      the sequence <M>(n_i), i = 0, \dots, lng-1</M> with
      <M>n_i := n^{(f^i)}</M> mod <A>m</A> as a list.
    </Returns>
    <Description>
      If <A>m</A> is not given it defaults to the modulus of <A>f</A>.
<Example>
<![CDATA[
gap> TrajectoryModulo(a,8,25);
[ 0, 0, 2, 3, 0, 2, 1, 2, 3, 2, 1, 3, 0, 0, 0, 0, 2, 3, 2, 1, 1, 2, 3, 1, 2 ]
gap> TrajectoryModulo(T,27,2,100);
[ 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 
  0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 
  1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="CoefficientsOnTrajectory" Arg="f, n, val, cond, all"/>
    <Description>
      This function computes something which we might call <Q>accumulated
      coefficients</Q> on the trajectory of <A>n</A> under the rcwa mapping
      <A>f</A>. More precisely: it computes a list <C>c</C> of coefficient
      triples such that for any <C>k</C>, we have
      <C><A>n</A>&circum;(<A>f</A>&circum;(k-1)) = (c[k][1]*<A>n</A> +
      c[k][2])/c[k][3]</C>. The meaning of the arguments <A>val</A> and
      <A>cond</A> is the same as in <Ref Func="Trajectory"/>.
      If <C><A>all</A> = true</C>, the whole sequence of coefficient triples
      is returned, otherwise the result is only the last triple.
<Example>
<![CDATA[
gap> CoefficientsOnTrajectory(T,27,1,"stop",false);
[ 36472996377170786403, 195820718533800070543, 1180591620717411303424 ]
gap> (last[1]*27+last[2])/last[3];
1
gap> CoefficientsOnTrajectory(sigma,37,37,"stop",true);
[ [ 1, 0, 1 ], [ 1, 1, 1 ], [ 2, 4, 1 ], [ 3, 9, 1 ], [ 6, 18, 1 ], 
  [ 2, 5, 1 ], [ 2, 3, 1 ], [ 2, 1, 3 ], [ 2, 4, 3 ], [ 2, 7, 3 ], 
  [ 1, 2, 1 ], [ 3, 3, 2 ], [ 3, 5, 2 ], [ 3, 7, 2 ], [ 3, 3, 1 ], 
  [ 9, 15, 2 ], [ 27, 57, 4 ], [ 27, 57, 2 ], [ 9, 17, 2 ], [ 9, 13, 2 ], 
  [ 9, 15, 1 ], [ 3, 4, 1 ], [ 3, 2, 1 ], [ 1, 0, 1 ] ]
gap> List(last,c->(c[1]*37+c[2])/c[3]){[1..23]} = Cycle(sigma,37);
true
gap> CoefficientsOnTrajectory(a,8,10,"length",true);
[ [ 1, 0, 1 ], [ 3, 0, 2 ], [ 9, 0, 4 ], [ 27, 0, 8 ], [ 81, -8, 32 ], 
  [ 243, -24, 64 ], [ 729, -72, 128 ], [ 2187, -88, 512 ], 
  [ 6561, -264, 1024 ], [ 19683, -1816, 4096 ] ]
gap> CoefficientsOnTrajectory(r,x^3+x^2,x^3+x^2,"stop",true);
[ [ Z(2)^0, 0*Z(2), Z(2)^0 ], [ x^2+x+Z(2)^0, x^2+x, x^2+Z(2)^0 ], 
  [ x^4+x^2+Z(2)^0, x^4+x, x^4+Z(2)^0 ], 
  [ x^6+x^5+x^3+x+Z(2)^0, x^6+x^4+x^3+x^2, x^6+x^4+x^2+Z(2)^0 ], 
  [ x^8+x^4+Z(2)^0, x^7+x^6, x^8+Z(2)^0 ] ]
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:NonBijectiveMappings">
<Heading>
  Special functions for non-bijective mappings and miscellanea
</Heading>

  <ManSection>
    <Oper Name="ContractionCentre" Arg="f, maxn, bound"/>
    <Description>
      Tries to compute the <E>contraction centre</E> of an rcwa mapping -
      assuming its existence this is the uniquely-defined finite subset
      <M>S_0</M> of the base ring <M>R</M> which is mapped bijectively onto
      itself under <A>f</A> and where for any <M>x</M> in <M>R</M> there is
      an integer <M>k</M> such that the image of <M>x</M> under the
      <M>k</M>-th power of <M>f</M> lies in <M>S_0</M>.
      The mapping <A>f</A> is assumed to be <E>contracting</E>, i.e.
      to have such a contraction centre.
      As this problem seems to be computationally undecidable methods will be
      probabilistic. The argument <A>maxn</A> is a bound on the starting
      value and <A>bound</A> is a bound on the elements of the sequences
      to be searched.
      If the limit <A>bound</A> is exceeded, an Info message on some Info
      level of <C>InfoRCWA</C> is given.
<Example>
<![CDATA[
gap> S0 := ContractionCentre(T,100,1000);
[ -136, -91, -82, -68, -61, -55, -41, -37, -34, -25, -17, -10, -7, -5, -1, 0, 
  1, 2 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="Divergence" Arg="f"/>
    <Description>
      The <E>divergence</E> of the rcwa mapping <A>f</A>.
      This is conjectured to be a measure for how fast an rcwa mapping
      contracts (if its divergence is smaller than 1) or how fast its
      trajectories diverge (if its divergence is larger than 1),
      provided that its transition graph for modulus Mod(<A>f</A>)
      is weakly-connected. <P/>

      We do not give a definition here as in the future it may turn out
      that defining the divergence in another way than we currently do
      is more suitable.
<Example>
<![CDATA[
gap> Divergence(T);
0.866025
gap> Rat(last^2);
3/4
gap> Divergence(g);
1
gap> Divergence(a);
1.06066
gap> Rat(last^2);
9/8
gap> Divergence(a^-1);
1.05827
gap> Rat(last^3);
32/27
gap> Divergence(u);
1.15991
gap> Rat(last^5);
6561/3125
gap> Divergence(a)*Divergence(u);
1.23027
gap> Divergence(a*u);
1.23027
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="ImageDensity" Arg="f"/>
    <Description>
      We define the <E>image density</E> of an rcwa mapping <A>f</A> of
      a ring <M>R</M> by the sum of the densities of the images of the
      affine partial mappings of <A>f</A>, where we set the density
      of a residue class <M>r(m)</M> equal to <M>1/|R/mR|</M>.
      Injective rcwa mappings have an image density of at most 1, and the
      image density of a surjective rcwa mapping is at least 1 -- thus in
      particular the image density of a bijective mapping equals 1.
<Example>
<![CDATA[
gap> ImageDensity(T);
4/3
gap> ImageDensity(a);
1
gap> ImageDensity(RcwaMapping([[2,0,1]]));
1/2
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:CategoriesOfRcwaMappings">
<Heading>The categories and families of rcwa mappings</Heading>

  <ManSection>
    <Filt Name="IsRcwaMapping" Arg="f"/>
    <Description>
      The category of all rcwa mappings.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsIntegralRcwaMapping" Arg="f"/>
    <Description>
      The category of all rcwa mappings of the ring of integers.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsSemilocalIntegralRcwaMapping" Arg="f"/>
    <Description>
      The category of all rcwa mappings of semilocalizations of the
      ring of integers.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsModularRcwaMapping" Arg="f"/>
    <Description>
      The category of all rcwa mappings of polynomial rings in one
      variable over some finite field.
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="RcwaMappingsFamily" Arg="R"/>
    <Returns>
      the family of rcwa mappings of the ring <A>R</A>.
    </Returns>
  </ManSection>

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->










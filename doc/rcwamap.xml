<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  rcwamap.xml          RCWA documentation          Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$      ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:RcwaMappings">
<Heading>Residue Class-Wise Affine Mappings</Heading>

This chapter describes the functionality available for computing with
rcwa mappings. <P/>

<!-- #################################################################### -->

<Section Label="sec:CategoriesOfRcwaMappings">
<Heading>The categories and families of rcwa mappings</Heading>

  <ManSection>
    <Filt Name="IsRcwaMapping" Arg="f"/>
    <Description>
      The category of all rcwa mappings.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsIntegralRcwaMapping" Arg="f"/>
    <Description>
      The category of all rcwa mappings of the ring of integers.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsSemilocalIntegralRcwaMapping" Arg="f"/>
    <Description>
      The category of all rcwa mappings of semilocalizations of the
      ring of integers.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsModularRcwaMapping" Arg="f"/>
    <Description>
      The category of all rcwa mappings of polynomial rings in one
      variable over some finite field.
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="RcwaMappingsFamily" Arg="R"/>
    <Returns>
      the family of rcwa mappings over the ring <A>R</A>.
    </Returns>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ConstructingRcwaMappings">
<Heading>Constructing rcwa mappings</Heading>

  <ManSection>
    <Meth Name="RcwaMapping" Arg="R, modulus, coeffs"/>
    <Meth Name="RcwaMapping" Arg="R, coeffs"/>
    <Meth Name="RcwaMapping" Arg="coeffs"/>
    <Meth Name="RcwaMapping" Arg="perm, range"/>
    <Meth Name="RcwaMapping" Arg="modulus, values"/>
    <Meth Name="RcwaMapping" Arg="pi, coeffs"/>
    <Meth Name="RcwaMapping" Arg="q, modulus, coeffs"/>
    <Meth Name="RcwaMapping" Arg="cycles"/>
    <Description>
      Returns the rcwa mapping
      <List>
        <Mark>(a)</Mark>
        <Item>
          with modulus <A>modulus</A> and coefficients <A>coeffs</A>
          over the ring <A>R</A>, resp.
        </Item>
        <Mark>(b)</Mark>
        <Item>
          with coefficients <A>coeffs</A> over the ring <A>R</A>,
          if this information is sufficient, resp.
        </Item>
        <Mark>(c)</Mark>
        <Item>
          with coefficients <A>coeffs</A>, if already this
          information is sufficient, resp.
        </Item>
        <Mark>(d)</Mark>
        <Item>
          acting on the translates of <A>range</A> by integral multiples
          of the length of <A>range</A> as the translates of the action of
          the finite permutation <A>perm</A> on <A>range</A> to the
          respective intervals, where moved points of <A>perm</A> outside
          <A>range</A> are ignored (<A>range</A> must entirely consist out
          of positive integers less than <M>2^{28}</M>, since &GAP;
          permutations can only move these), resp.
        </Item>
        <Mark>(e)</Mark>
        <Item>
          with modulus <A>modulus</A> and with values prescribed by the list
          <A>val</A>, which consists of 2<M>\cdot</M><A>modulus</A> pairs
          giving preimage and image for 2 points per residue class
          (mod <A>modulus</A>), resp.
        </Item>
        <Mark>(f)</Mark>
        <Item>
          of <M>\Z_{(\pi)}</M> with coefficients
          <A>coeffs</A>, where the set of primes <M>\pi</M> 
          is given as argument <A>pi</A>, resp.
        </Item>
        <Mark>(g)</Mark>
        <Item>
          of GF( <A>q</A> )[ <A>x</A> ] with modulus
          <A>modulus</A> and coefficients <A>coeffs</A>, resp.
        </Item>
        <Mark>(h)</Mark>
        <Item>
          an arbitrary rcwa mapping with <Q>residue class cycles</Q> as given
          by <A>cycles</A>. The latter is a list of lists of residue classes
          which the mapping should permute cyclically, each.
        </Item>
      </List>
      Assuming that <M>m</M>=<A>modulus</A> is the modulus of the rcwa
      mapping to be constructed, the argument <A>coeffs</A> is a list of
      <M>|R/mR|</M> lists of three elements of <A>R</A>, each, giving the
      coefficients <M>a_r</M>, <M>b_r</M> and <M>c_r</M>
      (cp. section <Ref Label="sec:BasicDefinitions"/>)
      for <M>r</M> running through a set of representatives
      for the residue classes (mod <M>m</M>).
      The ordering of these triples is specified by the ordering of the
      residues <M>r</M> mod <M>m</M> in the return value of
      <C>AllResidues(m)</C> (see <Ref Func="AllResidues"/>).
      The methods for the operation <C>RcwaMapping</C> perform a number of
      argument checks, which can be skipped by using <C>RcwaMappingNC</C>
      instead.
<Example>
<![CDATA[
gap> f := RcwaMapping([[1,1,1],[1,-1,1],[1,1,1],[1,-1,1]]);
<integral rcwa mapping with modulus 2>
gap> f = RcwaMapping((2,3),[2..3]);
true
gap> g := RcwaMapping((1,2,3)(8,9),[4..20]);
<integral rcwa mapping with modulus 17>
gap> Action(Group(g),[4..20]);
Group([ (5,6) ])
gap> T := RcwaMapping([[1,0,2],[3,1,2]]); # The Collatz mapping.
<integral rcwa mapping with modulus 2>
gap> T = RcwaMapping(2,[[1,2],[2,1],[3,5],[4,2]]);
true
gap> t := RcwaMapping(1,[[-1,1],[1,-1]]); # The involution n -> -n.
Integral rcwa mapping: n -> -n
gap> d := RcwaMapping([2],[[1/3,0,1]]);
Rcwa mapping of Z_( 2 ): n -> 1/3 n
gap> RcwaMapping([2,3],ShallowCopy(Coefficients(T)));
<rcwa mapping of Z_( 2, 3 ) with modulus 2>
gap> R := PolynomialRing(GF(2),1);;
gap> x := IndeterminatesOfPolynomialRing(R)[1];; SetName(x,"x");;
gap> e := One(GF(2));; z := Zero(R);;
gap> r := RcwaMapping( 2, x^2 + e,
>                      [ [ x^2 + x + e, z      , x^2 + e ],
>                        [ x^2 + x + e, x      , x^2 + e ],
>                        [ x^2 + x + e, x^2    , x^2 + e ],
>                        [ x^2 + x + e, x^2 + x, x^2 + e ] ] );
<rcwa mapping of GF(2)[x] with modulus x^2+Z(2)^0>
gap> rc := function(r,m) return ResidueClass(DefaultRing(m),m,r); end;;
gap> f1 := RcwaMapping([[rc(1,6),rc(0, 8)],[rc(5,6),rc(4, 8)]]);;
gap> f2 := RcwaMapping([[rc(1,6),rc(0, 4)],[rc(5,6),rc(2, 4)]]);;
gap> f3 := RcwaMapping([[rc(2,6),rc(1,12)],[rc(4,6),rc(7,12)]]);;
gap> List([f1,f2,f3],Order);
[ 2, 2, 2 ]
gap> f  := f1*f2*f3;
<bijective integral rcwa mapping with modulus 12>
gap> Order(f);
infinity
gap> [Multiplier(f),Divisor(f)];
[ 3, 2 ]
]]>
</Example>
    </Description>
  </ManSection>

  The following is the auxiliary function for determining the correct order
  of the coefficient triples of an rcwa mapping we already referred to
  (to be precise, this function is part of the &ResClasses; package, but is
  documented here since in &ResClasses; it is only used for internal
  purposes):

  <ManSection>
    <Func Name="AllResidues" Arg="R, m"/>
    <Returns>
      a sorted list of all residues modulo <A>m</A> in the ring <A>R</A>.
    </Returns>
    <Description>
      This defines also the ordering in which the coefficients of an
      rcwa mapping are stored; thus, if <A>f</A> is an rcwa mapping
      of <A>R</A> with coefficients list <A>c</A> and modulus <A>m</A>,
      then <A>f</A> maps an element <A>n</A> of <A>R</A>
      with <A>n</A> mod <A>m</A> = <A>r</A> to <P/>
      <Log>
        <![CDATA[
        ( c[ Position( res, r ) ][ 1 ] * n + c[ Position( res, r ) ][ 2 ] ) /
          c[ Position( res, r ) ][ 3 ]]]>
      </Log>
      where <A>res</A> denotes the list of residues returned
      by this function.
<Example>
<![CDATA[
gap> AllResidues(Integers,6);
[ 0 .. 5 ]
gap> AllResidues(R,x^4+x^2);
[ 0*Z(2), Z(2)^0, x, x+Z(2)^0, x^2, x^2+Z(2)^0, x^2+x, x^2+x+Z(2)^0, x^3, 
  x^3+Z(2)^0, x^3+x, x^3+x+Z(2)^0, x^3+x^2, x^3+x^2+Z(2)^0, x^3+x^2+x, 
  x^3+x^2+x+Z(2)^0 ]
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="internal representation"></Index>
  The internal representation of an rcwa mapping of any kind is always
  converted to a normalized (reduced) form, i.e. for all <M>r</M>, the
  coefficients <M>a_r</M>, <M>b_r</M> and <M>c_r</M> are divided by their
  gcd and then multiplied by a suitable unit such that <M>c_r</M> equals
  its <Q>standard associate</Q>, and the mapping is reduced to its
  modulus (the latter means that the number of stored triples can never
  be a proper multiple of the number of residue classes mod Mod(<M>f</M>)).

</Section>

<!-- #################################################################### -->

<Section Label="sec:ExtractComponents">
<Heading>Extracting the components of rcwa mappings</Heading>

  <ManSection>
    <Meth Name="Coefficients" Arg="f"/>
    <Returns>the coefficients of the rcwa mapping <A>f</A>.</Returns>
    <Description>
      The coefficients are returned as a list of triples
      <M>(a_r,b_r,c_r)</M> (cp. section <Ref Label="sec:BasicDefinitions"/>).
      The ordering of these triples is specified by the ordering of the
      residues <M>r</M> mod <M>m</M> in the return value of
      <C>AllResidues(m)</C> (see <Ref Func="AllResidues"/>),
      where <M>m</M> is the modulus of <A>f</A>.
<Example>
<![CDATA[
gap> Coefficients(T);
[ [ 1, 0, 2 ], [ 3, 1, 2 ] ]
gap> Coefficients(r);
[ [ x^2+x+Z(2)^0, 0*Z(2), x^2+Z(2)^0 ], [ x^2+x+Z(2)^0, x, x^2+Z(2)^0 ], 
  [ x^2+x+Z(2)^0, x^2, x^2+Z(2)^0 ], [ x^2+x+Z(2)^0, x^2+x, x^2+Z(2)^0 ] ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="Modulus" Arg="f" Label="Modulus of an rcwa mapping"/>
    <Returns>the modulus of the rcwa mapping <A>f</A>.</Returns>
    <Description>
      For the definition see section
      <Ref Label="sec:FurtherBasicDefinitions"/>. <P/>

      See also <Ref Meth="Modulus" Label="Modulus of an rcwa group"/> for
      rcwa groups, and <Ref Prop="IsTame" Label="Tame rcwa mapping"/>.
<Example>
<![CDATA[
gap> u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;
gap> Modulus(u);
5
gap> Modulus(r);
x^2+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:MultDiv">
<Heading>Multiplier and divisor</Heading>

  <ManSection>
    <Attr Name="Multiplier" Arg="f"/>
    <Description>
      The multiplier of the rcwa mapping <A>f</A>. <P/>

      For the definition see section
      <Ref Label="sec:FurtherBasicDefinitions"/>.
<Example>
<![CDATA[
gap> Multiplier(g);
1
gap> Multiplier(u);
9
gap> Multiplier(T);
3
gap> Multiplier(d);
1
gap> Multiplier(r);
x^2+x+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="Divisor" Arg="f"/>
    <Description>
      The divisor of the rcwa mapping <A>f</A>. <P/>

      For the definition see section
      <Ref Label="sec:FurtherBasicDefinitions"/>.
<Example>
<![CDATA[
gap> Divisor(g);
1
gap> Divisor(u);
5
gap> Divisor(T);
2
gap> Divisor(d);
1
gap> Divisor(r);
x^2+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="PrimeSet" Arg="f" Label="Prime set of an rcwa mapping"/>
    <Returns>the prime set of the rcwa mapping <A>f</A>.</Returns>
    <Description>
      <Index Key="rcwa mapping" Subkey="prime set"></Index>
      The <E>prime set</E> of an rcwa mapping is the set of prime divisors
      of the product of its modulus, its multiplier and its divisor. <P/>

      See also <Ref Oper="PrimeSet" Label="Prime set of an rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> PrimeSet(T);
[ 2, 3 ]
gap> PrimeSet(u);
[ 3, 5 ]
gap> PrimeSet(T^u);
[ 2, 3 ]
gap> PrimeSet(T^(u^-1));
[ 2, 3, 5 ]
gap> PrimeSet(r);
[ x+Z(2)^0, x^2+x+Z(2)^0 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsIntegral" Arg="f" Label="Integral mapping"/>
    <Description>
      <Index Key="rcwa mapping" Subkey="integral"></Index>
      Indicates whether the rcwa mapping <A>f</A> is integral or not.
      We call an rcwa mapping <A>f</A> <E>integral</E> if its divisor is
      equal to 1.
      Be careful not to confuse this with the term <E>integral rcwa
      mapping</E> for rcwa mappings of the integers; normally it should
      be rather clear what is meant. <P/>

      See also <Ref Prop="IsIntegral" Label="Integral group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> IsIntegral(g);
true
gap> IsIntegral(u);
false
gap> IsIntegral(t);
true
gap> IsIntegral(RcwaMapping([[2,0,1]]));
true
gap> IsIntegral(RcwaMapping([[2,0,1],[3,5,1]]));
true
gap> IsIntegral(RcwaMapping([[1,0,2],[3,5,1]]));
false
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsClassWiseOrderPreserving" Arg="f"
          Label="Class-wise order-preserving rcwa mapping"/>
    <Description>
      Indicates whether the rcwa mapping <A>f</A> is
      class-wise order-preserving or not. Of course this term is
      defined only if the underlying ring is ordered. <P/>

      See also <Ref Prop="IsClassWiseOrderPreserving"
      Label="Class-wise order-preserving rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> IsClassWiseOrderPreserving(g);
true
gap> IsClassWiseOrderPreserving(u);
true
gap> IsClassWiseOrderPreserving(T);
true
gap> IsClassWiseOrderPreserving(t);
false
gap> IsClassWiseOrderPreserving(d);
true
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:CheckEquality">
<Heading>Checking for equality</Heading>

  <Index Key="rcwa mapping" Subkey="equality"></Index>
  <ManSection>
    <Meth Name="\=" Arg="f, g"/>
    <Description>
      Tests whether the rcwa mappings <A>f</A> and <A>g</A> are equal.
      Since rcwa mappings are stored in a normalized form, this requires
      only comparing their moduli and coefficient lists.
<Example>
<![CDATA[
gap> RcwaMapping([[1,1,1],[2,-2,2],[3,3,3],[4,-4,4]])
>  = RcwaMapping([[1,1,1],[1,-1,1]]);
true
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:PrintAndDisplayMappings">
<Heading>Printing and displaying rcwa mappings</Heading>

  <ManSection>
    <Meth Name="Print" Arg="f"/>
    <Description>
      Prints the rcwa mapping <A>f</A> in &GAP;-readable format.
<Example>
<![CDATA[
gap> Print(T,"\n");
RcwaMapping( [ [ 1, 0, 2 ], [ 3, 1, 2 ] ] )
gap> Print(d,"\n");
RcwaMapping( [ 2 ], [ [ 1/3, 0, 1 ] ] )
gap> Print(r,"\n");
RcwaMapping( 2, x^2+Z(2)^0, [ [ x^2+x+Z(2)^0, 0*Z(2), x^2+Z(2)^0 ], 
  [ x^2+x+Z(2)^0, x, x^2+Z(2)^0 ], [ x^2+x+Z(2)^0, x^2, x^2+Z(2)^0 ], 
  [ x^2+x+Z(2)^0, x^2+x, x^2+Z(2)^0 ] ] )
]]>
</Example>
    </Description>
  </ManSection>

  The string printed by this method may be obtained with

  <ManSection>
    <Meth Name="String" Arg="f"/>
    <Returns>
      a &GAP;-readable string representation of the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> String(d);
"RcwaMapping( [ 2 ], [ [ 1/3, 0, 1 ] ] )"
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="Display" Arg="f"/>
    <Description>
      Displays the rcwa mapping <A>f</A> in a nice human-readable form.
<Example>
<![CDATA[
gap> SetName(u,"u");
gap> Display(u);

Bijective integral rcwa mapping with modulus 5

                n mod 5                |                 n^u
---------------------------------------+--------------------------------------
  0                                    | 3n/5
  1                                    | (9n + 1)/5
  2                                    | (3n - 1)/5
  3                                    | (9n - 2)/5
  4                                    | (9n + 4)/5

gap> SetName(r,"r");
gap> Display(r);

Rcwa mapping of GF(2)[x] with modulus x^2+Z(2)^0

     P mod x^2+Z(2)^0     |                        P^r
--------------------------+---------------------------------------------------
 0*Z(2)                   | (x^2+x+Z(2)^0)*P/(x^2+Z(2)^0)
 Z(2)^0                   | ((x^2+x+Z(2)^0)*P + x)/(x^2+Z(2)^0)
 x                        | ((x^2+x+Z(2)^0)*P + x^2)/(x^2+Z(2)^0)
 x+Z(2)^0                 | ((x^2+x+Z(2)^0)*P + x^2+x)/(x^2+Z(2)^0)

]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="LaTeXObj" Arg="f"/>
    <Returns>
      a &LaTeX; representation of the integral rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      An indentation by <A>Indentation</A> characters can be specified by
      setting this option value accordingly.
      This only applies to rcwa mappings with modulus larger than 1.
<Example>
<![CDATA[
gap> Print(LaTeXObj(u^-1));
n \ \longmapsto \
\begin{cases}
  \frac{5n}{3}      & \text{if} \ n \equiv 0 \ (3), \\
  \frac{5n + 1}{3}  & \text{if} \ n \equiv 1 \ (3), \\
  \frac{5n - 1}{9}  & \text{if} \ n \equiv 2 \ (9), \\
  \frac{5n + 2}{9}  & \text{if} \ n \equiv 5 \ (9), \\
  \frac{5n - 4}{9}  & \text{if} \ n \equiv 8 \ (9).
\end{cases}
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ImagesAndPreimages">
<Heading>Images and preimages under rcwa mappings</Heading>

  <Index Key="rcwa mapping" Subkey="evaluation"></Index>
  <ManSection>
    <Meth Name="ImageElm" Arg="f, x"/>
    <Meth Name="\^" Arg="f, x"/>
    <Returns>
      the image of the ring element <A>x</A> under the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> 15^T;
23
gap> 7^d;
7/3
gap> p := (x^3+x^2+x+One(R))^r;
x^3+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="image"></Index>
  <ManSection>
    <Meth Name="ImagesSet" Arg="f, S"/>
    <Meth Name="Image" Arg="f, S"/>
    <Meth Name="Image" Arg="f"/>
    <Meth Name="\^" Arg="f, S"/>
    <Returns>
      in the first two forms the image of the set <A>S</A> under the
      rcwa mapping <A>f</A>, and in the third form the image of the
      rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      In particular, <A>S</A> can be a union of residue classes;
      thus, rcwa mappings resp. rcwa groups can act on sets of residue class
      unions as well as on sets of single ring elements.
<Example>
<![CDATA[
gap> ResidueClassUnionViewingFormat("short");
gap> A := ResidueClass(Integers,3,2);
2(3)
gap> Image(T,A);
1(3) U 8(9)
gap> k := RcwaMapping([[-4,-8,1]]);;
gap> Image(k);
0(4)
gap> A^u;
1(9) U 3(9) U 14(27) U 20(27) U 26(27)
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="PreImageElm" Arg="f, x"/>
    <Returns>
      the preimage of the ring element <A>x</A> under the bijective
      rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> PreImageElm(u,8);
4
gap> PreImageElm(d,37/17);
111/17
gap> PreImageElm(r,p);
x^3+x^2+x+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  If the mapping <A>f</A> is not bijective, we can use

  <ManSection>
    <Meth Name="PreImagesElm" Arg="f, x"/>
    <Returns>
      the set of preimages of the ring element <A>x</A> under the
      rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> PreImagesElm(T,8);
[ 5, 16 ]
gap> PreImagesElm(ZeroIntegralRcwaMapping,0);
Integers
gap> ZeroOne := RcwaMapping([[0,0,1],[0,1,1]]);;
gap> PreImagesElm(ZeroOne,1);
1(2)
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="PreImagesRepresentative" Arg="f, x"/>
    <Returns>
      a representative of the set of preimages of <A>x</A> under <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> PreImagesRepresentative(ZeroOne,1);
1
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="PreImagesSet" Arg="f, S"/>
    <Meth Name="PreImage" Arg="f, S"/>
    <Returns>
      the preimage of the set <A>S</A> under the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      In particular, <A>S</A> can be a union of residue classes.
<Example>
<![CDATA[
gap> PreImage(T,A);
1(2) U 4(6)
gap> M := [1];; l := [1];;
gap> while Length(M) < 10000 do M := PreImage(T,M); Add(l,Length(M)); od;
gap> l;
[ 1, 1, 2, 2, 4, 5, 8, 10, 14, 18, 26, 36, 50, 67, 89, 117, 157, 208, 277, 
  367, 488, 649, 869, 1154, 1534, 2039, 2721, 3629, 4843, 6458, 8608, 11472 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="MovedPoints" Arg="f"/>
    <Returns>
      the set of moved points (support) of the bijective
      rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> MovedPoints(u);
Integers \ [ -1, 0 ]
gap> MovedPoints(r);
GF(2)[x] \ [ 0*Z(2), Z(2)^0, x, x+Z(2)^0 ]
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:InjectivitySurjectivityBijectivity">
<Heading>Testing for injectivity, surjectivity and bijectivity</Heading>

  <ManSection>
    <Meth Name="IsInjective" Arg="f"/>
    <Description>
      Checks whether the rcwa mapping <A>f</A> is injective.
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="IsSurjective" Arg="f"/>
    <Description>
      Checks whether the rcwa mapping <A>f</A> is surjective.
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="IsBijective" Arg="f"/>
    <Description>
      Checks whether the rcwa mapping <A>f</A> is bijective.
    </Description>
  </ManSection>

<Example>
<![CDATA[
gap> IsInjective(T);
false
gap> IsSurjective(T);
true
gap> IsBijective(u);
true
gap> a_2 := RcwaMapping([2],[[3,0,2],[3,1,4],[3,0,2],[3,-1,4]]);
<rcwa mapping of Z_( 2 ) with modulus 4>
gap> a_23 := RcwaMapping([2,3],[[3,0,2],[3,1,4],[3,0,2],[3,-1,4]]);
<rcwa mapping of Z_( 2, 3 ) with modulus 4>
gap> IsInjective(a_2);
false
gap> IsSurjective(a_2);
true
gap> IsBijective(a_23);
true
gap> IsBijective(r);
true
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:Arithmetic">
<Heading>Arithmetical operations and neutral elements</Heading>

  <Index Key="rcwa mapping" Subkey="sum"></Index>
  <Index Key="rcwa mapping" Subkey="difference"></Index>
  <ManSection>
    <Meth Name="\+" Arg = "f, g"/>
    <Meth Name="\-" Arg = "f, g"/>
    <Returns>
      the (pointwise) sum resp. difference of the rcwa mappings <A>f</A>
      and <A>g</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> a := RcwaMapping([[3,0,2],[3, 1,4],[3,0,2],[3,-1,4]]);;
gap> b := RcwaMapping([[3,0,2],[3,13,4],[3,0,2],[3,-1,4]]);;
gap> Display(a + b);

Integral rcwa mapping with modulus 4

                n mod 4                |                 n^f
---------------------------------------+--------------------------------------
  0 2                                  | 3n
  1                                    | (3n + 7)/2
  3                                    | (3n - 1)/2

gap> Display(a - b);

Integral rcwa mapping with modulus 4

                n mod 4                |                 n^f
---------------------------------------+--------------------------------------
  0 2 3                                | 0
  1                                    | -3

gap> d+d+d;
IdentityMapping( Z_( 2 ) )
gap> e := One(r);;
gap> e+e;
ZeroMapping( GF(2)[x], GF(2)[x] )
gap> p^(r+e) = p^r + p;
true
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="product"></Index>
  <ManSection>
    <Meth Name="\*" Arg="f, g"/>
    <Returns>
      the product (composition) of the rcwa mappings <A>f</A> and
      <A>g</A>. The mapping <A>f</A> is applied first.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> Display(a*b);

Integral rcwa mapping with modulus 16

               n mod 16                |                 n^f
---------------------------------------+--------------------------------------
   0  4  8 12                          | 9n/4
   1                                   | (9n + 55)/16
   2 10                                | (9n - 2)/8
   3 11                                | (9n - 3)/8
   5 13                                | (9n + 3)/8
   6 14                                | (9n + 26)/8
   7                                   | (9n + 49)/16
   9                                   | (9n - 1)/16
  15                                   | (9n - 7)/16

gap> s := RcwaMapping(2,x,[[One(R),Zero(R),One(R)],[x,Zero(R),One(R)]]);
<rcwa mapping of GF(2)[x] with modulus x>
gap> s^2=s; # a non-trivial idempotent
true
gap> IsInjective(s) or IsSurjective(s); # certainly not a group element ...
false
gap> Display(s*r-r*s);

Rcwa mapping of GF(2)[x] with modulus x^3+x

       P mod x^3+x        |                        P^f
--------------------------+---------------------------------------------------
 0*Z(2)                   | 
 Z(2)^0                   | 
 x                        | 
 x^2                      | 
 x^2+Z(2)^0               | 
 x^2+x                    | 0*Z(2)
 x+Z(2)^0                 | 
 x^2+x+Z(2)^0             | x

]]>
</Example>
    </Description>
  </ManSection>

  Multiplying rcwa mappings of the integers and (finite) permutations is
  forbidden, since &GAP;-permutations can only move positive integers
  less than <M>2^{28}</M>; more precisely, one would encounter problems like
  the following:

<Log>
<![CDATA[
gap> (1,2)^RcwaMapping([[-1,0,1]]);
(-2,-1)
gap> (1,2)^RcwaMapping([[1,2^28,1]]);
(268435457,268435458)
]]>
</Log>

  <ManSection>
    <Meth Name="Inverse" Arg="f"/>
    <Returns>
      the inverse mapping of the bijective rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> Display(Inverse(u));

Bijective integral rcwa mapping with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0 3 6                                | 5n/3
  1 4 7                                | (5n + 1)/3
  2                                    | (5n - 1)/9
  5                                    | (5n + 2)/9
  8                                    | (5n - 4)/9

gap> Display(Inverse(r));

Bijective rcwa mapping of GF(2)[x] with modulus x^2+x+Z(2)^0

    P mod x^2+x+Z(2)^0    |                        P^f
--------------------------+---------------------------------------------------
 0*Z(2)                   | (x^2+Z(2)^0)*P/(x^2+x+Z(2)^0)
 Z(2)^0                   | ((x^2+Z(2)^0)*P + x)/(x^2+x+Z(2)^0)
 x                        | ((x^2+Z(2)^0)*P + x^2)/(x^2+x+Z(2)^0)
 x+Z(2)^0                 | ((x^2+Z(2)^0)*P + x^2+x)/(x^2+x+Z(2)^0)

]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="conjugate"></Index>
  <ManSection>
    <Meth Name="\^" Arg="f, g"/>
    <Returns>
      the conjugate <M>f^g = g^{-1}fg</M> of <A>f</A> under <A>g</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> T^u;
<surjective integral rcwa mapping with modulus 18>
gap> Display(s^r);

Rcwa mapping of GF(2)[x] with modulus x^3+x^2+x

     P mod x^3+x^2+x      |                        P^f
--------------------------+---------------------------------------------------
 0*Z(2)                   | 
 x                        | 
 x^2                      | 
 x^2+x                    | P
 Z(2)^0                   | 
 x^2+x+Z(2)^0             | x*P
 x+Z(2)^0                 | 
 x^2+Z(2)^0               | x*P + x

]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="zero"></Index>
  <ManSection>
    <Var Name="ZeroIntegralRcwaMapping"/>
    <Meth Name="Zero" Arg="f"/>
    <Description>
      The zero integral rcwa mapping, resp. the zero mapping in the
      family of rcwa mappings <A>f</A> belongs to.
<Example>
<![CDATA[
gap> Zero(a);
ZeroMapping( Integers, Integers )
gap> Zero(r);
ZeroMapping( GF(2)[x], GF(2)[x] )
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="identity"></Index>
  <ManSection>
    <Var Name="IdentityIntegralRcwaMapping"/>
    <Meth Name="One" Arg="f"/>
    <Description>
      The identity integral rcwa mapping, resp. the identity mapping in the
      family of rcwa mappings <A>f</A> belongs to.
<Example>
<![CDATA[
gap> One(a);
IdentityMapping( Integers )
gap> One(d);
IdentityMapping( Z_( 2 ) )
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="no ring under add. and mult.">
    no ring under add. and mult.
  </Index>
  Caution: The set of rcwa mappings over a ring does not form a ring under
  addition and multiplication -- only the left distibutive law is satisfied
  ( <M>a \cdot (b + c) = a \cdot b + a \cdot c</M>, but not
  necessarily <M>(a + b) \cdot c = a \cdot c + b \cdot c</M> ), and the zero
  mapping multiplicatively is only a right zero element
  ( <M>a \cdot 0 = 0</M> for all <M>a</M>, but <M>0 \cdot a = 0</M> if and
  only if <M>0^a = 0</M> ).

</Section>

<!-- #################################################################### -->

<Section Label="sec:OrderOfRcwaMapping">
<Heading>Computing the order of an rcwa mapping</Heading>

  <ManSection>
    <Meth Name="Order" Arg="f"/>
    <Returns>
      the multiplicative order of the bijective rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      One of the sufficient criteria for <A>f</A> having infinite order
      which are used by this package relies on a currently unproven
      hypothesis. You can get information about the used methods on some
      Info level of <C>InfoRCWA</C>.
<Example>
<![CDATA[
gap> Order(Comm(a,b));
6
gap> Order(u);
infinity
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsTame" Arg="f" Label="Tame rcwa mapping"/>
    <Description>
      Indicates whether or not the rcwa mapping <A>f</A> is tame. For a
      definition see section <Ref Label="sec:FurtherBasicDefinitions"/>.
      <P/>

      See also <Ref Prop="IsTame" Label="Tame rcwa group"/> for rcwa groups.
<Example>
<![CDATA[
gap> IsTame(T);
false
gap> IsTame(a) or IsTame(b);
false
gap> IsTame(Comm(a,b));
true
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:TransMatGraphPrimeSet">
<Heading>Transition matrix, transition graph and trajectory</Heading>

  <ManSection>
    <Func Name="TransitionMatrix" Arg="f, m"/>
    <Returns>
      the transition matrix of the Markov chain associated to
      the rcwa mapping <A>f</A> and the states <M>r</M>(<A>m</A>) <M>\in</M>
      <M>R</M>/<A>m</A><M>R</M>.
    </Returns>
    <Description>
      <Index Key="rcwa mapping" Subkey="transition matrix"></Index>
      The assignment of the residue classes (mod <A>m</A>) to the rows and
      columns of the matrix is given by the ordering of the residues
      in the return value of <C>AllResidues(<A>m</A>)</C>
      (see <Ref Func="AllResidues"/>).
      The sums of the rows of a transition matrix are always equal to 1.
<Example>
<![CDATA[
gap> M := TransitionMatrix(a,7);;
gap> Display(M);
[ [  1/2,    0,  1/4,    0,    0,  1/4,    0 ],
  [    0,  1/4,    0,    0,  1/4,  1/2,    0 ],
  [  1/4,    0,    0,  3/4,    0,    0,    0 ],
  [    0,  1/2,  1/4,    0,    0,    0,  1/4 ],
  [    0,  1/4,    0,    0,    0,  1/4,  1/2 ],
  [  1/4,    0,    0,    0,  3/4,    0,    0 ],
  [    0,    0,  1/2,  1/4,    0,    0,  1/4 ] ]
gap> DeterminantMat(M);
-81/4096
gap> M := TransitionMatrix(T,19);;
gap> Display(M*One(GF(7)));
 4 . . . . . . . . . 4 . . . . . . . .
 . . 4 . . . . . . . 4 . . . . . . . .
 . 4 . . . . . . . . . . . 4 . . . . .
 . . . . . 4 . . . . . 4 . . . . . . .
 . . 4 . . . . . . . . . . . . . 4 . .
 . . . . . . . . 4 . . . 4 . . . . . .
 4 . . 4 . . . . . . . . . . . . . . .
 . . . . . . . . . . . 4 . 4 . . . . .
 . . . 4 4 . . . . . . . . . . . . . .
 . . . . . . . . . . . . . . 1 . . . .
 . . . . . 4 4 . . . . . . . . . . . .
 . . . . . . . . . . . . . . . 4 . 4 .
 . . . . . . 4 . . 4 . . . . . . . . .
 . 4 . . . . . . . . . . . . . . 4 . .
 . . . . . . . 4 . . . . 4 . . . . . .
 . . . . 4 . . . . . . . . . . . . 4 .
 . . . . . . . . 4 . . . . . . 4 . . .
 . . . . . . . 4 . . . . . . . . . . 4
 . . . . . . . . . 4 . . . . . . . . 4
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="TransitionGraph" Arg="f, m"/>
    <Returns>
      the transition graph for modulus <A>m</A> of the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      <Index Key="rcwa mapping" Subkey="transition graph"></Index>
      We define the <E>transition graph</E> <M>\Gamma_{f,m}</M>
      of <M>f</M> for modulus <M>m</M> as follows:
      <Enum>
        <Item>
          The vertices are the residue classes (mod <M>m</M>).
        </Item>
        <Item>
          There is an edge from <M>r_1(m)</M> to <M>r_2(m)</M> if and only if
          there is some <M>n_1 \in r_1(m)</M> such that
          <M>n_1^f \in r_2(m)</M>.
        </Item>
      </Enum>
      The assignment of the residue classes (mod <M>m</M>) to the vertices
      of the graph is given by the ordering of the residues in the return
      value of <C>AllResidues(<A>m</A>)</C> (see <Ref Func="AllResidues"/>).
      <P/>

      The result is returned as a <Package>GRAPE</Package>-graph.
<Example>
<![CDATA[
gap> TransitionGraph(a,Modulus(a));
rec( isGraph := true, order := 4, group := Group(()), 
  schreierVector := [ -1, -2, -3, -4 ], 
  adjacencies := [ [ 1, 3 ], [ 1, 2, 3, 4 ], [ 2, 4 ], [ 1, 2, 3, 4 ] ], 
  representatives := [ 1, 2, 3, 4 ], names := [ 1, 2, 3, 4 ] )
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="OrbitsModulo" Arg="f, m"
          Label="OrbitsModulo for rcwa mapping"/>
    <Returns>
      the partition of of <C>AllResidues(<A>m</A>)</C> corresponding to
      the weakly-connected components of the transition graph for modulus
      <A>m</A> of the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      See also <Ref Meth="OrbitsModulo" Label="OrbitsModulo for rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> OrbitsModulo(Comm(a,b),9);
[ [ 0 ], [ 1, 4, 5, 6, 7 ], [ 2 ], [ 3 ], [ 8 ] ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="FactorizationOnConnectedComponents" Arg = "f, m"
          Label="FactorizationOnConnectedComponents for rcwa mapping"/>
    <Returns>
      the set of restrictions of the rcwa mapping <A>f</A> to the
      weakly-connected components of its transition graph
      <M>\Gamma_{f,m}</M>.
    </Returns>
    <Description>
      These mappings have pairwisely disjoint supports, hence any two
      of them commute, and their product equals <A>f</A>.
<Example>
<![CDATA[
gap> sigma := RcwaMapping([[1, 0,1],[1, 1,1],[2,2,1],[3,-3,2],
>                          [1, 0,1],[1,-2,3],[3,6,2],[1,-2,1],
>                          [1, 0,1],[1, 1,1],[1,1,1],[1,-2,1],
>                          [2, 0,1],[1, 1,1],[1,1,1],[3,-3,2],
>                          [1, 0,1],[1, 1,1],[3,6,2],[1,-2,1],
>                          [1, 0,1],[1, 1,1],[1,1,1],[2,-4,1],
>                          [1,-3,3],[1, 1,1],[1,1,1],[3,-3,2],
>                          [1, 0,1],[2, 2,1],[3,6,2],[1,-2,1],
>                          [1, 0,1],[1, 1,1],[1,1,1],[1,-2,1]]);;
gap> fact := FactorizationOnConnectedComponents(sigma,36);
[ <integral rcwa mapping with modulus 36>, 
  <integral rcwa mapping with modulus 36>, 
  <integral rcwa mapping with modulus 36> ]
gap> List(fact,MovedPoints);
[ 33(36) U 34(36) U 35(36), 9(36) U 10(36) U 11(36), 
  <union of 23 residue classes (mod 36), +0/-2 elements> ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="Trajectory" Arg="f, n, val, cond"/>
    <Description>
      This function computes the trajectory of <A>n</A> under the
      rcwa mapping <A>f</A>. The parameter <A>val</A> can either specify the
      length of the sequence to be computed or be a <Q>stopping set</Q>
      such that the computation stops when some iterate
      <C><A>n</A>&circum;(<A>f</A>&circum;k) in <A>val</A></C> is reached,
      depending on whether <C><A>cond</A> = "length"</C> or
      <C><A>cond</A> = "stop"</C>.
<Example>
<![CDATA[
gap> Trajectory(a,8,100,"length");
[ 8, 12, 18, 27, 20, 30, 45, 34, 51, 38, 57, 43, 32, 48, 72, 108, 162, 243, 
  182, 273, 205, 154, 231, 173, 130, 195, 146, 219, 164, 246, 369, 277, 208, 
  312, 468, 702, 1053, 790, 1185, 889, 667, 500, 750, 1125, 844, 1266, 1899, 
  1424, 2136, 3204, 4806, 7209, 5407, 4055, 3041, 2281, 1711, 1283, 962, 
  1443, 1082, 1623, 1217, 913, 685, 514, 771, 578, 867, 650, 975, 731, 548, 
  822, 1233, 925, 694, 1041, 781, 586, 879, 659, 494, 741, 556, 834, 1251, 
  938, 1407, 1055, 791, 593, 445, 334, 501, 376, 564, 846, 1269, 952 ]
gap> Trajectory(T,27,[1],"stop");
[ 27, 41, 62, 31, 47, 71, 107, 161, 242, 121, 182, 91, 137, 206, 103, 155, 
  233, 350, 175, 263, 395, 593, 890, 445, 668, 334, 167, 251, 377, 566, 283, 
  425, 638, 319, 479, 719, 1079, 1619, 2429, 3644, 1822, 911, 1367, 2051, 
  3077, 4616, 2308, 1154, 577, 866, 433, 650, 325, 488, 244, 122, 61, 92, 46, 
  23, 35, 53, 80, 40, 20, 10, 5, 8, 4, 2, 1 ]
gap> Length(Trajectory(RcwaMapping([[1,0,2],[5,-1,2]]),19,[1],"stop"));
307
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="TrajectoryModulo" Arg="f, n, m, lng"/>
    <Func Name="TrajectoryModulo" Arg="f, n, lng"/>
    <Returns>
      the sequence <M>(n_i), i = 0, \dots, lng-1</M> with
      <M>n_i := n^{(f^i)}</M> mod <A>m</A> as a list.
    </Returns>
    <Description>
      If <A>m</A> is not given it defaults to the modulus of <A>f</A>.
<Example>
<![CDATA[
gap> TrajectoryModulo(a,8,25);
[ 0, 0, 2, 3, 0, 2, 1, 2, 3, 2, 1, 3, 0, 0, 0, 0, 2, 3, 2, 1, 1, 2, 3, 1, 2 ]
gap> TrajectoryModulo(T,27,2,100);
[ 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 
  0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 
  1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="CoefficientsOnTrajectory" Arg="f, n, val, cond, all"/>
    <Description>
      This function computes something which we might call <Q>accumulated
      coefficients</Q> on the trajectory of <A>n</A> under the rcwa mapping
      <A>f</A>. More precisely: it computes a list <C>c</C> of coefficient
      triples such that for any <C>k</C>, we have
      <C><A>n</A>&circum;(<A>f</A>&circum;(k-1)) = (c[k][1]*<A>n</A> +
      c[k][2])/c[k][3]</C>. The meaning of the arguments <A>val</A> and
      <A>cond</A> is the same as in <Ref Func="Trajectory"/>.
      If <C><A>all</A> = true</C>, the whole sequence of coefficient triples
      is returned, otherwise the result is only the last triple.
<Example>
<![CDATA[
gap> CoefficientsOnTrajectory(T,27,1,"stop",false);
[ 36472996377170786403, 195820718533800070543, 1180591620717411303424 ]
gap> (last[1]*27+last[2])/last[3];
1
gap> CoefficientsOnTrajectory(sigma,37,37,"stop",true);
[ [ 1, 0, 1 ], [ 1, 1, 1 ], [ 2, 4, 1 ], [ 3, 9, 1 ], [ 6, 18, 1 ], 
  [ 2, 5, 1 ], [ 2, 3, 1 ], [ 2, 1, 3 ], [ 2, 4, 3 ], [ 2, 7, 3 ], 
  [ 1, 2, 1 ], [ 3, 3, 2 ], [ 3, 5, 2 ], [ 3, 7, 2 ], [ 3, 3, 1 ], 
  [ 9, 15, 2 ], [ 27, 57, 4 ], [ 27, 57, 2 ], [ 9, 17, 2 ], [ 9, 13, 2 ], 
  [ 9, 15, 1 ], [ 3, 4, 1 ], [ 3, 2, 1 ], [ 1, 0, 1 ] ]
gap> List(last,c->(c[1]*37+c[2])/c[3]){[1..23]} = Cycle(sigma,37);
true
gap> CoefficientsOnTrajectory(a,8,10,"length",true);
[ [ 1, 0, 1 ], [ 3, 0, 2 ], [ 9, 0, 4 ], [ 27, 0, 8 ], [ 81, -8, 32 ], 
  [ 243, -24, 64 ], [ 729, -72, 128 ], [ 2187, -88, 512 ], 
  [ 6561, -264, 1024 ], [ 19683, -1816, 4096 ] ]
gap> CoefficientsOnTrajectory(r,x^3+x^2,x^3+x^2,"stop",true);
[ [ Z(2)^0, 0*Z(2), Z(2)^0 ], [ x^2+x+Z(2)^0, x^2+x, x^2+Z(2)^0 ], 
  [ x^4+x^2+Z(2)^0, x^4+x, x^4+Z(2)^0 ], 
  [ x^6+x^5+x^3+x+Z(2)^0, x^6+x^4+x^3+x^2, x^6+x^4+x^2+Z(2)^0 ], 
  [ x^8+x^4+Z(2)^0, x^7+x^6, x^8+Z(2)^0 ] ]
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ActionOfMappingOnClasses">
<Heading>
  The action of an rcwa mapping on the set of residue class unions
</Heading>

  <ManSection>
    <Attr Name ="RespectedClassPartition" Arg="sigma"
          Label="Respected class partition for rcwa mapping"/>
    <Description>
      A partition of the base ring <M>R</M> into a finite number of residue
      classes on which the bijective mapping <A>sigma</A> acts as a
      permutation, and on those elements <A>sigma</A> is affine.
      The partition is non-trivial as long as the modulus of <A>sigma</A>
      is not equal to 1. Such a partition exists if and only if <A>sigma</A>
      is tame. <P/>

      See also <Ref Attr="RespectedClassPartition"
      Label="Respected class partition for rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> g := RcwaMapping([[2,2,1],[1, 4,1],[1,0,2],[2,2,1],[1,-4,1],[1,-2,1]]);;
gap> h := RcwaMapping([[2,2,1],[1,-2,1],[1,0,2],[2,2,1],[1,-1,1],[1, 1,1]]);;
gap> pcp := RespectedClassPartition(g);
[ 0(12), 1(12), 3(12), 4(12), 5(12), 6(12), 7(12), 9(12), 10(12), 11(12), 
  2(24), 8(24), 14(24), 20(24) ]
gap> G := Group(g,h);
<integral rcwa group with 2 generators>
gap> Action(G,pcp);
Group([ (1,11,2,5,3,12,4)(6,13,7,10,8,14,9), (1,11,2,10)(3,12,4)(5,6,13,7)(8,
    14,9) ])
gap> Size(last);
322560
gap> Size(G);
infinity
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ConjugacyInWholeRCWA_R">
<Heading>Conjugacy of mappings in RCWA(R)</Heading>

  <ManSection>
    <Oper Name="ShortCycles" Arg="f, maxlng"/>
    <Description>
      Computes all <Q>single</Q> finite cycles, hence all finite cycles
      not belonging to an infinite series, of the rcwa mapping <A>f</A> of
      length at most <A>maxlng</A>.
      Since &GAP;-permutations cannot move negative integers, rationals
      or even polynomials, the cycles are returned as lists, for example
      the list <C>[-3,1,2,-2]</C> denotes the cycle <C>(-3,1,2,-2)</C>.
      Mappings having different sets of finite cycle lengths are obviously
      not conjugate in RCWA(<M>R</M>).
<Example>
<![CDATA[
gap> ShortCycles(a,2);
[ [ 0 ], [ 1 ], [ -1 ], [ 2, 3 ], [ -3, -2 ] ]
gap> ShortCycles(a,5);
[ [ 0 ], [ 1 ], [ -1 ], [ 2, 3 ], [ -3, -2 ], [ 4, 6, 9, 7, 5 ], 
  [ -9, -7, -5, -4, -6 ] ]
gap> ShortCycles(u,2);
[ [ 0 ], [ -1 ], [ 1, 2 ], [ 3, 5 ], [ -10, -6 ] ]
gap> ShortCycles(Comm(a,b),10);
[  ]
gap> ShortCycles(a*b,2);
[ [ 0 ], [ 2 ], [ 3 ], [ -26 ], [ 7 ], [ -3 ], [ -1 ] ]
gap> v := RcwaMapping([[-1,2,1],[1,-1,1],[1,-1,1]]);;
gap> w := RcwaMapping([[-1,3,1],[1,-1,1],[1,-1,1],[1,-1,1]]);;
gap> Order(v);
6
gap> Order(w);
8
gap> ShortCycles(v,10);
[ [ 0, 2, 1 ] ]
gap> ShortCycles(w,10);
[ [ 0, 3, 2, 1 ] ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name ="IntegralConjugate" Arg="f"
          Label="Integral conjugate for rcwa mapping"/>
    <Description>
      Some integral representative of the conjugacy class of the tame
      bijective rcwa mapping <A>f</A> in the whole group RCWA(<M>R</M>).
      Such a representative exists if the ring <M>R</M> has residue class
      rings of any finite cardinality.
      Since the result is not defined uniquely, methods for this
      operation will just choose one such mapping. <P/>

      See also <Ref Attr="IntegralConjugate"
                Label="Integral conjugate for rcwa group"/> for rcwa groups.
<Example>
<![CDATA[
gap> g_int := IntegralConjugate(g);;
gap> Display(g_int);

Bijective integral rcwa mapping with modulus 14, of order 7

               n mod 14                |                 n^f
---------------------------------------+--------------------------------------
   0                                   | n + 10
   1  6                                | n + 3
   2                                   | n + 9
   3  8                                | n - 3
   4  9                                | n - 2
   5                                   | n + 7
   7                                   | n + 6
  10                                   | n - 9
  11                                   | n - 8
  12                                   | n - 6
  13                                   | n - 5

]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="IntegralizingConjugator" Arg="f"
          Label="Integralizing conjugator for rcwa mapping"/>
    <Description>
      An rcwa mapping mapping <A>x</A> such that <A>f</A>&circum;<A>x</A>
      is integral. This is certainly not defined uniquely, but it holds that
      <C><A>f</A>&circum;IntegralizingConjugator(<A>f</A>) =
         IntegralConjugate(<A>f</A>)</C>. <P/>

      See also <Ref Attr="IntegralizingConjugator"
                Label="Integralizing conjugator for rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> g_to_int := IntegralizingConjugator(g);;
gap> Display(g_to_int);

Bijective integral rcwa mapping with modulus 24

               n mod 24                |                 n^f
---------------------------------------+--------------------------------------
   0 12                                | 7n/6
   1 13                                | (7n - 1)/6
   2                                   | (7n + 106)/12
   3 15                                | (7n - 9)/6
   4 16                                | (7n - 10)/6
   5 17                                | (7n - 11)/6
   6 18                                | (7n - 12)/6
   7 19                                | (7n - 13)/6
   8                                   | (7n + 76)/12
   9 21                                | (7n - 21)/6
  10 22                                | (7n - 22)/6
  11 23                                | (7n - 23)/6
  14                                   | (7n + 46)/12
  20                                   | (7n + 16)/12

gap> g^g_to_int = g_int;
true
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="IsConjugate" Arg="G, f, g"/>
    <Description>
      Checks whether the bijective rcwa mappings <A>f</A> and <A>g</A>
      are conjugate in <A>G</A>. <P/>

      Currently there are methods only for very few cases,
      e.g. for determining conjugacy in the whole group RCWA(<M>R</M>)
      in case this is <Q>easy</Q>. <P/>

      This may fail or run into an infinite loop.
<Example>
<![CDATA[
gap> IsConjugate(RCWA(Integers),g,g_int);
true
gap> IsConjugate(RCWA(Integers),a,b);
false
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:NonBijectiveMappings">
<Heading>
  Special functions for non-bijective mappings and miscellanea
</Heading>

  <ManSection>
    <Oper Name="ContractionCentre" Arg="f, maxn, bound"/>
    <Description>
      Tries to compute the <E>contraction centre</E> of an rcwa mapping -
      assuming its existence this is the uniquely-defined finite subset
      <M>S_0</M> of the base ring <M>R</M> which is mapped bijectively onto
      itself under <A>f</A> and where for any <M>x</M> in <M>R</M> there is
      an integer <M>k</M> such that the image of <M>x</M> under the
      <M>k</M>-th power of <M>f</M> lies in <M>S_0</M>.
      The mapping <A>f</A> is assumed to be <E>contracting</E>, i.e.
      to have such a contraction centre.
      As this problem seems to be computationally undecidable methods will be
      probabilistic. The argument <A>maxn</A> is a bound on the starting
      value and <A>bound</A> is a bound on the elements of the sequences
      to be searched.
      If the limit <A>bound</A> is exceeded, an Info message on some Info
      level of <C>InfoRCWA</C> is given.
<Example>
<![CDATA[
gap> S0 := ContractionCentre(T,100,1000);
[ -136, -91, -82, -68, -61, -55, -41, -37, -34, -25, -17, -10, -7, -5, -1, 0, 
  1, 2 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="Divergence" Arg="f"/>
    <Description>
      The <E>divergence</E> of the rcwa mapping <A>f</A>.
      This is conjectured to be a measure for how fast an rcwa mapping
      contracts (if its divergence is smaller than 1) or how fast its
      trajectories diverge (if its divergence is larger than 1),
      provided that its transition graph for modulus Mod(<A>f</A>)
      is weakly-connected. <P/>

      We do not give a definition here as in the future it may turn out
      that defining the divergence in another way than we currently do
      is more suitable.
<Example>
<![CDATA[
gap> Divergence(T);
0.866025
gap> Rat(last^2);
3/4
gap> Divergence(g);
1
gap> Divergence(a);
1.06066
gap> Rat(last^2);
9/8
gap> Divergence(a^-1);
1.05827
gap> Rat(last^3);
32/27
gap> Divergence(u);
1.15991
gap> Rat(last^5);
6561/3125
gap> Divergence(a)*Divergence(u);
1.23027
gap> Divergence(a*u);
1.23027
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="ImageDensity" Arg="f"/>
    <Description>
      We define the <E>image density</E> of an rcwa mapping <A>f</A> of
      a ring <M>R</M> by the sum of the densities of the images of the
      affine partial mappings of <A>f</A>, where we set the density
      of a residue class <M>r(m)</M> equal to <M>1/|R/mR|</M>.
      Injective rcwa mappings have an image density of at most 1, and the
      image density of a surjective rcwa mapping is at least 1 -- thus in
      particular the image density of a bijective mapping equals 1.
<Example>
<![CDATA[
gap> ImageDensity(T);
4/3
gap> ImageDensity(a);
1
gap> ImageDensity(RcwaMapping([[2,0,1]]));
1/2
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="Restriction" Arg="g, f"
          Label="Restriction of an rcwa mapping"/>
    <Returns> the <E>restriction</E> of <A>g</A> by <A>f</A>. </Returns>
    <Description>
      By definition, the restriction <M>g_f</M> of <A>g</A> by <A>f</A>
      is the uniquely-determined rcwa mapping satisfying
      <M>f \cdot g_f = g \cdot f</M> and fixing the complement of
      the image of <A>f</A>. The mapping <A>f</A> has to be injective and
      its multiplier must not be zero. If <A>f</A> is bijective the
      returned mapping is just the conjugate of <A>g</A> by <A>f</A>. <P/>

      See also <Ref Oper="Restriction" Label="Restriction of an rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> Comm(Restriction(a,RcwaMapping([[2,0,1]])),
>         Restriction(u,RcwaMapping([[2,1,1]])));
IdentityMapping( Integers )
]]>
</Example>      
    </Description>
  </ManSection>

  <Alt Only="HTML">&nbsp;</Alt>

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->


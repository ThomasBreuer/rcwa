<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  rcwamap.xml          RCWA documentation          Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- ##  $Id$      ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:RcwaMappings">
<Heading>Residue Class-Wise Affine Mappings</Heading>

This chapter describes the functionality available for computing with
rcwa mappings. <P/>

<!-- #################################################################### -->

<Section Label="sec:CategoriesOfRcwaMappings">
<Heading>The categories and families of rcwa mappings</Heading>

  <ManSection>
    <Filt Name="IsRcwaMapping" Arg="f"/>
    <Description>
      The category of all rcwa mappings.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsRationalBasedRcwaMapping" Arg="f"/>
    <Description>
      The category of all <Q>rational-based</Q> (hence all integral and all
      semilocal integral) rcwa mappings.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsIntegralRcwaMapping" Arg="f"/>
    <Description>
      The category of all integral rcwa mappings.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsSemilocalIntegralRcwaMapping" Arg="f"/>
    <Description>
      The category of all semilocal integral rcwa mappings.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsModularRcwaMapping" Arg="f"/>
    <Description>
      The category of all modular rcwa mappings.
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="RcwaMappingsFamily" Arg="R"/>
    <Returns>
      the family of rcwa mappings over the ring <A>R</A>.
    </Returns>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ConstructingRcwaMappings">
<Heading>Constructing rcwa mappings</Heading>

  <ManSection>
    <Meth Name="RcwaMapping" Arg="R, modulus, coeffs"/>
    <Meth Name="RcwaMapping" Arg="R, coeffs"/>
    <Meth Name="RcwaMapping" Arg="coeffs"/>
    <Meth Name="RcwaMapping" Arg="perm, range"/>
    <Meth Name="RcwaMapping" Arg="modulus, values"/>
    <Meth Name="RcwaMapping" Arg="pi, coeffs"/>
    <Meth Name="RcwaMapping" Arg="q, modulus, coeffs"/>
    <Meth Name="RcwaMapping" Arg="cycles"/>
    <Description>
      Returns the rcwa mapping
      <List>
        <Mark>(a)</Mark>
        <Item>
          with modulus <A>modulus</A> and coefficients <A>coeffs</A>
          over the ring <A>R</A>, resp.
        </Item>
        <Mark>(b)</Mark>
        <Item>
          with coefficients <A>coeffs</A> over the ring <A>R</A>,
          if this information is sufficient, resp.
        </Item>
        <Mark>(c)</Mark>
        <Item>
          with coefficients <A>coeffs</A>, if already this
          information is sufficient, resp.
        </Item>
        <Mark>(d)</Mark>
        <Item>
          acting on the translates of <A>range</A> by integral multiples
          of the length of <A>range</A> as the translates of the action of
          the finite permutation <A>perm</A> on <A>range</A> to the
          respective intervals, where moved points of <A>perm</A> outside
          <A>range</A> are ignored (<A>range</A> must entirely consist out
          of positive integers less than <M>2^{28}</M>, since &GAP;
          permutations can only move these), resp.
        </Item>
        <Mark>(e)</Mark>
        <Item>
          with modulus <A>modulus</A> and with values prescribed by the list
          <A>val</A>, which consists of 2<M>\cdot</M><A>modulus</A> pairs
          giving preimage and image for 2 points per residue class
          (mod <A>modulus</A>), resp.
        </Item>
        <Mark>(f)</Mark>
        <Item>
          of <M>\Z_{(\pi)}</M> with coefficients
          <A>coeffs</A>, where the set of primes <M>\pi</M> 
          is given as argument <A>pi</A>, resp.
        </Item>
        <Mark>(g)</Mark>
        <Item>
          of GF( <A>q</A> )[ <A>x</A> ] with modulus
          <A>modulus</A> and coefficients <A>coeffs</A>, resp.
        </Item>
        <Mark>(h)</Mark>
        <Item>
          an arbitrary rcwa mapping with residue class cycles as given by
          <A>cycles</A>.
        </Item>
      </List>
      The argument <A>coeffs</A> is a list of <M>R/mR</M> lists of 3
      elements of <A>R</A>, each (where <A>m</A> is the modulus of the
      mapping), giving the coefficients <M>a_r</M>, <M>b_r</M> and
      <M>c_r</M> for <M>r</M> running through a set of representatives
      for the residue classes (mod <A>m</A>), as described in the
      introduction.
<Example>
<![CDATA[
gap> f := RcwaMapping([[1,1,1],[1,-1,1],[1,1,1],[1,-1,1]]);
<integral rcwa mapping with modulus 2>
gap> f = RcwaMapping((2,3),[2..3]);
true
gap> g := RcwaMapping((1,2,3)(8,9),[4..20]);
<integral rcwa mapping with modulus 17>
gap> Action(Group(g),[4..20]);
Group([ (5,6) ])
gap> T := RcwaMapping([[1,0,2],[3,1,2]]); # The Collatz mapping.
<integral rcwa mapping with modulus 2>
gap> T = RcwaMapping(2,[[1,2],[2,1],[3,5],[4,2]]);
true
gap> t := RcwaMapping(1,[[-1,1],[1,-1]]); # The involution n -> -n.
Integral rcwa mapping: n -> -n
gap> d := RcwaMapping([2],[[1/3,0,1]]);
Rcwa mapping of Z_( 2 ): n -> 1/3 n
gap> RcwaMapping([2,3],ShallowCopy(Coefficients(T)));
<rcwa mapping of Z_( 2, 3 ) with modulus 2>
gap> R := PolynomialRing(GF(2),1);;
gap> x := IndeterminatesOfPolynomialRing(R)[1];; SetName(x,"x");;
gap> e := One(GF(2));; z := Zero(R);;
gap> r := ModularRcwaMapping( 2, x^2 + e,
>                             [ [ x^2 + x + e, z      , x^2 + e ],
>                               [ x^2 + x + e, x      , x^2 + e ],
>                               [ x^2 + x + e, x^2    , x^2 + e ],
>                               [ x^2 + x + e, x^2 + x, x^2 + e ] ] );
<rcwa mapping of GF(2)[x] with modulus x^2+Z(2)^0>
gap> f1 := RcwaMapping([[rc(1,6),rc(0, 8)],[rc(5,6),rc(4, 8)]]);;
gap> f2 := RcwaMapping([[rc(1,6),rc(0, 4)],[rc(5,6),rc(2, 4)]]);;
gap> f3 := RcwaMapping([[rc(2,6),rc(1,12)],[rc(4,6),rc(7,12)]]);;
gap> List([f1,f2,f3],Order);
[ 2, 2, 2 ]
gap> f  := f1*f2*f3;
gap> Order(f);
infinity
gap> [Multiplier(f),Divisor(f)];
[ 3, 2 ]
]]>
</Example>
    </Description>
  </ManSection>

  There is an auxiliary function for determining the correct order of the
  coefficient triples of a modular rcwa mapping (to be precise, this function
  is part of the &ResClasses; package, but is documented here since in
  &ResClasses;, it is only used for internal purposes):

  <ManSection>
    <Func Name="AllResidues" Arg="R, m"/>
    <Returns>
      a sorted list of all residues modulo <A>m</A> in the ring <A>R</A>.
    </Returns>
    <Description>
      This gives also the ordering in which the coefficients of an
      rcwa mapping are stored; thus, if <A>f</A> is an rcwa mapping
      of <A>R</A> with coefficients list <A>c</A> and modulus <A>m</A>,
      then <A>f</A> maps an element <A>n</A> of <A>R</A>
      with <A>n</A> mod <A>m</A> = <A>r</A> to <P/>
      <Log>
        <![CDATA[
        ( c[ Position( res, r ) ][ 1 ] * n + c[ Position( res, r ) ][ 2 ] ) /
          c[ Position( res, r ) ][ 3 ]]]>
      </Log>
      where <A>res</A> denotes the list of residues returned
      by this function.
<Example>
<![CDATA[
gap> AllResidues(Integers,6);
[ 0 .. 5 ]
gap> AllResidues(R,x^4+x^2);
[ 0*Z(2), Z(2)^0, x, x+Z(2)^0, x^2, x^2+Z(2)^0, x^2+x, x^2+x+Z(2)^0, x^3, 
  x^3+Z(2)^0, x^3+x, x^3+x+Z(2)^0, x^3+x^2, x^3+x^2+Z(2)^0, x^3+x^2+x, 
  x^3+x^2+x+Z(2)^0 ]
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="internal representation"></Index>
  The internal representation of an rcwa mapping of any kind is always
  converted to a normalized (reduced) form, i.e. for all <M>r</M>, the
  coefficients <M>a_r</M>, <M>b_r</M> and <M>c_r</M> are divided by their
  gcd and then multiplied by a suitable unit such that <M>c_r</M> equals its
  standard conjugate, and the mapping is reduced to the smallest possible
  modulus.

</Section>

<!-- #################################################################### -->

<Section Label="sec:ExtractComponents">
<Heading>Extracting the components of rcwa mappings</Heading>

  <ManSection>
    <Meth Name="Coefficients" Arg="f"/>
    <Returns>the coefficients of the rcwa mapping <A>f</A>.</Returns>
    <Description>
<Example>
<![CDATA[
gap> Coefficients(T);
[ [ 1, 0, 2 ], [ 3, 1, 2 ] ]
gap> Coefficients(r);
[ [ x^2+x+Z(2)^0, 0*Z(2), x^2+Z(2)^0 ], [ x^2+x+Z(2)^0, x, x^2+Z(2)^0 ], 
  [ x^2+x+Z(2)^0, x^2, x^2+Z(2)^0 ], [ x^2+x+Z(2)^0, x^2+x, x^2+Z(2)^0 ] ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="Modulus" Arg="f" Label="Modulus of an rcwa mapping"/>
    <Returns>the modulus of the rcwa mapping <A>f</A>.</Returns>
    <Description>
      See also <Ref Meth="Modulus" Label="Modulus of an rcwa group"/> for
      rcwa groups, and <Ref Prop="IsTame" Label="Tame rcwa mapping"/>.
<Example>
<![CDATA[
gap> u := RcwaMapping([[3,0,5],[9,1,5],[3,-1,5],[9,-2,5],[9,4,5]]);;
gap> Modulus(u);
5
gap> Modulus(r);
x^2+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:FlatMultDiv">
<Heading>Flat and order-preserving mappings, multiplier and divisor</Heading>

  <ManSection>
    <Attr Name="Multiplier" Arg="f"/>
    <Description>
      The multiplier of the rcwa mapping <A>f</A>.
<Example>
<![CDATA[
gap> Multiplier(g);
1
gap> Multiplier(u);
9
gap> Multiplier(T);
3
gap> Multiplier(d);
1
gap> Multiplier(r);
x^2+x+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="Divisor" Arg="f"/>
    <Description>
      The divisor of the rcwa mapping <A>f</A>.
<Example>
<![CDATA[
gap> Divisor(g);
1
gap> Divisor(u);
5
gap> Divisor(T);
2
gap> Divisor(d);
1
gap> Divisor(r);
x^2+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="PrimeSet" Arg="f" Label="Prime set of an rcwa mapping"/>
    <Returns>the prime set of the rcwa mapping <A>f</A>.</Returns>
    <Description>
      See also <Ref Oper="PrimeSet" Label="Prime set of an rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> PrimeSet(T);
[ 2, 3 ]
gap> PrimeSet(u);
[ 3, 5 ]
gap> PrimeSet(T^u);
[ 2, 3 ]
gap> PrimeSet(T^(u^-1));
[ 2, 3, 5 ]
gap> PrimeSet(r);
[ x+Z(2)^0, x^2+x+Z(2)^0 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsFlat" Arg="f" Label="Flat rcwa mapping"/>
    <Description>
      Indicates whether the rcwa mapping <A>f</A> is flat or not.
      See also <Ref Prop="IsFlat" Label="Flat rcwa group"/> for rcwa groups.
<Example>
<![CDATA[
gap> IsFlat(g);
true
gap> IsFlat(u);
false
gap> IsFlat(T);
false
gap> IsFlat(d);
true
gap> IsFlat(r);
false
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Prop Name="IsClassWiseOrderPreserving" Arg="f"
          Label="Class-wise order-preserving rcwa mapping"/>
    <Description>
      Indicates whether the rational-based rcwa mapping <A>f</A> is
      class-wise order-preserving or not. <P/>
      See also <Ref Prop="IsClassWiseOrderPreserving"
      Label="Class-wise order-preserving rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> IsClassWiseOrderPreserving(g);
true
gap> IsClassWiseOrderPreserving(u);
true
gap> IsClassWiseOrderPreserving(T);
true
gap> IsClassWiseOrderPreserving(t);
false
gap> IsClassWiseOrderPreserving(d);
true
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:CheckEquality">
<Heading>Checking for equality</Heading>

  <Index Key="rcwa mapping" Subkey="equality"></Index>
  <ManSection>
    <Meth Name="\=" Arg="f, g"/>
    <Description>
      Tests whether the rcwa mappings <A>f</A> and <A>g</A> are equal.
      Since rcwa mappings are stored in a normalized form, this requires
      only comparing their coefficients.
<Example>
<![CDATA[
gap> RcwaMapping([[1,1,1],[2,-2,2],[3,3,3],[4,-4,4]])
>  = RcwaMapping([[1,1,1],[1,-1,1]]);
true
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:PrintAndDisplayMappings">
<Heading>Printing and displaying rcwa mappings</Heading>

  <ManSection>
    <Meth Name="Print" Arg="f"/>
    <Description>
      Prints the rcwa mapping <A>f</A> in &GAP;-readable format.
<Example>
<![CDATA[
gap> Print(T,"\n");
IntegralRcwaMapping( [ [ 1, 0, 2 ], [ 3, 1, 2 ] ] )
gap> Print(d,"\n");
SemilocalIntegralRcwaMapping( [ 2 ], [ [ 1/3, 0, 1 ] ] )
gap> Print(r,"\n");
ModularRcwaMapping( 2, x^2+Z(2)^0, [ [ x^2+x+Z(2)^0, 0*Z(2), x^2+Z(2)^0 ], 
  [ x^2+x+Z(2)^0, x, x^2+Z(2)^0 ], [ x^2+x+Z(2)^0, x^2, x^2+Z(2)^0 ], 
  [ x^2+x+Z(2)^0, x^2+x, x^2+Z(2)^0 ] ] )
]]>
</Example>
    </Description>
  </ManSection>

  The string printed by this method may be obtained with

  <ManSection>
    <Meth Name="String" Arg="f"/>
    <Returns>
      a &GAP;-readable string representation of the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> String(d);
"SemilocalIntegralRcwaMapping( [ 2 ], [ [ 1/3, 0, 1 ] ] )"
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="Display" Arg="f"/>
    <Description>
      Displays the rcwa mapping <A>f</A> in a nice human-readable form.
<Example>
<![CDATA[
gap> SetName(u,"u");
gap> Display(u);

Bijective integral rcwa mapping with modulus 5

                n mod 5                |                 n^u
---------------------------------------+--------------------------------------
  0                                    | 3n/5
  1                                    | (9n + 1)/5
  2                                    | (3n - 1)/5
  3                                    | (9n - 2)/5
  4                                    | (9n + 4)/5

gap> SetName(r,"r");
gap> Display(r);

Rcwa mapping of GF(2)[x] with modulus x^2+Z(2)^0

     P mod x^2+Z(2)^0     |                        P^r
--------------------------+---------------------------------------------------
 0*Z(2)                   | (x^2+x+Z(2)^0)*P/(x^2+Z(2)^0)
 Z(2)^0                   | ((x^2+x+Z(2)^0)*P + x)/(x^2+Z(2)^0)
 x                        | ((x^2+x+Z(2)^0)*P + x^2)/(x^2+Z(2)^0)
 x+Z(2)^0                 | ((x^2+x+Z(2)^0)*P + x^2+x)/(x^2+Z(2)^0)

]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="LaTeXObj" Arg="f"/>
    <Returns>
      a &LaTeX; representation of the integral rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      An indentation by <A>Indentation</A> characters can be specified by
      setting this option value accordingly.
      This only applies to rcwa mappings with modulus larger than 1.
<Example>
<![CDATA[
gap> Print(LaTeXObj(u^-1));
n \ \longmapsto \
\begin{cases}
  \frac{5n}{3}      & \text{if} \ n \equiv 0 \ (3), \\
  \frac{5n + 1}{3}  & \text{if} \ n \equiv 1 \ (3), \\
  \frac{5n - 1}{9}  & \text{if} \ n \equiv 2 \ (9), \\
  \frac{5n + 2}{9}  & \text{if} \ n \equiv 5 \ (9), \\
  \frac{5n - 4}{9}  & \text{if} \ n \equiv 8 \ (9).
\end{cases}
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ImagesAndPreimages">
<Heading>Images and preimages under rcwa mappings</Heading>

  <Index Key="rcwa mapping" Subkey="evaluation"></Index>
  <ManSection>
    <Meth Name="ImageElm" Arg="f, x"/>
    <Meth Name="\^" Arg="f, x"/>
    <Returns>
      the image of the ring element <A>x</A> under the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> 15^T;
23
gap> 7^d;
7/3
gap> p := (x^3+x^2+x+One(R))^r;
x^3+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="image"></Index>
  <ManSection>
    <Meth Name="ImagesSet" Arg="f, S"/>
    <Meth Name="Image" Arg="f, S"/>
    <Meth Name="Image" Arg="f"/>
    <Meth Name="\^" Arg="f, S"/>
    <Returns>
      the image of the set <A>S</A> under the rcwa mapping <A>f</A>,
      resp. the image of the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      In particular, <A>S</A> can be a union of residue classes;
      thus, rcwa mappings resp. rcwa groups act on sets of residue class
      unions as well as on sets of single ring elements.
<Example>
<![CDATA[
gap> A := ResidueClass(Integers,3,2);
The residue class 2(3)
gap> Image(T,A);
Union of the residue classes 1(9), 4(9), 7(9) and 8(9)
gap> k := RcwaMapping([[-4,-8,1]]);;
gap> Image(k);
The residue class 0(4)
gap> A^u;
<union of 9 residue classes (mod 27)>
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="PreImageElm" Arg="f, x"/>
    <Returns>
      the preimage of the ring element <A>x</A> under the bijective
      rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> PreImageElm(u,8);
4
gap> PreImageElm(d,37/17);
111/17
gap> PreImageElm(r,p);
x^3+x^2+x+Z(2)^0
]]>
</Example>
    </Description>
  </ManSection>

  If the mapping <A>f</A> is not bijective, we can use

  <ManSection>
    <Meth Name="PreImagesElm" Arg="f, x"/>
    <Returns>
      the set of preimages of the ring element <A>x</A> under the
      rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> PreImagesElm(T,8);
[ 5, 16 ]
gap> PreImagesElm(ZeroIntegralRcwaMapping,0);
Integers
gap> ZeroOne := RcwaMapping([[0,0,1],[0,1,1]]);;
gap> PreImagesElm(ZeroOne,1);
The residue class 1(2)
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="PreImagesRepresentative" Arg="f, x"/>
    <Returns>
      a representative of the set of preimages of the ring element
      <A>x</A> under the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> PreImagesRepresentative(ZeroOne,1);
1
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="PreImagesSet" Arg="f, S"/>
    <Meth Name="PreImage" Arg="f, S"/>
    <Returns>
      the preimage of the set <A>S</A> under the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      In particular, <A>S</A> can be a union of residue classes.
<Example>
<![CDATA[
gap> PreImage(T,A);
Union of the residue classes 1(6), 3(6), 4(6) and 5(6)
gap> M := [1];; l := [1];;
gap> while Length(M) < 10000 do M := PreImage(T,M); Add(l,Length(M)); od;
gap> l;
[ 1, 1, 2, 2, 4, 5, 8, 10, 14, 18, 26, 36, 50, 67, 89, 117, 157, 208, 277, 
  367, 488, 649, 869, 1154, 1534, 2039, 2721, 3629, 4843, 6458, 8608, 11472 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="MovedPoints" Arg="f"/>
    <Returns>
      the set of moved points (support) of the bijective
      rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> MovedPoints(u);
Integers \ [ -1, 0 ]
gap> MovedPoints(r);
GF(2)[x] \ [ 0*Z(2), Z(2)^0, x, x+Z(2)^0 ]
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:InjectivitySurjectivityBijectivity">
<Heading>Testing for injectivity, surjectivity and bijectivity</Heading>

  <ManSection>
    <Meth Name="IsInjective" Arg="f"/>
    <Description>
      Indicates whether the rcwa mapping <A>f</A> is injective.
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="IsSurjective" Arg="f"/>
    <Description>
      Indicates whether the rcwa mapping <A>f</A> is surjective.
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="IsBijective" Arg="f"/>
    <Description>
      Indicates whether the rcwa mapping <A>f</A> is bijective.
    </Description>
  </ManSection>

<Example>
<![CDATA[
gap> IsInjective(T);
false
gap> IsSurjective(T);
true
gap> IsBijective(u);
true
gap> a_2 := RcwaMapping([2],[[3,0,2],[3,1,4],[3,0,2],[3,-1,4]]);
<rcwa mapping of Z_( 2 ) with modulus 4>
gap> a_23 := RcwaMapping([2,3],[[3,0,2],[3,1,4],[3,0,2],[3,-1,4]]);
<rcwa mapping of Z_( 2, 3 ) with modulus 4>
gap> IsInjective(a_2);
false
gap> IsSurjective(a_2);
true
gap> IsBijective(a_23);
true
gap> IsBijective(r);
true
]]>
</Example>

</Section>

<!-- #################################################################### -->

<Section Label="sec:Arithmetic">
<Heading>Arithmetical operations and neutral elements</Heading>

  <Index Key="rcwa mapping" Subkey="sum"></Index>
  <Index Key="rcwa mapping" Subkey="difference"></Index>
  <ManSection>
    <Meth Name="\+" Arg = "f, g"/>
    <Meth Name="\-" Arg = "f, g"/>
    <Returns>
      the (pointwise) sum resp. difference of the rcwa mappings <A>f</A>
      and <A>g</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> a := RcwaMapping([[3,0,2],[3, 1,4],[3,0,2],[3,-1,4]]);;
gap> b := RcwaMapping([[3,0,2],[3,13,4],[3,0,2],[3,-1,4]]);;
gap> Display(a + b);

Integral rcwa mapping with modulus 4

                n mod 4                |                 n^f
---------------------------------------+--------------------------------------
  0 2                                  | 3n
  1                                    | (3n + 7)/2
  3                                    | (3n - 1)/2

gap> Display(a - b);

Integral rcwa mapping with modulus 4

                n mod 4                |                 n^f
---------------------------------------+--------------------------------------
  0 2 3                                | 0
  1                                    | -3

gap> d+d+d;
IdentityMapping( Z_( 2 ) )
gap> e := One(r);;
gap> e+e;
ZeroMapping( GF(2)[x], GF(2)[x] )
gap> p^(r+e) = p^r + p;
true
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="product"></Index>
  <ManSection>
    <Meth Name="\*" Arg="f, g"/>
    <Returns>
      the product (composition) of the rcwa mappings <A>f</A> and
      <A>g</A>. The mapping <A>f</A> is applied first.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> Display(a*b);

Integral rcwa mapping with modulus 16

               n mod 16                |                 n^f
---------------------------------------+--------------------------------------
   0  4  8 12                          | 9n/4
   1                                   | (9n + 55)/16
   2 10                                | (9n - 2)/8
   3 11                                | (9n - 3)/8
   5 13                                | (9n + 3)/8
   6 14                                | (9n + 26)/8
   7                                   | (9n + 49)/16
   9                                   | (9n - 1)/16
  15                                   | (9n - 7)/16

gap> s := RcwaMapping(2,x,[[One(R),Zero(R),One(R)],[x,Zero(R),One(R)]]);
<rcwa mapping of GF(2)[x] with modulus x>
gap> s^2=s; # a non-trivial idempotent
true
gap> IsInjective(s) or IsSurjective(s); # certainly not a group element ...
false
gap> Display(s*r-r*s);

Rcwa mapping of GF(2)[x] with modulus x^3+x

       P mod x^3+x        |                        P^f
--------------------------+---------------------------------------------------
 0*Z(2)                   | 
 Z(2)^0                   | 
 x                        | 
 x^2                      | 
 x^2+Z(2)^0               | 
 x^2+x                    | 0*Z(2)
 x+Z(2)^0                 | 
 x^2+x+Z(2)^0             | x

]]>
</Example>
    </Description>
  </ManSection>

  Multiplying rational-based rcwa mappings and (finite) permutations is
  forbidden, since &GAP;-permutations can only move positive integers
  less than <M>2^{28}</M>; more precisely, one would encounter problems like
  the following:

<Log>
<![CDATA[
gap> (1,2)^RcwaMapping([[-1,0,1]]);
(-2,-1)
gap> (1,2)^RcwaMapping([[1,2^28,1]]);
(268435457,268435458)
]]>
</Log>

  <ManSection>
    <Meth Name="Inverse" Arg="f"/>
    <Returns>
      the inverse mapping of the bijective rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> Display(Inverse(u));

Bijective integral rcwa mapping with modulus 9

                n mod 9                |                 n^f
---------------------------------------+--------------------------------------
  0 3 6                                | 5n/3
  1 4 7                                | (5n + 1)/3
  2                                    | (5n - 1)/9
  5                                    | (5n + 2)/9
  8                                    | (5n - 4)/9

gap> Display(Inverse(r));

Bijective rcwa mapping of GF(2)[x] with modulus x^2+x+Z(2)^0

    P mod x^2+x+Z(2)^0    |                        P^f
--------------------------+---------------------------------------------------
 0*Z(2)                   | (x^2+Z(2)^0)*P/(x^2+x+Z(2)^0)
 Z(2)^0                   | ((x^2+Z(2)^0)*P + x)/(x^2+x+Z(2)^0)
 x                        | ((x^2+Z(2)^0)*P + x^2)/(x^2+x+Z(2)^0)
 x+Z(2)^0                 | ((x^2+Z(2)^0)*P + x^2+x)/(x^2+x+Z(2)^0)

]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="conjugate"></Index>
  <ManSection>
    <Meth Name="\^" Arg="f, g"/>
    <Returns>
      the conjugate <M>f^g = g^{-1}fg</M> of <A>f</A> under <A>g</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> T^u;
<surjective integral rcwa mapping with modulus 18>
gap> Display(s^r);

Rcwa mapping of GF(2)[x] with modulus x^3+x^2+x

     P mod x^3+x^2+x      |                        P^f
--------------------------+---------------------------------------------------
 0*Z(2)                   | 
 x                        | 
 x^2                      | 
 x^2+x                    | P
 Z(2)^0                   | 
 x^2+x+Z(2)^0             | x*P
 x+Z(2)^0                 | 
 x^2+Z(2)^0               | x*P + x

]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="zero"></Index>
  <ManSection>
    <Var Name="ZeroIntegralRcwaMapping"/>
    <Meth Name="Zero" Arg="f"/>
    <Description>
      The zero integral rcwa mapping, resp. the zero mapping in the
      family of rcwa mappings <A>f</A> belongs to.
<Example>
<![CDATA[
gap> Zero(a);
ZeroMapping( Integers, Integers )
gap> Zero(r);
ZeroMapping( GF(2)[x], GF(2)[x] )
]]>
</Example>
    </Description>
  </ManSection>

  <Index Key="rcwa mapping" Subkey="identity"></Index>
  <ManSection>
    <Var Name="IdentityIntegralRcwaMapping"/>
    <Meth Name="One" Arg="f"/>
    <Description>
      The identity integral rcwa mapping, resp. the identity mapping in the
      family of rcwa mappings <A>f</A> belongs to.
<Example>
<![CDATA[
gap> One(a);
IdentityMapping( Integers )
gap> One(d);
IdentityMapping( Z_( 2 ) )
]]>
</Example>
    </Description>
  </ManSection>

  Sometimes this is also printed as <C>IdentityMapping(</C><A>R</A><C>)</C>,
  where <A>R</A> denotes the ring <A>f</A> is acting on. <P/>

  <Index Key="no ring under add. and mult.">
    no ring under add. and mult.
  </Index>
  Caution: The set of rcwa mappings over a ring does not form a ring under
  addition and multiplication -- it holds only the left distibutive law
  ( <M>a \cdot (b + c) = a \cdot b + a \cdot c</M>, but not
  necessary <M>(a + b) \cdot c = a \cdot c + b \cdot c</M> ), and the zero
  mapping multiplicatively is only a right zero element
  ( <M>a \cdot 0 = 0</M> for all <M>a</M>, but <M>0 \cdot a = 0</M> if and
  only if <M>0^a = 0</M> ).

</Section>

<!-- #################################################################### -->

<Section Label="sec:OrderOfRcwaMapping">
<Heading>Computing the order of an rcwa mapping</Heading>

  <ManSection>
    <Meth Name="Order" Arg="f"/>
    <Returns>
      the multiplicative order of the bijective rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      One of the (currently at least three) sufficient criteria for <A>f</A>
      having infinite order which are used by this package relies on a
      currently unproved hypothesis.
<Example>
<![CDATA[
gap> Order(Comm(a,b));
6
gap> Order(u);
infinity
]]>
</Example>
    </Description>
  </ManSection>

  The other criterium applies in case that <A>f</A> is tame:

  <ManSection>
    <Prop Name="IsTame" Arg="f" Label="Tame rcwa mapping"/>
    <Description>
      Indicates whether or not the rcwa mapping <A>f</A> is tame. <P/>

      See also <Ref Prop="IsTame" Label="Tame rcwa group"/> for rcwa groups.
<Example>
<![CDATA[
gap> IsTame(T);
false
gap> IsTame(a) or IsTame(b);
false
gap> IsTame(Comm(a,b));
true
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:TransMatGraphPrimeSet">
<Heading>Transition matrix, transition graph and trajectory</Heading>

  <ManSection>
    <Func Name="TransitionMatrix" Arg="f, deg"/>
    <Returns>
      the transition matrix of degree <A>deg</A>
      of the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
<Example>
<![CDATA[
gap> M := TransitionMatrix(a,7);;
gap> Display(M);
[ [  1,  0,  1,  0,  0,  1,  0 ],
  [  0,  1,  0,  0,  1,  1,  0 ],
  [  1,  0,  0,  1,  0,  0,  0 ],
  [  0,  1,  1,  0,  0,  0,  1 ],
  [  0,  1,  0,  0,  0,  1,  1 ],
  [  1,  0,  0,  0,  1,  0,  0 ],
  [  0,  0,  1,  1,  0,  0,  1 ] ]
gap> DeterminantMat(M);
-5
gap> M := TransitionMatrix(T,13);;
gap> Display(M*One(GF(2)));
 1 . . . . . . 1 . . . . .
 . . 1 . . . . 1 . . . . .
 . 1 . . . . . . . . 1 . .
 . . . . . 1 . . 1 . . . .
 1 . 1 . . . . . . . . . .
 . . . . . . . . 1 1 . . .
 . . . 1 . . . . . . . . .
 . . . . . . . . . . 1 1 .
 . . . . 1 . 1 . . . . . .
 . 1 . . . . . . . . . 1 .
 . . . . . 1 . . . 1 . . .
 . . . . 1 . . . . . . . 1
 . . . . . . 1 . . . . . 1
gap> DeterminantMat(M);
-16
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="TransitionGraph" Arg="f, m"/>
    <Returns>
      the transition graph for modulus <A>m</A> of the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      For technical reasons, the residue classes
      0(<A>m</A>) .. <A>m</A>-1(<A>m</A>) modulo the modulus <A>m</A>
      of <A>f</A> are identified with vertices named 1 .. <A>m</A>, in
      this order. <P/>

      The result is returned as a <Package>GRAPE</Package>-graph.
<Example>
<![CDATA[
gap> TransitionGraph(a,Modulus(a));
rec( isGraph := true, order := 4, group := Group(()), 
  schreierVector := [ -1, -2, -3, -4 ], 
  adjacencies := [ [ 1, 3 ], [ 1, 2, 3, 4 ], [ 2, 4 ], [ 1, 2, 3, 4 ] ], 
  representatives := [ 1, 2, 3, 4 ], names := [ 1, 2, 3, 4 ] )
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="OrbitsModulo" Arg="f, m"
          Label="OrbitsModulo for rcwa mapping"/>
    <Returns>
      the set of the subsets of <C>[0..<A>m</A>-1]</C> corresponding to the
      weakly-connected components of the transition graph for modulus
      <A>m</A> of the rcwa mapping <A>f</A>.
    </Returns>
    <Description>
      See also <Ref Meth="OrbitsModulo" Label="OrbitsModulo for rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> OrbitsModulo(Comm(a,b),9);
[ [ 0 ], [ 1, 4, 5, 6, 7 ], [ 2 ], [ 3 ], [ 8 ] ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="FactorizationOnConnectedComponents" Arg = "f, m"
          Label="FactorizationOnConnectedComponents for rcwa mapping"/>
    <Returns>
      the set of restrictions of the rcwa mapping <A>f</A> onto the
      weakly-connected components of its transition graph
      <M>\Gamma_{f,m}</M>.
    </Returns>
    <Description>
      These mappings have pairwisely disjoint supports, hence any two
      of them commute, and their product equals <A>f</A>.
<Example>
<![CDATA[
gap> sigma2 := RcwaMapping([[1, 0,1],[3,3,2],[1,0,1],[2,0,1],[1,0,1],[1,0,1],
>                           [1,-3,3],[3,3,2],[1,0,1],[1,0,1],[1,0,1],[1,0,1],
>                           [2, 0,1],[3,3,2],[1,0,1],[1,0,1],[1,0,1],[1,0,1]]);;
gap> sigma1 := StandardConjugate(sigma2);;
gap> sigma := sigma1*sigma2;
<bijective integral rcwa mapping with modulus 36>
gap> fact := FactorizationOnConnectedComponents(sigma,36);
[ <integral rcwa mapping with modulus 36>, 
  <integral rcwa mapping with modulus 36>, 
  <integral rcwa mapping with modulus 36> ]
gap> List(fact,MovedPoints);
[ Union of the residue classes 33(36), 34(36) and 35(36), 
  Union of the residue classes 9(36), 10(36) and 11(36), 
  <union of 23 residue classes (mod 36), +0/-2 elements> ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="Trajectory" Arg="f, n, val, cond"/>
    <Description>
      This function computes the trajectory of <A>n</A> under the
      rcwa mapping <A>f</A>. The parameter <A>val</A> can either specify the
      length of the sequence to be processed or be a <Q>stopping value</Q>
      such that the function stops when it reaches some iterate
      <C><A>n</A>\^(<A>f</A>\^k) = <A>val</A></C>, depending on whether
      <C><A>cond</A> = "length"</C> or <C><A>cond</A> = "stop"</C>.
<Example>
<![CDATA[
gap> Trajectory(a,8,100,"length");
[ 8, 12, 18, 27, 20, 30, 45, 34, 51, 38, 57, 43, 32, 48, 72, 108, 162, 243, 
  182, 273, 205, 154, 231, 173, 130, 195, 146, 219, 164, 246, 369, 277, 208, 
  312, 468, 702, 1053, 790, 1185, 889, 667, 500, 750, 1125, 844, 1266, 1899, 
  1424, 2136, 3204, 4806, 7209, 5407, 4055, 3041, 2281, 1711, 1283, 962, 
  1443, 1082, 1623, 1217, 913, 685, 514, 771, 578, 867, 650, 975, 731, 548, 
  822, 1233, 925, 694, 1041, 781, 586, 879, 659, 494, 741, 556, 834, 1251, 
  938, 1407, 1055, 791, 593, 445, 334, 501, 376, 564, 846, 1269, 952 ]
gap> Trajectory(T,27,1,"stop");
[ 27, 41, 62, 31, 47, 71, 107, 161, 242, 121, 182, 91, 137, 206, 103, 155, 
  233, 350, 175, 263, 395, 593, 890, 445, 668, 334, 167, 251, 377, 566, 283, 
  425, 638, 319, 479, 719, 1079, 1619, 2429, 3644, 1822, 911, 1367, 2051, 
  3077, 4616, 2308, 1154, 577, 866, 433, 650, 325, 488, 244, 122, 61, 92, 46, 
  23, 35, 53, 80, 40, 20, 10, 5, 8, 4, 2, 1 ]
gap> Length(Trajectory(RcwaMapping([[1,0,2],[5,-1,2]]),19,1,"stop"));
307
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="TrajectoryModulo" Arg="f, n, m, lng"/>
    <Func Name="TrajectoryModulo" Arg="f, n, lng"/>
    <Returns>
      the sequence <M>(n_i), i = 0, \dots, lng-1</M> with
      <M>n_i := n^{(f^i)}</M> mod <A>m</A> as a list.
    </Returns>
    <Description>
      If <A>m</A> is not given, it defaults to the modulus of <A>f</A>.
<Example>
<![CDATA[
gap> TrajectoryModulo(a,8,25);
[ 0, 0, 2, 3, 0, 2, 1, 2, 3, 2, 1, 3, 0, 0, 0, 0, 2, 3, 2, 1, 1, 2, 3, 1, 2 ]
gap> TrajectoryModulo(T,27,2,100);
[ 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 
  0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 
  1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="CoefficientsOnTrajectory" Arg="f, n, val, cond, all"/>
    <Description>
      This function computes <Q>accumulated coefficients</Q> on the
      trajectory of <A>n</A> under the rcwa mapping <A>f</A>. More precisely:
      it computes a list <C>c</C> of coefficient triples such that for any
      <C>k</C>, we have <C><A>n</A>\^(<A>f</A>\^(k-1)) = (c[k][1]*<A>n</A> +
      c[k][2])/c[k][3]</C>. The meaning of the arguments <A>val</A> and
      <A>cond</A> is the same as in <Ref Func="Trajectory"/>.
      If <C><A>all</A> = true</C>, the whole sequence of coefficient triples
      is returned, otherwise the result is only the last triple.
<Example>
<![CDATA[
gap> CoefficientsOnTrajectory(T,27,1,"stop",false);
[ 36472996377170786403, 195820718533800070543, 1180591620717411303424 ]
gap> (last[1]*27+last[2])/last[3];
1
gap> CoefficientsOnTrajectory(sigma,37,37,"stop",true);
[ [ 1, 0, 1 ], [ 1, 1, 1 ], [ 2, 4, 1 ], [ 3, 9, 1 ], [ 6, 18, 1 ], 
  [ 2, 5, 1 ], [ 2, 3, 1 ], [ 2, 1, 3 ], [ 2, 4, 3 ], [ 2, 7, 3 ], 
  [ 1, 2, 1 ], [ 3, 3, 2 ], [ 3, 5, 2 ], [ 3, 7, 2 ], [ 3, 3, 1 ], 
  [ 9, 15, 2 ], [ 27, 57, 4 ], [ 27, 57, 2 ], [ 9, 17, 2 ], [ 9, 13, 2 ], 
  [ 9, 15, 1 ], [ 3, 4, 1 ], [ 3, 2, 1 ], [ 1, 0, 1 ] ]
gap> List(last,c->(c[1]*37+c[2])/c[3]){[1..23]} = Cycle(sigma,37);
true
gap> CoefficientsOnTrajectory(a,8,10,"length",true);
[ [ 1, 0, 1 ], [ 3, 0, 2 ], [ 9, 0, 4 ], [ 27, 0, 8 ], [ 81, -8, 32 ], 
  [ 243, -24, 64 ], [ 729, -72, 128 ], [ 2187, -88, 512 ], 
  [ 6561, -264, 1024 ], [ 19683, -1816, 4096 ] ]
gap> CoefficientsOnTrajectory(r,x^3+x^2,x^3+x^2,"stop",true);
[ [ Z(2)^0, 0*Z(2), Z(2)^0 ], [ x^2+x+Z(2)^0, x^2+x, x^2+Z(2)^0 ], 
  [ x^4+x^2+Z(2)^0, x^4+x, x^4+Z(2)^0 ], 
  [ x^6+x^5+x^3+x+Z(2)^0, x^6+x^4+x^3+x^2, x^6+x^4+x^2+Z(2)^0 ], 
  [ x^8+x^4+Z(2)^0, x^7+x^6, x^8+Z(2)^0 ] ]
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:ActionOfMappingOnClasses">
<Heading>
  The action of an rcwa mapping on the set of residue classes
</Heading>

  <ManSection>
    <Attr Name="RespectedClassPartition" Arg="sigma"
          Label="Respected class partition for rcwa mapping"/>
    <Description>
      A partition of the base ring <M>R</M> into a finite number of residue
      classes, on which the bijective mapping <A>sigma</A> acts as a
      permutation, and on those elements <A>sigma</A> is affine.
      The partition is non-trivial as long as the modulus of <A>sigma</A>
      is not equal to 1. Such a partition exists always if <A>sigma</A> is
      tame. <P/>

      See also <Ref Attr="RespectedClassPartition"
      Label="Respected class partition for rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> g := RcwaMapping([[2,2,1],[1, 4,1],[1,0,2],[2,2,1],[1,-4,1],[1,-2,1]]);;
gap> h := RcwaMapping([[2,2,1],[1,-2,1],[1,0,2],[2,2,1],[1,-1,1],[1, 1,1]]);;
gap> pcp := RespectedClassPartition(g);
[ The residue class 0(6), The residue class 1(6), The residue class 3(6), 
  The residue class 4(6), The residue class 5(6), The residue class 2(12), 
  The residue class 8(12) ]
gap> G := Group(g,h);
<integral rcwa group with 2 generators>
gap> Action(G,pcp);
Group([ (1,6,2,5,3,7,4), (1,6,2,5)(3,7,4) ])
gap> Size(last);
5040
gap> Size(G);
infinity
]]>
</Example>
    </Description>
  </ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:NormalFormOfRcwaMapping">
<Heading>The normal form of an rcwa mapping</Heading>

  <ManSection>
    <Oper Name="ShortCycles" Arg="f, maxlng"/>
    <Description>
      Computes all <Q>single</Q> finite cycles, hence all finite cycles not
      belonging to an infinite series, of the rcwa mapping <A>f</A> of length at
      most <A>maxlng</A>.
      Since in &GAP;, permutations cannot move negative integers, rationals
      or even polynomials, the cycles are returned as lists, for example, the
      list <C>[-3,1,2,-2]</C> denotes the cycle <C>(-3,1,2,-2)</C>.
<Example>
<![CDATA[
gap> ShortCycles(a,2);
[ [ 0 ], [ 1 ], [ -1 ], [ 2, 3 ], [ -3, -2 ] ]
gap> ShortCycles(a,5);
[ [ 0 ], [ 1 ], [ -1 ], [ 2, 3 ], [ -3, -2 ], [ 4, 6, 9, 7, 5 ], 
  [ -9, -7, -5, -4, -6 ] ]
gap> ShortCycles(u,2);
[ [ 0 ], [ -1 ], [ 1, 2 ], [ 3, 5 ], [ -10, -6 ] ]
gap> ShortCycles(Comm(a,b),10);
[  ]
gap> ShortCycles(a*b,2);
[ [ 0 ], [ 2 ], [ 3 ], [ -26 ], [ 7 ], [ -3 ], [ -1 ] ]
gap> v := RcwaMapping([[-1,2,1],[1,-1,1],[1,-1,1]]);;
gap> w := RcwaMapping([[-1,3,1],[1,-1,1],[1,-1,1],[1,-1,1]]);;
gap> Order(v);
6
gap> Order(w);
8
gap> ShortCycles(v,10);
[ [ 0, 2, 1 ] ]
gap> ShortCycles(w,10);
[ [ 0, 3, 2, 1 ] ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="FlatConjugate" Arg="f"
          Label="Flat conjugate for rcwa mapping"/>
    <Description>
      Some flat representative of the conjugacy class of the tame
      bijective rcwa mapping <A>f</A> in the whole group RCWA(<M>R</M>).
      Since this is not defined uniquely, methods for this operation
      will just choose one such mapping. <P/>

      See also <Ref Attr="FlatConjugate"
                Label="Flat conjugate for rcwa group"/> for rcwa groups.
<Example>
<![CDATA[
gap> g_flat := FlatConjugate(g);
<bijective integral rcwa mapping with modulus 7, of order 7>
gap> Display(g_flat);

Bijective integral rcwa mapping with modulus 7, of order 7

                n mod 7                |                 n^f
---------------------------------------+--------------------------------------
  0                                    | n + 5
  1                                    | n + 3
  2                                    | n + 4
  3 6                                  | n - 3
  4                                    | n - 2
  5                                    | n - 4

]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="FlateningConjugator" Arg="f"
          Label="Flatening conjugator for rcwa mapping"/>
    <Description>
      An rcwa mapping mapping <A>x</A> such that <A>f</A>&circum;<A>x</A>
      is flat. This is certainly not defined uniquely, but it holds
      that <C>f&circum;FlateningConjugator(f) = FlatConjugate(f)</C>. <P/>

      See also <Ref Attr="FlateningConjugator"
                Label="Flatening conjugator for rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> g_toflat := FlateningConjugator(g);
<bijective integral rcwa mapping with modulus 12>
gap> Display(g_toflat);

Bijective integral rcwa mapping with modulus 12

               n mod 12                |                 n^f
---------------------------------------+--------------------------------------
   0  6                                | 7n/6
   1  7                                | (7n - 1)/6
   2                                   | (7n + 46)/12
   3  9                                | (7n - 9)/6
   4 10                                | (7n - 10)/6
   5 11                                | (7n - 11)/6
   8                                   | (7n + 16)/12

gap> g^g_toflat = g_flat;
true
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="StandardConjugate" Arg="f"/>
    <Description>
      Some <Q>nice</Q> canonical representative of the conjugacy class of the
      bijective integral rcwa mapping <A>f</A> in the whole group
      RCWA(<M>\Z</M>).
      Two integral rcwa mappings are conjugate in RCWA(<M>\Z</M>) if and only
      if their <Q>standard conjugates</Q> are equal.
<Example>
<![CDATA[
gap> w_std := StandardConjugate(w);
<bijective integral rcwa mapping with modulus 4, of order 8>
gap> Order(w_std);
8
gap> ShortCycles(w_std,8);
[ [ 0, 1, 2, 3 ] ]
gap> ab := Comm(a,b);
<bijective integral rcwa mapping with modulus 18>
gap> ab_std := StandardConjugate(ab);
<bijective integral rcwa mapping with modulus 7, of order 6>
gap> Display(ab_std);

Bijective integral rcwa mapping with modulus 7, of order 6

                n mod 7                |                 n^f
---------------------------------------+--------------------------------------
  0                                    | n
  1 2 3 4 5                            | n + 1
  6                                    | n - 5

gap> f := RcwaMapping([[1,1,1],[1, 4,1],[1,1,1],[2,-2,1],
>                      [1,0,2],[1,-5,1],[1,1,1],[2,-2,1]]);
<integral rcwa mapping with modulus 8>
gap> f_std := StandardConjugate(f);
<bijective integral rcwa mapping with modulus 3, of order 3>
gap> Display(f_std);

Bijective integral rcwa mapping with modulus 3, of order 3

                n mod 3                |                 n^f
---------------------------------------+--------------------------------------
  0 1                                  | n + 1
  2                                    | n - 2

]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="StandardizingConjugator" Arg="f"/>
    <Description>
      An rcwa mapping mapping <A>x</A>, such that <A>f</A>&circum;<A>x</A>
      is the <Q>standard</Q> representative of the conjugacy class of the
      bijective integral rcwa mapping <A>f</A> in the whole integral residue
      class-wise affine group.
<Example>
<![CDATA[
gap> ab_tostd := StandardizingConjugator(ab);
<bijective integral rcwa mapping with modulus 36>
gap> Display(ab_tostd);

Bijective integral rcwa mapping with modulus 36

               n mod 36                |                 n^f
---------------------------------------+--------------------------------------
   0  9 18 27                          | 28n/9
   1 19                                | (7n + 2)/9
   2 11 20 29                          | (28n + 7)/9
   3 12 21 30                          | (28n + 42)/9
   4 22                                | (7n + 44)/9
   5 23                                | (7n + 73)/9
   6                                   | (7n + 192)/18
   7 25                                | (7n + 32)/9
   8 17 26 35                          | (28n - 35)/9
  10 28                                | (7n + 20)/9
  13 31                                | (7n + 80)/9
  14 32                                | (7n + 55)/9
  15                                   | (7n + 93)/18
  16 34                                | (7n + 68)/9
  24                                   | (7n + 156)/18
  33                                   | (7n + 57)/18

gap> ab^ab_tostd = ab_std;
true
gap> f_tostd := StandardizingConjugator(f);
<bijective integral rcwa mapping with modulus 16>
gap> Display(f_tostd);

Bijective integral rcwa mapping with modulus 16

               n mod 16                |                 n^f
---------------------------------------+--------------------------------------
   0  8                                | 9n/8
   1  9                                | (9n - 1)/8
   2 10                                | (9n + 6)/8
   3 11                                | (9n + 5)/8
   4                                   | (9n + 44)/16
   5 13                                | (9n - 29)/8
   6 14                                | (9n - 6)/8
   7 15                                | (9n - 7)/8
  12                                   | (9n + 20)/16

gap> f^f_tostd = f_std;
true
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="CycleType" Arg="f"/>
    <Description>
      The <E>cycle type</E> of a tame integral rcwa mapping <A>f</A> is
      denoted by a list of two lists, where the first list contains the
      lengths of <Q>halved</Q> cycles, hence the cycles belonging to a series
      producing a cycle of only half of the <Q>usual</Q> length at some
      point, with the respective multiplicities, and the second list is the
      set of the lengths of all other cycles, sorted by increasing length.
<Example>
<![CDATA[
gap> CycleType(t);
[ [ 2 ], [  ] ]
gap> CycleType(RcwaMapping([[1,1,1],[1,-1,1]]));
[ [  ], [ 2 ] ]
gap> CycleType(v);
[ [ 6 ], [  ] ]
gap> CycleType(w);
[ [ 8 ], [  ] ]
gap> g := RcwaMapping([[-1,0,1],[1,2,1],[1,0,1],[1,-2,1]]);;
gap> CycleType(g);
[ [ 2 ], [ 1, 2 ] ]
gap> CycleType(Comm(a,b));
[ [  ], [ 1, 6 ] ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="IsConjugate" Arg="R, f, g"/>
    <Description>
      Checks whether the bijective rcwa mappings <A>f</A> and <A>g</A>
      are conjugate in the whole group RCWA(<M>R</M>), e.g. via comparing
      their <Q>standard conjugates</Q>.
      This may fail or run into an infinite loop.
<Example>
<![CDATA[
gap> IsConjugate(RCWA(Integers),w,w_std);
true
gap> IsConjugate(RCWA(Integers),a,b);
false
gap> IsConjugate(RCWA(Integers),ab,ab_std);
true
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="ContractionCentre" Arg="f, maxn, bound"/>
    <Description>
      Tries to compute the <Q>contraction centre</Q> of an rcwa mapping -
      assuming its existence this is the uniquely-defined finite subset
      <M>S_0</M> of the base ring <M>R</M> which is mapped bijectively onto
      itself under <A>f</A> and where for any <M>x</M> in <M>R</M> there is an
      integer <M>k</M> such that the image of <M>x</M> under the <M>k</M>-th
      power of <M>f</M> lies in <M>S_0</M>.
      The mapping <A>f</A> is assumed to be contracting.
      As this problem seems to be computationally undecidable methods will be
      probabilistic. The argument <A>maxn</A> is a bound on the starting
      value and <A>bound</A> is a bound on the elements of the sequence to be
      searched.
      If the limit <A>bound</A> is exceeded, an Info message on some Info
      level of <C>InfoRCWA</C> is given.
<Example>
<![CDATA[
gap> S0 := ContractionCentre(T,100,1000);
[ -136, -91, -82, -68, -61, -55, -41, -37, -34, -25, -17, -10, -7, -5, -1, 0,
  1, 2 ]
]]>
</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="Restriction" Arg="g, f"
          Label="Restriction of an rcwa mapping"/>
    <Returns> the restriction of <A>g</A> by <A>f</A>. </Returns>
    <Description>
      The mapping <A>f</A> has to be injective. The support of the returned
      mapping is a subset of the image of <A>f</A>. If <A>f</A> is bijective
      the returned mapping is just the conjugate of <A>g</A> by <A>f</A>.
      <P/>

      See also <Ref Oper="Restriction" Label="Restriction of an rcwa group"/>
      for rcwa groups.
<Example>
<![CDATA[
gap> Comm(Restriction(a,RcwaMapping([[2,0,1]])),
>         Restriction(u,RcwaMapping([[2,1,1]])));
IdentityMapping( Integers )
]]>
</Example>      
    </Description>
  </ManSection>

  <Alt Only="HTML">&nbsp;</Alt>

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->


